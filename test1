/** @jsx jsx */
import { React, jsx, AllWidgetProps } from 'jimu-core';
import { JimuMapView, JimuMapViewComponent } from 'jimu-arcgis';

/**
 * Sağlam iki uçlu (dual-thumb) slider
 * Pointer Events kullan, her iki uç sorunsuz hareket etsin.
 */
type DualRangeSliderProps = {
  min: number;
  max: number;
  step?: number;
  minValue: number;
  maxValue: number;
  onChange: (newMin: number, newMax: number) => void;
};

const DualRangeSlider: React.FC<DualRangeSliderProps> = ({
  min,
  max,
  step = 1,
  minValue,
  maxValue,
  onChange
}) => {
  const trackRef = React.useRef<HTMLDivElement>(null);
  const activeRef = React.useRef<null | { thumb: 'min' | 'max'; pointerId: number }>(null);

  const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));
  const valueToPercent = (v: number) => ((v - min) * 100) / (max - min);
  const snap = (v: number) => Math.round(v / step) * step;
  const handlePointerDown = (thumb: 'min' | 'max') => (e: React.PointerEvent) => {
    e.preventDefault();
    e.stopPropagation();
    activeRef.current = { thumb, pointerId: e.pointerId };
    try {
      (e.currentTarget as HTMLElement).setPointerCapture?.(e.pointerId);
    } catch {}
  };

  const handlePointerMove = (thumb: 'min' | 'max') => (e: React.PointerEvent) => {
    const active = activeRef.current;
    if (!active || active.thumb !== thumb || active.pointerId !== e.pointerId || !trackRef.current) {
      return;
    }

    const rect = trackRef.current.getBoundingClientRect();
    const ratio = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    let val = snap(min + ratio * (max - min));
    val = clamp(val, min, max);

    if (thumb === 'min') {
      const newMin = Math.min(val, maxValue);
      if (newMin !== minValue) {
        onChange(newMin, maxValue);
      }
    } else {
      const newMax = Math.max(val, minValue);
      if (newMax !== maxValue) {
        onChange(minValue, newMax);
      }
    }
  };

  const handlePointerUp = (thumb: 'min' | 'max') => (e: React.PointerEvent) => {
    const active = activeRef.current;
    if (active && active.thumb === thumb && active.pointerId === e.pointerId) {
      activeRef.current = null;
      try {
        (e.currentTarget as HTMLElement).releasePointerCapture?.(e.pointerId);
      } catch {}
    }
  };

  const minPercent = valueToPercent(minValue);
  const maxPercent = valueToPercent(maxValue);

  return (
    <div style={{ width: '100%', padding: '8px 0', touchAction: 'none' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 13, fontWeight: 600, marginBottom: 6 }}>
        <span>Min: {minValue}</span>
        <span>Max: {maxValue}</span>
      </div>

      <div ref={trackRef} style={{ position: 'relative', height: 36, userSelect: 'none' }}>
        {/* Track */}
        <div
          style={{
            position: 'absolute',
            top: 16,
            left: 0,
            right: 0,
            height: 4,
            background: '#ddd',
            borderRadius: 2
          }}
        />
        {/* Selected range */}
        <div
          style={{
            position: 'absolute',
            top: 16,
            left: `${minPercent}%`,
            width: `${Math.max(0, maxPercent - minPercent)}%`,
            height: 4,
            background: '#0079c1',
            borderRadius: 2
          }}
        />
        {/* Min thumb */}
        <div
          onPointerDown={handlePointerDown('min')}
          onPointerMove={handlePointerMove('min')}
          onPointerUp={handlePointerUp('min')}
          onPointerCancel={handlePointerUp('min')}
          style={{
            position: 'absolute',
            top: 8,
            left: `calc(${minPercent}% - 8px)`,
            width: 16,
            height: 16,
            background: '#fff',
            border: '2px solid #0079c1',
            borderRadius: '50%',
            cursor: 'pointer',
            boxShadow: '0 0 2px rgba(0,0,0,0.4)',
            zIndex: 2
          }}
          title="Min"
        />
        {/* Max thumb */}
        <div
          onPointerDown={handlePointerDown('max')}
          onPointerMove={handlePointerMove('max')}
          onPointerUp={handlePointerUp('max')}
          onPointerCancel={handlePointerUp('max')}
          style={{
            position: 'absolute',
            top: 8,
            left: `calc(${maxPercent}% - 8px)`,
            width: 16,
            height: 16,
            background: '#fff',
            border: '2px solid #0079c1',
            borderRadius: '50%',
            cursor: 'pointer',
            boxShadow: '0 0 2px rgba(0,0,0,0.4)',
            zIndex: 2
          }}
          title="Max"
        />
      </div>
    </div>
  );
};

/** Filtre tipi */
interface FilterCondition {
  id: string;
  field: string;
  min: number;
  max: number;
}

interface State {
  conditions: FilterCondition[];
  selectedField: string;
  tempMin: number;
  tempMax: number;
  activeWhere: string | null;
  usidInput: string;
  activeUsid: string[] | null;
  usidError: string | null;
}

const FIELD_RANGES: Record<string, { min: number; max: number; def: [number, number] }> = {
  RSRP: { min: -140, max: -50, def: [-140, -50] },
  RSRQ: { min: -25, max: 0, def: [-25, 0] },
  SNR: { min: -20, max: 35, def: [-10, 35] }
};

interface LegendSegment {
  from?: number;
  to?: number;
  color: string;
  label: string;
}

const KPI_LEGENDS: Record<string, LegendSegment[]> = {
  RSRP: [
    { from: FIELD_RANGES.RSRP.min, to: -118, color: '#ff00ff', label: '< -118' },
    { from: -118, to: -115, color: '#ff0000', label: '-118 to -115' },
    { from: -115, to: -110, color: '#ff8c00', label: '-115 to -110' },
    { from: -110, to: -105, color: '#ffd700', label: '-110 to -105' },
    { from: -105, to: -95, color: '#40e0d0', label: '-105 to -95' },
  { from: -95, to: -85, color: '#0000ff', label: '-95 to -85' },
  { from: -85, to: FIELD_RANGES.RSRP.max, color: '#008000', label: '>= -85' }
  ],
  RSRQ: [
    { from: FIELD_RANGES.RSRQ.min, to: -16, color: '#ff0000', label: '< -16' },
    { from: -16, to: -10, color: '#ffd700', label: '-16 to -10' },
  { from: -10, to: -5, color: '#0000ff', label: '-10 to -5' },
  { from: -5, to: FIELD_RANGES.RSRQ.max, color: '#008000', label: '>= -5' }
  ],
  SNR: [
    { from: FIELD_RANGES.SNR.min, to: -10, color: '#ff0000', label: '< -10' },
    { from: -10, to: -5, color: '#ff8c00', label: '-10 to -5' },
    { from: -5, to: 0, color: '#ffd700', label: '-5 to 0' },
    { from: 0, to: 5, color: '#40e0d0', label: '0 to 5' },
    { from: 5, to: 10, color: '#0000ff', label: '5 to 10' },
  { from: 10, to: FIELD_RANGES.SNR.max, color: '#008000', label: '>= 10' }
  ]
};

export default class Widget extends React.PureComponent<AllWidgetProps<any>, State> {
  state: State;
  private mapView: JimuMapView = null;
  private viewHandles: any[] = [];
  private layerHandles: any[] = [];
  private sublayerHandles: any[] = [];

  constructor(props: AllWidgetProps<any>) {
    super(props);
    this.state = {
      conditions: [],
      selectedField: 'RSRP',
      tempMin: FIELD_RANGES.RSRP.def[0],
      tempMax: FIELD_RANGES.RSRP.def[1],
      activeWhere: null,
      usidInput: '',
  activeUsid: null,
      usidError: null
    };
  }

  componentWillUnmount(): void {
    this.removeAllHandles();
  }

  removeAllHandles = () => {
    const remove = (h: any) => { try { h?.remove?.(); } catch {} };
    this.viewHandles.forEach(remove);
    this.layerHandles.forEach(remove);
    this.sublayerHandles.forEach(remove);
    this.viewHandles = [];
    this.layerHandles = [];
    this.sublayerHandles = [];
  };

  onActiveViewChange = (jimuMapView: JimuMapView) => {
    if (!jimuMapView) return;
    this.mapView = jimuMapView;
    this.removeAllHandles();

    const v: any = this.mapView.view;
    if (!v) return;

    // Yeni layerView oluştuğunda (zoom/scale ile görünür olduğunda) tekrar uygula
    const hCreate = v.on('layerview-create', () => {
      if (this.state.activeWhere) this.applyActiveWhereToAll();
    });

    // Layerview silinirse/yeniden yaratılırsa tekrar uygula
    const hDestroy = v.on('layerview-destroy', () => {
      if (this.state.activeWhere) this.applyActiveWhereToAll();
    });

    // Navigasyon bittiğinde (zoom/pan sonrası) tekrar uygula
    const hStationary = v.watch('stationary', (st: boolean) => {
      if (st && this.state.activeWhere) this.applyActiveWhereToAll();
    });

    // Katman listesinde değişiklik olursa
    const hLayersChange = v.map?.allLayers?.on?.('change', () => {
      if (this.state.activeWhere) this.applyActiveWhereToAll();
    });

    const popupHandles: any[] = [];
    const popup = v.popup;
    if (popup?.watch) {
      const hPopupVisible = popup.watch('visible', () => {
        if (this.state.activeWhere) {
          setTimeout(() => this.applyActiveWhereToAll(), 0);
        }
      });
      if (hPopupVisible) popupHandles.push(hPopupVisible);

      const hPopupSelected = popup.watch('selectedFeature', () => {
        if (this.state.activeWhere) {
          setTimeout(() => this.applyActiveWhereToAll(), 0);
        }
      });
      if (hPopupSelected) popupHandles.push(hPopupSelected);
    }

    this.viewHandles.push(hCreate, hDestroy, hStationary, hLayersChange, ...popupHandles);
  };

  onFieldChange = (e: any) => {
    const field = e.target.value;
    const r = FIELD_RANGES[field];
    this.setState({
      selectedField: field,
      tempMin: r.def[0],
      tempMax: r.def[1]
    });
  };

  onSliderChange = (newMin: number, newMax: number) => {
    // Slider sürüklenirken sadece geçici değerler güncellenir
    this.setState({ tempMin: newMin, tempMax: newMax });
  };

  addCondition = () => {
    const { selectedField, tempMin, tempMax, conditions } = this.state;
    const i = conditions.findIndex((c: FilterCondition) => c.field === selectedField);

    let next: FilterCondition[];
    if (i >= 0) {
      next = [...conditions];
      next[i] = { ...next[i], min: tempMin, max: tempMax };
    } else {
      next = [...conditions, { id: Date.now().toString(), field: selectedField, min: tempMin, max: tempMax }];
    }

    this.setState({ conditions: next }, () => this.applyFromConditions());
  };

  removeCondition = (id: string) => {
    const next = this.state.conditions.filter((c: FilterCondition) => c.id !== id);
    this.setState({ conditions: next }, () => this.applyFromConditions());
  };

  buildWhere = (conds: FilterCondition[], usids?: string[] | null) => {
    const parts: string[] = [];

    if (conds?.length) {
      conds.forEach((c: FilterCondition) => {
        parts.push(`${c.field} >= ${c.min} AND ${c.field} <= ${c.max}`);
      });
    }

    if (Array.isArray(usids) && usids.length) {
      const clauses = usids
        .map((value: string) => {
          const trimmed = value.trim();
          if (!trimmed) return null;
          const isNumeric = /^-?\d+(?:\.\d+)?$/.test(trimmed);
          const sanitized = trimmed.replace(/'/g, "''");
          return isNumeric ? `USID = ${sanitized}` : `USID = '${sanitized}'`;
        })
        .filter(Boolean) as string[];

      if (clauses.length === 1) {
        parts.push(clauses[0]);
      } else if (clauses.length > 1) {
        parts.push(`(${clauses.join(' OR ')})`);
      }
    }

    return parts.length ? parts.join(' AND ') : null;
  };

  applyFromConditions = () => {
    const { conditions, activeUsid } = this.state;
    const where = this.buildWhere(conditions, activeUsid);

    if (!where) {
      this.setState({ activeWhere: null }, () => this.clearLayerDefinitions());
      return;
    }

    this.setState({ activeWhere: where }, () => this.applyActiveWhereToAll());
  };

  onUsidInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    this.setState({ usidInput: e.target.value, usidError: null });
  };

  onUsidKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      this.applyUsidFilter();
    }
  };

  applyUsidFilter = () => {
    const raw = (this.state.usidInput || '').trim();

    if (!raw) {
      this.setState({ activeUsid: null, usidError: null }, () => this.applyFromConditions());
      return;
    }

    const entries = raw
      .split(',')
      .map(item => item.trim())
      .filter(Boolean);

    if (!entries.length) {
      this.setState({ activeUsid: null, usidError: null }, () => this.applyFromConditions());
      return;
    }

    this.setState({ activeUsid: entries, usidError: null }, () => this.applyFromConditions());
  };

  clearUsid = () => {
    this.setState({ usidInput: '', activeUsid: null, usidError: null }, () => this.applyFromConditions());
  };

  clearLayerDefinitions = () => {
    if (!this.mapView) return;

    const view: any = this.mapView.view;
    const layers = view?.map?.allLayers;
  if (!layers) return;

    layers.forEach((layer: any) => {
      if (!layer) return;

      if (layer.type === 'feature') {
        try {
          if (typeof layer.definitionExpression !== 'undefined') {
            layer.definitionExpression = null;
          }
        } catch {}

        try {
          view.whenLayerView(layer).then((lv: any) => {
            try { if (lv) lv.filter = null; } catch {}
          }).catch(() => {});
        } catch {}
      }

      if (layer.type === 'map-image' && layer.allSublayers) {
        layer.allSublayers.forEach((sublayer: any) => {
          try {
            if (typeof sublayer.definitionExpression !== 'undefined') {
              sublayer.definitionExpression = null;
            }
          } catch {}
        });

        try { layer.refresh && layer.refresh(); } catch {}
      }
    });
  };

  renderLegend = (field: string): React.ReactNode => {
    const segments = KPI_LEGENDS[field];
    if (!segments?.length) return null;

    const info = FIELD_RANGES[field];
    if (!info) return null;

    const total = info.max - info.min;
    if (total <= 0) return null;

    const toPercent = (start: number, end: number) => {
      const clampedStart = Math.max(start, info.min);
      const clampedEnd = Math.min(end, info.max);
      const span = clampedEnd - clampedStart;
      return Math.max((span / total) * 100, 0);
    };

    return (
      <div style={{ marginTop: 12 }}>
        <div
          style={{
            display: 'flex',
            height: 8,
            borderRadius: 4,
            overflow: 'hidden',
            boxShadow: '0 0 2px rgba(0,0,0,0.2)'
          }}
        >
          {segments.map((segment, idx) => {
            const widthPercent = toPercent(segment.from ?? info.min, segment.to ?? info.max);
            if (widthPercent <= 0) {
              return null;
            }

            return (
              <div
                key={`${field}-band-${idx}`}
                style={{
                  width: `${widthPercent}%`,
                  backgroundColor: segment.color
                }}
                title={segment.label}
              />
            );
          })}
        </div>
        <div style={{ display: 'flex', marginTop: 4, fontSize: 10, color: '#333' }}>
          {segments.map((segment, idx) => {
            const widthPercent = toPercent(segment.from ?? info.min, segment.to ?? info.max);
            if (widthPercent <= 0) {
              return null;
            }

            return (
              <div
                key={`${field}-label-${idx}`}
                style={{
                  width: `${widthPercent}%`,
                  textAlign: 'center',
                  padding: '2px 0',
                  whiteSpace: 'nowrap',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis'
                }}
                title={segment.label}
              >
                {segment.label}
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  isTargetFeatureLayer = (layer: any): boolean => {
    const fields = layer?.fields || [];
    return fields.some((f: any) => {
      const n = (f?.name || '').toUpperCase();
      return n.includes('RSRP') || n.includes('RSRQ') || n.includes('SNR');
    });
  };

  isTargetSublayer = (sublayer: any): boolean => {
    const title = (sublayer?.title || '').toUpperCase();
    return title.includes('RSRP') || title.includes('RSRQ') || title.includes('SNR');
  };

  applyActiveWhereToAll = () => {
    const where = this.state.activeWhere;
    if (!this.mapView || !where) return;
    const view: any = this.mapView.view;
    const layers = view?.map?.allLayers;
    if (!layers) return;

    // Mevcut sublayer watcher'larını temizle (yeniden eklenecek)
    this.layerHandles.forEach(h => { try { h?.remove?.(); } catch {} });
    this.layerHandles = [];
    this.sublayerHandles.forEach(h => { try { h?.remove?.(); } catch {} });
    this.sublayerHandles = [];

    const activeWhereSnapshot = where;

    layers.forEach((layer: any) => {
      if (!layer) return;

      // FeatureLayer
      if (layer.type === 'feature') {
        if (this.isTargetFeatureLayer(layer)) {
          try { layer.definitionExpression = where; } catch {}
          if (typeof layer.watch === 'function') {
            const hLayerDef = layer.watch('definitionExpression', (value: string) => {
              if (this.state.activeWhere !== activeWhereSnapshot) return;
              if (value !== activeWhereSnapshot) {
                try { layer.definitionExpression = activeWhereSnapshot; } catch {}
              }
            });
            if (hLayerDef) this.layerHandles.push(hLayerDef);
          }
          try {
            view.whenLayerView(layer).then((lv: any) => {
              try { lv.filter = { where: activeWhereSnapshot }; } catch {}
              if (typeof lv?.watch === 'function') {
                const hLayerFilter = lv.watch('filter', (filterValue: any) => {
                  if (this.state.activeWhere !== activeWhereSnapshot) return;
                  const currentWhere = filterValue?.where;
                  if (!currentWhere || currentWhere !== activeWhereSnapshot) {
                    try { lv.filter = { where: activeWhereSnapshot }; } catch {}
                  }
                });
                if (hLayerFilter) this.layerHandles.push(hLayerFilter);
              }
            }).catch(() => {});
          } catch {}
        }
      }

      // MapImageLayer
      if (layer.type === 'map-image' && layer.allSublayers) {
        layer.allSublayers.forEach((sublayer: any) => {
          if (!this.isTargetSublayer(sublayer)) return;
          try {
            if (typeof sublayer.definitionExpression !== 'undefined') {
              sublayer.definitionExpression = where;
            }
          } catch {}

          if (typeof sublayer.watch === 'function') {
            const hSubDef = sublayer.watch('definitionExpression', (value: string) => {
              if (this.state.activeWhere !== activeWhereSnapshot) return;
              if (value !== activeWhereSnapshot) {
                try {
                  if (typeof sublayer.definitionExpression !== 'undefined') {
                    sublayer.definitionExpression = activeWhereSnapshot;
                  }
                } catch {}
              }
            });
            if (hSubDef) this.sublayerHandles.push(hSubDef);
          }

          // Sublayer görünürlük/scale etkilenirse yeniden uygula
          const hVis = sublayer.watch && sublayer.watch('visible', () => {
            if (this.state.activeWhere !== activeWhereSnapshot) return;
            try {
              if (typeof sublayer.definitionExpression !== 'undefined') {
                sublayer.definitionExpression = activeWhereSnapshot;
              }
            } catch {}
          });
          const hMinScale = sublayer.watch && sublayer.watch('minScale', () => {
            if (this.state.activeWhere !== activeWhereSnapshot) return;
            try {
              if (typeof sublayer.definitionExpression !== 'undefined') {
                sublayer.definitionExpression = activeWhereSnapshot;
              }
            } catch {}
          });
          const hMaxScale = sublayer.watch && sublayer.watch('maxScale', () => {
            if (this.state.activeWhere !== activeWhereSnapshot) return;
            try {
              if (typeof sublayer.definitionExpression !== 'undefined') {
                sublayer.definitionExpression = activeWhereSnapshot;
              }
            } catch {}
          });

          [hVis, hMinScale, hMaxScale].forEach(h => { if (h) this.sublayerHandles.push(h); });

        });

        try { layer.refresh && layer.refresh(); } catch {}
      }
    });
  };

  clearFilter = () => {
    if (!this.mapView) return;
    this.clearLayerDefinitions();
    this.removeAllHandles();

    const currentField = FIELD_RANGES[this.state.selectedField] || FIELD_RANGES.RSRP;

    this.setState({
      activeWhere: null,
      conditions: [],
      activeUsid: null,
      usidInput: '',
      usidError: null,
      tempMin: currentField.def[0],
      tempMax: currentField.def[1]
    });
  };

  render() {
    const { conditions, selectedField, tempMin, tempMax, activeWhere, usidInput, activeUsid, usidError } = this.state;
    const current = FIELD_RANGES[selectedField];

    return (
      <div style={{ padding: '15px', width: '100%', height: '100%', backgroundColor: '#fff', overflow: 'auto' }}>
        <JimuMapViewComponent
          useMapWidgetId={this.props.useMapWidgetIds?.[0]}
          onActiveViewChange={this.onActiveViewChange}
        />

        <div>
          <h3 style={{ margin: '0 0 15px 0', fontSize: 18, fontWeight: 'bold' }}>
            IQI Custom Filter
          </h3>

          {/* Alan Seçimi */}
          <div style={{ marginBottom: 12 }}>
            <label style={{ display: 'block', marginBottom: 5, fontSize: 14, fontWeight: 600 }}>
              KPI Selection : 
            </label>
            <select
              value={selectedField}
              onChange={this.onFieldChange}
              style={{ width: '100%', padding: 8, fontSize: 14, border: '1px solid #ccc', borderRadius: 4 }}
            >
                <option value="RSRP">RSRP</option>
                <option value="RSRQ">RSRQ</option>
                <option value="SNR">SNR</option>
            </select>
          </div>

          {/* İki uçlu Slider */}
          <DualRangeSlider
            min={current.min}
            max={current.max}
            step={1}
            minValue={tempMin}
            maxValue={tempMax}
            onChange={this.onSliderChange}
          />

          {this.renderLegend(selectedField)}

          {/* USID Arama */}
          <div style={{ marginBottom: 16 }}>
            <label style={{ display: 'block', marginBottom: 5, fontSize: 14, fontWeight: 600 }}>
              USID Filter:
            </label>
            <div style={{ display: 'flex', gap: 8 }}>
              <input
                type="text"
                value={usidInput}
                onChange={this.onUsidInputChange}
                onKeyDown={this.onUsidKeyDown}
                placeholder="Enter USID or comma-separated USIDs"
                style={{ flex: 1, padding: 8, fontSize: 10, border: '1px solid #ccc', borderRadius: 4 }}
              />
              <button
                onClick={this.applyUsidFilter}
                style={{
                  padding: '8px 12px',
                  backgroundColor: '#28a745',
                  color: '#fff',
                  border: 'none',
                  borderRadius: 4,
                  fontSize: 14,
                  fontWeight: 600,
                  cursor: 'pointer'
                }}
              >
                Search
              </button>
              <button
                onClick={this.clearUsid}
                disabled={!usidInput && !(activeUsid && activeUsid.length)}
                style={{
                  padding: '8px 12px',
                  backgroundColor: usidInput || (activeUsid && activeUsid.length) ? '#6c757d' : '#ccc',
                  color: '#fff',
                  border: 'none',
                  borderRadius: 4,
                  fontSize: 14,
                  fontWeight: 600,
                  cursor: usidInput || (activeUsid && activeUsid.length) ? 'pointer' : 'not-allowed'
                }}
              >
                Reset
              </button>
            </div>
            {activeUsid && activeUsid.length > 0 && (
              <div style={{ marginTop: 6, fontSize: 12, color: '#0079c1' }}>
                USID Filter applied to :   <strong>{activeUsid.join(', ')}</strong>
              </div>
            )}
            {usidError && (
              <div style={{ marginTop: 6, fontSize: 12, color: '#dc3545' }}>
                {usidError}
              </div>
            )}
          </div>

          {/* Koşul Ekle (otomatik uygular) */}
          <button
            onClick={this.addCondition}
            style={{
              width: '100%',
              padding: 10,
              backgroundColor: '#0079c1',
              color: '#fff',
              border: 'none',
              borderRadius: 4,
              fontSize: 14,
              fontWeight: 600,
              cursor: 'pointer',
              marginBottom: 16
            }}
          >
            + Add Condition
          </button>

          {/* Aktif Koşullar */}
          {conditions.length > 0 && (
            <div style={{ marginBottom: 16 }}>
              <h4 style={{ fontSize: 14, fontWeight: 600, marginBottom: 8 }}>Active Conditions:</h4>
              {conditions.map((cond, idx) => (
                <div
                  key={cond.id}
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '8px 10px',
                    backgroundColor: '#f5f5f5',
                    borderRadius: 4,
                    marginBottom: 8,
                    fontSize: 13
                  }}
                >
                  <span>
                    {idx > 0 && <strong>AND </strong>}
                    <strong>{cond.field}</strong>: {cond.min} → {cond.max}
                  </span>
                  <button
                    onClick={() => this.removeCondition(cond.id)}
                    style={{
                      padding: '4px 8px',
                      backgroundColor: '#d9534f',
                      color: 'white',
                      border: 'none',
                      borderRadius: 3,
                      fontSize: 12,
                      cursor: 'pointer'
                    }}
                  >
                    ✕
                  </button>
                </div>
              ))}
            </div>
          )}

          {/* Temizle */}
          <div style={{ display: 'flex', gap: 10 }}>
            <button
              onClick={this.clearFilter}
              disabled={!activeWhere}
              style={{
                flex: 1,
                padding: 12,
                backgroundColor: activeWhere ? '#dc3545' : '#ccc',
                color: '#fff',
                border: 'none',
                borderRadius: 4,
                fontSize: 14,
                fontWeight: 600,
                cursor: activeWhere ? 'pointer' : 'not-allowed'
              }}
            >
              ✗ Clear
            </button>
          </div>

          {/* Bilgi */}
          <div
            style={{
              marginTop: 20,
              padding: 10,
              backgroundColor: '#e7f3ff',
              borderLeft: '4px solid #0079c1',
              fontSize: 12,
              borderRadius: 4
            }}
          >
            CQX Quality Thresholds<br />
            Weighted acceptable coverage (RSRP greater than -115dBm).<br />
            and poor signal quality (scaled RSRQ &lt;-18 dB) 4G and 5G devices on 4G network
          </div>
        </div>
      </div>
    );
  }
}
