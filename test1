import { React, getAppStore } from 'jimu-core'
import maplibregl, { type LayerSpecification, type Map as MapLibreMap, type StyleSpecification, type CustomRenderMethodInput } from 'maplibre-gl'
import MapLibreWorker from 'maplibre-gl/dist/maplibre-gl-csp-worker'
import { type IMConfig, type Config, type LayerConfig } from '../../config'
import { ThreeD, type SectorData } from '../../lib/three-d-sectors'
import cubeIcon from '../../../cube.svg'
import logoImage from '../../../logo.png'

interface MapLibreViewProps {
  config: IMConfig
}

const DEFAULT_CENTER: [number, number] = [-98.5795, 39.8283]
const DEFAULT_ZOOM = 3.2
const DEFAULT_PITCH = 0
const DEFAULT_BEARING = 0
const DEFAULT_BASEMAP_STYLE_URL = 'https://bird.web.abc.com/oauth21/api/visualization/assets/styles/light/style.json'

const isbirdProtectedUrl = (url: string): boolean => {
  try {
    const parsed = new URL(url, window.location.origin)
    const host = parsed.hostname.toLowerCase()
    return (
      host === 'bird.web.abc.com' || host.endsWith('.bird.web.abc.com') ||
      host === 'bird.research.abc.com' || host.endsWith('.bird.research.abc.com')
    )
  } catch (_ignored) {
    return false
  }
}

const DEFAULT_TOKEN_URL = 'https://egisportal.dev.abc.com/egis-bird-client/token'
const DEFAULT_SECTOR_ENDPOINT = 'https://bird.web.abc.com/oauth21/api/sector/tile/{sector_name}/12.0/RSRP/style.json'
const DEFAULT_METADATA_SECTOR_STYLE_URL = 'https://bird.web.abc.com/oauth21/api/metadata/sector/tile/style.json'
const DEFAULT_COVERAGE_STYLE_URL = 'https://bird.web.abc.com/oauth21/api/vector/styles/all/style.json?coverageLayer={coverage_layer}'
const DEFAULT_BBOX_COVERAGE_ENDPOINT = 'https://bird.web.abc.com/oauth21/api/bird/bbox/{min_lng}/{min_lat}/{max_lng}/{max_lat}/output.json?resolution=4.0'
const DEFAULT_TOKEN_EXPIRY_SECONDS = 3599
const MIN_REFRESH_OFFSET_SECONDS = 60
const STATUS_POLL_INTERVAL_MS = 1000
const CELL_NAME = 'NWL91056_7C_1' 
const DEFAULT_SECTOR_NAME = CELL_NAME || 'replace-with-sector-name'
const ENABLE_WIDGET_3D_BUILDINGS_LAYER = false



type CoverageLayer = 'rsrp_dbm_poly' | 'sector_id_poly' | 'usid_poly' | 'bin_state_poly' | 'sector_counter_poly'

type OptimizationLayerType = 'none' | 'bin_state_pre' | 'bin_state_post' | 'bin_state_diff' | 
  'sinr_pre' | 'sinr_post' | 'sinr_floor' | 'sinr_delta' | 
  'sector_id_pre' | 'sector_id_post' | 'sector_id_diff' | 
  'rsrp_pre' | 'rsrp_post' | 'rsrp_diff' | 
  'user_density'

const OPTIMIZATION_LAYER_OPTIONS: Array<{ value: OptimizationLayerType, label: string, category: string }> = [
  { value: 'none', label: 'None (Hide Layer)', category: 'Control' },
  { value: 'bin_state_pre', label: 'Pre Optimization', category: 'Bin State' },
  { value: 'bin_state_post', label: 'Post Optimization', category: 'Bin State' },
  { value: 'bin_state_diff', label: 'Difference', category: 'Bin State' },
  { value: 'sinr_pre', label: 'Pre Optimization', category: 'SINR' },
  { value: 'sinr_post', label: 'Post Optimization', category: 'SINR' },
  { value: 'sinr_floor', label: 'Floor Data', category: 'SINR' },
  { value: 'sinr_delta', label: 'Delta', category: 'SINR' },
  { value: 'sector_id_pre', label: 'Pre Optimization', category: 'Sector ID' },
  { value: 'sector_id_post', label: 'Post Optimization', category: 'Sector ID' },
  { value: 'sector_id_diff', label: 'Difference', category: 'Sector ID' },
  { value: 'rsrp_pre', label: 'Pre Optimization', category: 'RSRP' },
  { value: 'rsrp_post', label: 'Post Optimization', category: 'RSRP' },
  { value: 'rsrp_diff', label: 'Difference', category: 'RSRP' },
  { value: 'user_density', label: 'User Density', category: 'User Density' }
]

const COVERAGE_LAYER_OPTIONS: Array<{ value: CoverageLayer, label: string }> = [
  { value: 'rsrp_dbm_poly', label: 'rsrp_dbm_poly' },
  { value: 'sector_id_poly', label: 'sector_id_poly' },
  { value: 'usid_poly', label: 'usid_poly' },
  { value: 'bin_state_poly', label: 'bin_state_poly' },
  { value: 'sector_counter_poly', label: 'sector_counter_poly' }
]

interface ApiVisibilityEntry {
  label: string
  enabled: boolean
}

interface BasemapLayerEntry {
  id: string
  label: string
  type: string
  category: 'background' | 'road' | 'water' | 'other' | 'terrain'
}

const TERRAIN_TOGGLE_ID = '__terrain__'

const normalizeBasemapLayerKey = (value: string): string => {
  return String(value ?? '')
    .toLowerCase()
    .replace(/[-_]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
}

const FIXED_VISIBLE_BASEMAP_LAYER_KEYS = new Set<string>([
  'water',
  'highway path',
  'highway minor',
  'highway major casing',
  'highway motorway inner',
  'highway motorway bridge inner',
  // Place/City labels
  'place other',
  'place suburb',
  'place village',
  'place town',
  'place city',
  'place capital',
  'place label city',
  'place label city en',
  'place country minor',
  'place country major',
  'country label',
  'country label en',
  // Road/Street labels
  'road major label',
  'road major label en'
])

const TOGGLEABLE_BASEMAP_LAYER_KEYS = new Set<string>([
  'building 3d',
  'vegetation 3d'
])

const ALLOWED_BASEMAP_LAYER_KEYS = new Set<string>([
  ...Array.from(FIXED_VISIBLE_BASEMAP_LAYER_KEYS),
  ...Array.from(TOGGLEABLE_BASEMAP_LAYER_KEYS)
])

interface BBoxBounds {
  minLng: number
  minLat: number
  maxLng: number
  maxLat: number
}

interface OptimizationResult {
  id: string
  sessionId: string
  jobId: string
  bounds: BBoxBounds
  data: any
  timestamp: number
  label: string
  color: string
  source: 'submitted' | 'recalled'
  // Optimization parameters specific to this result
  frequency?: number
  networkType?: string
  hyperparameters?: {
    rsrp_threshold: number
    sinr_threshold: number
    alpha_condition_change: number
    alpha_bin_to_bin: number
    condition_change_multiplier: number
    rsrp_bin_to_bin_loss_tolerance: number
    rsrp_condition_change_loss_tolerance: number
    use_user_density_cache: boolean
    use_default_antenna_pabcerns_only: boolean
  }
  availableFrequencies?: number[]
  submittedTime?: string // "time" field from the API response JSON (e.g. "Tue Feb 17 13:07:33 2026")
}

interface RecallFormState {
  sessionId: string
  jobId: string
  error: string | null
  loading: boolean
}

const RESULT_COLORS = ['#00ff00', '#0080ff', '#ff8000', '#ff00ff', '#ffff00', '#00ffff']

const clampLngLat = (lng: number, lat: number): [number, number] => {
  const clampedLng = Math.max(-180, Math.min(180, lng))
  const clampedLat = Math.max(-85, Math.min(85, lat))
  return [clampedLng, clampedLat]
}

const normalizeBBox = (a: [number, number], b: [number, number]): BBoxBounds => {
  const minLng = Math.min(a[0], b[0])
  const maxLng = Math.max(a[0], b[0])
  const minLat = Math.min(a[1], b[1])
  const maxLat = Math.max(a[1], b[1])
  return { minLng, minLat, maxLng, maxLat }
}

const formatCoord = (value: number): string => {
  return Number.isFinite(value) ? value.toFixed(6) : String(value)
}

// Generate unique ID using crypto API or fallback to timestamp-based UUID
const generateUniqueId = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID()
  }
  // Fallback: timestamp + random for uniqueness
  return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`
}

const looksLikeBinLayer = (layer: any): boolean => {
  if (!layer || typeof layer !== 'object') {
    return false
  }

  // Heuristic: only treat a layer as a "bin" layer if it is explicitly named/grouped
  // as bins. (Many non-bin layers are also circles.)
  const type = String(layer.type ?? '').toLowerCase()
  const id = String(layer.id ?? '').toLowerCase()
  const sourceLayer = String(layer['source-layer'] ?? '').toLowerCase()
  const metadataGroup = String(layer?.metadata?.group ?? '').toLowerCase()

  const mentionsBins = id.includes('bin') || id.includes('bins') || sourceLayer.includes('bin') || sourceLayer.includes('bins') || metadataGroup.includes('bin') || metadataGroup.includes('bins')

  if (mentionsBins && (type === 'circle' || type === 'symbol' || type === 'fill' || type === 'line')) {
    return true
  }

  return false
}

const looksLikeAggregatedLayer = (layer: any): boolean => {
  if (!layer || typeof layer !== 'object') {
    return false
  }
  // Heuristic: blended/aggregated coverage is commonly a heatmap.
  const type = String(layer.type ?? '').toLowerCase()
  return type === 'heatmap'
}

// Helper to extract bounding box from optimization results data
// Helper function to convert Web Mercator meters to WGS84 lat/lng degrees
const webMercatorToLngLat = (x: number, y: number): { lng: number, lat: number } => {
  const R = 6378137.0 // Earth radius in meters (Web Mercator)
  const lng = (x / R) * (180.0 / Math.PI)
  const lat = (Math.atan(Math.exp(y / R)) * (360.0 / Math.PI)) - 90.0
  return { lng, lat }
}

const extractBoundsFromResults = (data: any): BBoxBounds | null => {
  // Try to extract bounds from various possible locations in the API response
  
  // Check for request.bbox format (recalled optimizations with Web Mercator coordinates)
  if (data?.request?.bbox) {
    const bbox = data.request.bbox
    if (typeof bbox.min_lng_m === 'number' && typeof bbox.min_lat_m === 'number' &&
        typeof bbox.max_lng_m === 'number' && typeof bbox.max_lat_m === 'number') {
      // Convert Web Mercator meters to lat/lng degrees
      const minPoint = webMercatorToLngLat(bbox.min_lng_m, bbox.min_lat_m)
      const maxPoint = webMercatorToLngLat(bbox.max_lng_m, bbox.max_lat_m)
      return {
        minLng: minPoint.lng,
        minLat: minPoint.lat,
        maxLng: maxPoint.lng,
        maxLat: maxPoint.lat
      }
    }
  }
  
  if (data?.metadata?.bounds) {
    const b = data.metadata.bounds
    if (typeof b.minLng === 'number' && typeof b.minLat === 'number' &&
        typeof b.maxLng === 'number' && typeof b.maxLat === 'number') {
      return b
    }
  }

  if (data?.bounds) {
    const b = data.bounds
    if (typeof b.minLng === 'number' && typeof b.minLat === 'number' &&
        typeof b.maxLng === 'number' && typeof b.maxLat === 'number') {
      return b
    }
  }

  // Try to extract from MapLibre style sources (for recalled optimizations)
  if (data?.sources && typeof data.sources === 'object') {
    for (const sourceValue of Object.values(data.sources)) {
      const source = sourceValue as any
      // Vector tile sources often have bounds in [west, south, east, north] format
      if (source?.bounds && Array.isArray(source.bounds) && source.bounds.length === 4) {
        const [west, south, east, north] = source.bounds
        if (typeof west === 'number' && typeof south === 'number' &&
            typeof east === 'number' && typeof north === 'number') {
          return {
            minLng: west,
            minLat: south,
            maxLng: east,
            maxLat: north
          }
        }
      }
      // Also check for bounds in minLng/maxLng format
      if (source?.bounds && typeof source.bounds === 'object') {
        const b = source.bounds
        if (typeof b.minLng === 'number' && typeof b.minLat === 'number' &&
            typeof b.maxLng === 'number' && typeof b.maxLat === 'number') {
          return b
        }
      }
    }
  }

  return null
}

;(maplibregl as typeof maplibregl & { workerClass?: typeof Worker }).workerClass = MapLibreWorker as typeof Worker

const findLabelLayerId = (map: MapLibreMap): string | undefined => {
  const style = map.getStyle()
  if (!style?.layers?.length) {
    return undefined
  }

  // We want overlays to render *above roads* but keep labels on top.
  // Using the first label layer can place overlays too low (under later road layers).
  // Pick the top-most label layer (last symbol layer with a text-field).
  for (let i = style.layers.length - 1; i >= 0; i--) {
    const layer = style.layers[i] as LayerSpecification
    if (layer?.type !== 'symbol') {
      continue
    }
    const layout = (layer as any)?.layout
    if (layout?.['text-field']) {
      return layer.id
    }
  }

  return undefined
}

const findOverlayBeforeLayerId = (map: MapLibreMap): string | undefined => {
  const style = map.getStyle()
  if (!style?.layers?.length) {
    return undefined
  }

  const layers = style.layers as LayerSpecification[]

  const isLabelLayer = (layer: LayerSpecification): boolean => {
    if (layer?.type !== 'symbol') {
      return false
    }
    const layout = (layer as any)?.layout
    return Boolean(layout?.['text-field'])
  }

  const isRoadLayer = (layer: LayerSpecification): boolean => {
    if (!layer || typeof layer !== 'object') {
      return false
    }

    // Heuristic: match common road naming conventions in ids/source-layers.
    // This is intentionally loose; goal is to find the *highest* road-ish layer.
    const type = String((layer as any)?.type ?? '').toLowerCase()
    if (type !== 'line') {
      return false
    }

    const id = String((layer as any)?.id ?? '').toLowerCase()
    const sourceLayer = String((layer as any)?.['source-layer'] ?? '').toLowerCase()
    const metadataGroup = String((layer as any)?.metadata?.group ?? '').toLowerCase()
    const haystack = `${id} ${sourceLayer} ${metadataGroup}`

    return (
      haystack.includes('road') ||
      haystack.includes('roads') ||
      haystack.includes('street') ||
      haystack.includes('streets') ||
      haystack.includes('highway') ||
      haystack.includes('motorway') ||
      haystack.includes('transportation') ||
      haystack.includes('transport') ||
      haystack.includes('route') ||
      haystack.includes('routes') ||
      haystack.includes('path') ||
      haystack.includes('paths') ||
      haystack.includes('tunnel') ||
      haystack.includes('bridge')
    )
  }

  // 1) Find the top-most road layer index.
  let lastRoadIndex = -1
  for (let i = 0; i < layers.length; i++) {
    if (isRoadLayer(layers[i])) {
      lastRoadIndex = i
    }
  }

  // 2) Insert overlays just above roads, but before the next "always-on-top" layer
  // (labels or extrusions) after roads.
  if (lastRoadIndex >= 0) {
    let candidateId: string | undefined
    for (let i = lastRoadIndex + 1; i < layers.length; i++) {
      const layer = layers[i]
      if (layer?.type === 'fill-extrusion' || isLabelLayer(layer)) {
        candidateId = layer.id
        break
      }
    }

    // If we found a reasonable layer to stay under, use it.
    if (candidateId) {
      return candidateId
    }

    // Otherwise, no labels/extrusions above roads; add overlay to the top.
    return undefined
  }

  // 3) If we can't identify roads, fall back to staying under top-most labels.
  return findLabelLayerId(map)
}

const MapLibreView = ({ config }: MapLibreViewProps) => {
  const mapContainerRef = React.useRef<HTMLDivElement>(null)
  const mapRef = React.useRef<MapLibreMap | null>(null)
  const [mapReady, setMapReady] = React.useState(false)
  const overlayRef = React.useRef<Record<string, { sourceIds: string[], layerIds: string[] }>>({})
  const coverageOriginalOpacityRef = React.useRef<Record<string, number>>({})
  const threeDSceneRef = React.useRef<ThreeD.Scene>(new ThreeD.Scene())
  const [show3DSectors, setShow3DSectors] = React.useState<boolean>(true)
  const [sectorScale, setSectorScale] = React.useState<number>(1)
  const terrainChangedRef = React.useRef<boolean>(false)
  const terrainStyleRef = React.useRef<any | null>(null)

  const fallbackConfig = React.useMemo<Config>(() => ({
    mapStyleUrl: DEFAULT_BASEMAP_STYLE_URL,
    initialView: {
      center: DEFAULT_CENTER,
      zoom: DEFAULT_ZOOM,
      bearing: DEFAULT_BEARING,
      pitch: DEFAULT_PITCH
    },
    layers: [],
    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,
    api: {
      tokenUrl: DEFAULT_TOKEN_URL,
      sectorEndpoint: DEFAULT_SECTOR_ENDPOINT,
      sectorName: DEFAULT_SECTOR_NAME,
      refreshOffsetSeconds: MIN_REFRESH_OFFSET_SECONDS
    }
  }), [])

  const runtimeConfig = React.useMemo<Config>(() => {
    return config?.asMutable({ deep: true }) ?? fallbackConfig
  }, [config, fallbackConfig])

  const [authState, setAuthState] = React.useState<{ accessToken: string | null, expiresIn: number | null }>({ accessToken: null, expiresIn: null })

  const [metadataStyleData, setMetadataStyleData] = React.useState<any>(null)
  const [metadataStyleStatus, setMetadataStyleStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [metadataStyleError, setMetadataStyleError] = React.useState<string | null>(null)
  const [lastMetadataStyleUrl, setLastMetadataStyleUrl] = React.useState<string | null>(null)

  const [clickedSectorData, setClickedSectorData] = React.useState<SectorData | null>(null)
  const [sectorStyleData, setSectorStyleData] = React.useState<any>(null)
  const [sectorStyleStatus, setSectorStyleStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [sectorStyleError, setSectorStyleError] = React.useState<string | null>(null)
  const [lastSectorStyleUrl, setLastSectorStyleUrl] = React.useState<string | null>(null)

  // Sector metadata from new API
  const [sectorMetadata, setSectorMetadata] = React.useState<any>(null)
  const [sectorMetadataStatus, setSectorMetadataStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [sectorMetadataError, setSectorMetadataError] = React.useState<string | null>(null)
  const [selectedSectorTilt, setSelectedSectorTilt] = React.useState<number | null>(null)
  const [sectorCoverageType, setSectorCoverageType] = React.useState<'RSRP' | 'los_poly'>('RSRP')
  const [sectorPanelExpanded, setSectorPanelExpanded] = React.useState<boolean>(true)

  const [coverageStyleData, setCoverageStyleData] = React.useState<any>(null)
  const [coverageStyleStatus, setCoverageStyleStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [coverageStyleError, setCoverageStyleError] = React.useState<string | null>(null)
  const [lastCoverageStyleUrl, setLastCoverageStyleUrl] = React.useState<string | null>(null)
  const [coverageShowBins, setCoverageShowBins] = React.useState<boolean>(false)
  const [coverageLayer, setCoverageLayer] = React.useState<CoverageLayer>('rsrp_dbm_poly')
  const [coverageOpacity, setCoverageOpacity] = React.useState<number>(50)
  const [coverageVisible, setCoverageVisible] = React.useState<boolean>(true)
  const [legendExpanded, setLegendExpanded] = React.useState<boolean>(false)
  const [optimizationLegendExpanded, setOptimizationLegendExpanded] = React.useState<boolean>(false)
  const [hoveredCoverageabcribute, setHoveredCoverageabcribute] = React.useState<string | null>(null)

  // IQI Layer State
  const [iqiVisible, setIqiVisible] = React.useState<boolean>(false)
  const [iqiOpacity, setIqiOpacity] = React.useState<number>(100)
  const [iqiToken, setIqiToken] = React.useState<string | null>(null)
  const [iqiTokenExpiresAt, setIqiTokenExpiresAt] = React.useState<number | null>(null)
  const [iqiStatus, setIqiStatus] = React.useState<'idle' | 'loading-token' | 'loading-data' | 'success' | 'error'>('idle')
  const [iqiError, setIqiError] = React.useState<string | null>(null)
  const [iqiFeatureCount, setIqiFeatureCount] = React.useState<number>(0)
  const iqiFetchControllerRef = React.useRef<AbortController | null>(null)
  const iqiTokenRefreshTimerRef = React.useRef<number | null>(null)
  const iqiGenerationRef = React.useRef<number>(0)
  const iqiBatchTimerRef = React.useRef<number | null>(null)
  const iqiSourceExistsRef = React.useRef<boolean>(false)

  const coverageStyleLayerSummary = React.useMemo(() => {
    const layers = Array.isArray((coverageStyleData as any)?.layers) ? (coverageStyleData as any).layers : []
    const total = layers.length
    const circleCount = layers.filter((l: any) => String(l?.type ?? '').toLowerCase() === 'circle').length
    const heatmapCount = layers.filter((l: any) => String(l?.type ?? '').toLowerCase() === 'heatmap').length
    const binLikeCount = layers.filter((l: any) => looksLikeBinLayer(l)).length
    const nonBinCount = Math.max(total - binLikeCount, 0)
    return { total, circleCount, heatmapCount, binLikeCount, nonBinCount }
  }, [coverageStyleData])

  // RSRP Coverage Legend Data
  const RSRP_LEGEND = React.useMemo(() => [
    { value: -126, color: '#313695', label: '≤ -126' },
    { value: -118, color: '#4575b4', label: '≤ -118' },
    { value: -109, color: '#74add1', label: '≤ -109' },
    { value: -100, color: '#abd9e9', label: '≤ -100' },
    { value: -92, color: '#e0f3f8', label: '≤ -92' },
    { value: -83, color: '#ffffbf', label: '≤ -83' },
    { value: -75, color: '#fee090', label: '≤ -75' },
    { value: -66, color: '#fdae61', label: '≤ -66' },
    { value: -57, color: '#f46d43', label: '≤ -57' },
    { value: -49, color: '#d73027', label: '≤ -49' },
    { value: -48, color: '#a50026', label: '≤ -48' }
  ], [])

  // Bin State Legend Data
  const BIN_STATE_LEGEND = React.useMemo(() => [
    { value: 'no_coverage', color: '#000000', label: 'No Coverage' },
    { value: 'dominance', color: '#87a922', label: 'Dominance' },
    { value: 'lack_dominance', color: '#0c359e', label: 'Lack of Dominance' },
    { value: 'interference', color: '#d03030', label: 'Interference' },
    { value: 'not_defined', color: '#2a2a2a', label: 'Not Defined' }
  ], [])

  // Sector Counter Legend Data
  const SECTOR_COUNTER_LEGEND = React.useMemo(() => [
    { value: 100, color: '#485ee4', label: '100' },
    { value: 200, color: '#2e9ff4', label: '200' },
    { value: 300, color: '#27d5c6', label: '300' },
    { value: 400, color: '#50f980', label: '400' },
    { value: 500, color: '#95fb51', label: '500' },
    { value: 600, color: '#e4d931', label: '600' },
    { value: 700, color: '#ffa223', label: '700' },
    { value: 800, color: '#f76118', label: '800' },
    { value: 900, color: '#b61f07', label: '900' },
    { value: 1000, color: '#900c00', label: '1000' }
  ], [])

  // Optimization Layer Legends
  const RSRP_OPTIMIZATION_LEGEND = React.useMemo(() => [
    { value: -144, color: '#313695', label: '-144 dBm' },
    { value: -120, color: '#74ADD1', label: '-120 dBm' },
    { value: -110, color: '#FFFFBF', label: '-110 dBm' },
    { value: -90, color: '#FEE090', label: '-90 dBm' },
    { value: -75, color: '#FDAE61', label: '-75 dBm' },
    { value: -56, color: '#D73027', label: '-56 dBm' }
  ], [])

  const RSRP_DIFF_LEGEND = React.useMemo(() => [
    { value: 'bad_to_good', color: '#0F4D0F', label: 'Bad to Good' },
    { value: 'good_to_bad', color: '#ff0000', label: 'Good to Bad' }
  ], [])

  const SINR_OPTIMIZATION_LEGEND = React.useMemo(() => [
    { value: -5, color: '#87001d', label: '< -5 dB' },
    { value: 0, color: '#d1cd9c', label: '-5 to 0 dB' },
    { value: 5, color: '#88b356', label: '0 to 5 dB' },
    { value: 10, color: '#1d7c40', label: '≥ 5 dB' }
  ], [])

  const SINR_FLOOR_LEGEND = React.useMemo(() => [
    { value: 1, color: '#CCFFCC', label: 'Level 1' },
    { value: 2, color: '#5CE65C', label: 'Level 2' },
    { value: 3, color: '#0F4D0F', label: 'Level 3' }
  ], [])

  const SINR_DELTA_LEGEND = React.useMemo(() => [
    { value: -35, color: '#87001d', label: '< -35 dB' },
    { value: -5, color: '#b1261e', label: '-35 to -5 dB' },
    { value: -3, color: '#c95936', label: '-5 to -3 dB' },
    { value: -1, color: '#d1b871', label: '-3 to -1 dB' },
    { value: 1, color: '#88b356', label: '-1 to 1 dB' },
    { value: 3, color: '#529b51', label: '1 to 3 dB' },
    { value: 5, color: '#1d7c40', label: '3 to 5 dB' },
    { value: 35, color: '#10542c', label: '> 5 dB' }
  ], [])

  const USER_DENSITY_LEGEND = React.useMemo(() => [
    { value: 0, color: '#23171b', label: '0' },
    { value: 0.1, color: '#32204a', label: '≥ 0.1' },
    { value: 0.3, color: '#4569ee', label: '≥ 0.3' },
    { value: 0.6, color: '#28b3e9', label: '≥ 0.6' },
    { value: 1.0, color: '#38ee9d', label: '≥ 1.0' },
    { value: 3.0, color: '#7cfd5e', label: '≥ 3.0' },
    { value: 6.0, color: '#d0e637', label: '≥ 6.0' },
    { value: 10.0, color: '#ffa223', label: '≥ 10.0' },
    { value: 30.0, color: '#f05616', label: '≥ 30.0' },
    { value: 60.0, color: '#ac1805', label: '≥ 60.0' },
    { value: 100.0, color: '#900c00', label: '≥ 100.0' }
  ], [])

  const BIN_STATE_OPTIMIZATION_LEGEND = React.useMemo(() => [
    { value: 'no_coverage', color: '#000000', label: 'No Coverage' },
    { value: 'dominance', color: '#87A922', label: 'Dominance' },
    { value: 'lack_dominance', color: '#0C359E', label: 'Lack of Dominance' },
    { value: 'interference', color: '#ff0000', label: 'Interference' }
  ], [])

  const SECTOR_ID_LEGEND = React.useMemo(() => [
    { value: 0, color: '#fff000', label: '0%' },
    { value: 0.05, color: '#313695', label: '5%' },
    { value: 0.1, color: '#4575B4', label: '10%' },
    { value: 0.15, color: '#74ADD1', label: '15%' },
    { value: 0.2, color: '#ffff00', label: '20%' },
    { value: 0.25, color: '#ABD9E9', label: '25%' },
    { value: 0.3, color: '#f0ff0f', label: '30%' },
    { value: 0.35, color: '#E0F3F8', label: '35%' },
    { value: 0.4, color: '#00ffff', label: '40%' },
    { value: 0.45, color: '#FEE090', label: '45%' },
    { value: 0.5, color: '#00ff00', label: '50%' },
    { value: 0.55, color: '#FDAE61', label: '55%' },
    { value: 0.6, color: '#F46D43', label: '60%' },
    { value: 0.65, color: '#D73027', label: '65%' },
    { value: 0.7, color: '#0000ff', label: '70%' },
    { value: 0.75, color: '#f5f5f0', label: '75%' },
    { value: 0.8, color: '#ccccff', label: '80%' },
    { value: 0.85, color: '#ff00ff', label: '85%' },
    { value: 0.9, color: '#cc66ff', label: '90%' },
    { value: 0.95, color: '#A50026', label: '95%' },
    { value: 1, color: '#efefef', label: '100%' }
  ], [])

  const [showApiControls, setShowApiControls] = React.useState<boolean>(false)
  const [apiVisibility, setApiVisibility] = React.useState<Record<string, ApiVisibilityEntry>>({})
  const [basemapLayers, setBasemapLayers] = React.useState<BasemapLayerEntry[]>([])
  const [basemapLayerVisibility, setBasemapLayerVisibility] = React.useState<Record<string, boolean>>({})

  const [optimizationDrawEnabled, setOptimizationDrawEnabled] = React.useState<boolean>(false)
  const [optimizationBounds, setOptimizationBounds] = React.useState<BBoxBounds | null>(null)
  const optimizationBoundsRef = React.useRef<BBoxBounds | null>(null)
  const optimizationDrawRef = React.useRef<{ sourceId: string, fillLayerId: string, lineLayerId: string } | null>(null)
  const optimizationDrawingStateRef = React.useRef<{ active: boolean, startPoint: maplibregl.PointLike, startLngLat: maplibregl.LngLatLike } | null>(null)
  const [optimizationSectors, setOptimizationSectors] = React.useState<number[]>([])
  const [selectedOptimizationSector, setSelectedOptimizationSector] = React.useState<number | null>(null)
  const [selectedNetworkType, setSelectedNetworkType] = React.useState<string>('LTE')
  const [optimizationStatus, setOptimizationStatus] = React.useState<'idle' | 'drawing' | 'ready' | 'loading' | 'success' | 'error'>('idle')
  const [optimizationError, setOptimizationError] = React.useState<string | null>(null)
  const [lastOptimizationUrl, setLastOptimizationUrl] = React.useState<string | null>(null)

  const [sessionId, setSessionId] = React.useState<string>('')
  const [jobId, setJobId] = React.useState<string>('')
  const [optimizationJobStatus, setOptimizationJobStatus] = React.useState<'idle' | 'submitting' | 'polling' | 'completed' | 'error'>('idle')
  const [optimizationJobError, setOptimizationJobError] = React.useState<string | null>(null)
  const [statusMessage, setStatusMessage] = React.useState<string>('')

  const [submissionResponse, setSubmissionResponse] = React.useState<any>(null)
  const [lastSubmissionUrl, setLastSubmissionUrl] = React.useState<string | null>(null)
  const [lastStatusUrl, setLastStatusUrl] = React.useState<string | null>(null)
  const [optimizationResults, setOptimizationResults] = React.useState<any>(null)
  const [showResultsView, setShowResultsView] = React.useState<boolean>(false)
  const [resultsError, setResultsError] = React.useState<string | null>(null)
  const [showJsonDetails, setShowJsonDetails] = React.useState<boolean>(false)
  const [showTiltTableModal, setShowTiltTableModal] = React.useState<boolean>(false)
  const pollingTimerRef = React.useRef<number | null>(null)

  // Store submitted job parameters indexed by sessionId-jobId
  const submittedJobParamsRef = React.useRef<Record<string, {
    frequency: number | null
    networkType: string
    hyperparameters: typeof DEFAULT_HYPERPARAMETERS
    availableFrequencies: number[]
  }>>({})

  // Multi-Result Management (New)
  const [optimizationResultsArray, setOptimizationResultsArray] = React.useState<OptimizationResult[]>([])
  const [activeResultIndex, setActiveResultIndex] = React.useState<number | null>(null)
  const [showResultsPanel, setShowResultsPanel] = React.useState<boolean>(false)

  // Recall Functionality
  const [recallFormVisible, setRecallFormVisible] = React.useState<boolean>(false)
  const [recallForm, setRecallForm] = React.useState<RecallFormState>({
    sessionId: '',
    jobId: '',
    error: null,
    loading: false
  })

  // bird Optimization Section State
  const [showOptimizationSection, setShowOptimizationSection] = React.useState<boolean>(false)
  // Button size - adjust this constant to change button size (no UI control)
  const bird_BUTTON_SIZE = 80
  // Layer Controls Sidebar State
  const [showLayerControls, setShowLayerControls] = React.useState<boolean>(true)


  // Bounding Box Visualization
  const [visibleBoundingBoxes, setVisibleBoundingBoxes] = React.useState<Set<string>>(new Set())
  const [loadedResultsMinimized, setLoadedResultsMinimized] = React.useState<boolean>(false)

  // Portal user info
  const [portalUser, setPortalUser] = React.useState<{ username: string, fullName: string } | null>(null)
  const [isOptoUser, setIsOptoUser] = React.useState<boolean>(false)

  // Optimization Hyperparameters
  const DEFAULT_HYPERPARAMETERS = React.useMemo(() => ({
    rsrp_threshold: -106,
    sinr_threshold: 0,
    alpha_condition_change: 0.9,
    alpha_bin_to_bin: 0.6,
    condition_change_multiplier: 5,
    rsrp_bin_to_bin_loss_tolerance: 0,
    rsrp_condition_change_loss_tolerance: 0,
    use_user_density_cache: true,
    use_default_antenna_pabcerns_only: false
  }), [])

  const HYPERPARAMETER_TOOLTIPS = React.useMemo(() => ({
    rsrp_threshold: 'Threshold for good/bad RSRP in dBm.',
    sinr_threshold: 'Threshold for good/bad SINR in dBm.',
    alpha_condition_change: 'SINR/RSRP weightage for condition change score. At 1.0, SINR has 100% weightage, and RSRP 0%. At 0.5, both have equal weightage. At 0.0, RSRP has 100% weightage, and SINR 0%.',
    alpha_bin_to_bin: 'SINR/RSRP weightage for bin-to-bin improvement score. At 1.0, SINR has 100% weightage, and RSRP 0%. At 0.5, both have equal weightage. At 0.0, RSRP has 100% weightage, and SINR 0%.',
    condition_change_multiplier: 'Multiplier for condition change score, as compared to bin-to-bin score. At 1, condition change and bin-to-bin scores have equal weightage. At 0.5, condition change has half the weightage of bin-to-bin. At 5, condition change has 5 times the weightage of bin-to-bin.',
    rsrp_bin_to_bin_loss_tolerance: 'Percentage of Net RSRP Bin to Bin that you are willing to sacrifice in exchange for SINR improvement. Should be between -100 and 0, i.e -0.5 means a tolerance of -0.5% Net RSRP Bin to Bin.',
    rsrp_condition_change_loss_tolerance: 'Percentage of Net RSRP Condition Change that you are willing to sacrifice in exchange for SINR improvement. Should be between -100 and 0, i.e -0.5 means a tolerance of -0.5% Net RSRP Condition.',
    use_user_density_cache: 'If true, use user density cache for optimization. If false, do not use user density cache for optimization.',
    use_default_antenna_pabcerns_only: 'If true, only uses default antenna pabcern types.'
  }), [])

  const [hyperparameters, setHyperparameters] = React.useState(DEFAULT_HYPERPARAMETERS)
  const [hyperparametersExpanded, setHyperparametersExpanded] = React.useState<boolean>(false)
  const hyperparametersLocked = true

  const hasHyperparametersChanged = React.useCallback(() => {
    return Object.keys(hyperparameters).some(
      key => hyperparameters[key as keyof typeof hyperparameters] !== DEFAULT_HYPERPARAMETERS[key as keyof typeof DEFAULT_HYPERPARAMETERS]
    )
  }, [hyperparameters, DEFAULT_HYPERPARAMETERS])

  // Computed value: get active result's data for backward compatibility
  const activeResultData = React.useMemo(() => {
    if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
      return optimizationResultsArray[activeResultIndex].data
    }
    return null
  }, [optimizationResultsArray, activeResultIndex])

  const [optimizationLayerType, setOptimizationLayerType] = React.useState<string>('none')
  const [optimizationLayerData, setOptimizationLayerData] = React.useState<any>(null)
  const [optimizationLayerStatus, setOptimizationLayerStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [optimizationLayerError, setOptimizationLayerError] = React.useState<string | null>(null)

  // Per-result optimization layer tracking
  const [resultLayerTypes, setResultLayerTypes] = React.useState<Record<string, OptimizationLayerType>>({})
  const resultLayerDataRef = React.useRef<Record<string, any>>({})
  const resultLayerStatusRef = React.useRef<Record<string, 'idle' | 'loading' | 'success' | 'error'>>({})

  // Optimization layer opacity control (default 0.5 to match style.json)
  const [optimizationLayerOpacity, setOptimizationLayerOpacity] = React.useState<number>(50)

  const [tokenStatus, setTokenStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [tokenError, setTokenError] = React.useState<string | null>(null)
  const [lastTokenUrlTried, setLastTokenUrlTried] = React.useState<string | null>(null)
  const [lastMapError, setLastMapError] = React.useState<string | null>(null)
  const tokenRefreshTimerRef = React.useRef<number | null>(null)
  const [sectorName, setSectorName] = React.useState<string>(runtimeConfig.api?.sectorName ?? DEFAULT_SECTOR_NAME)
  const authTokenRef = React.useRef<string | null>(null)
  const [lastAccessToken, setLastAccessToken] = React.useState<string | null>(null)

  const defaultApiLabel = React.useCallback((key: string): string => {
    const trimmed = (key ?? '').trim()
    if (trimmed.length === 0) {
      return 'API'
    }

    const known: Record<string, string> = {
      sector: 'Sector',
      bbox: 'BBox Coverage',
      coverage: 'Coverage',
      meta: 'Metadata'
    }

    if (known[trimmed]) {
      return known[trimmed]
    }

    const spaced = trimmed
      .replace(/[-_]+/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')

    return spaced
      .split(' ')
      .filter(Boolean)
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
      .join(' ')
  }, [])

  const registerApi = React.useCallback((key: string, label?: string) => {
    const normalizedKey = String(key ?? '').trim()
    if (normalizedKey.length === 0) {
      return
    }

    setApiVisibility((prev: Record<string, ApiVisibilityEntry>) => {
      if (prev[normalizedKey]) {
        return prev
      }
      return {
        ...prev,
        [normalizedKey]: {
          label: typeof label === 'string' && label.trim().length > 0 ? label.trim() : defaultApiLabel(normalizedKey),
          enabled: true
        }
      }
    })
  }, [defaultApiLabel])

  const isApiEnabled = React.useCallback((key: string): boolean => {
    const normalizedKey = String(key ?? '').trim()
    if (normalizedKey.length === 0) {
      return true
    }
    return apiVisibility[normalizedKey]?.enabled ?? true
  }, [apiVisibility])

  const isManagedBasemapLayer = React.useCallback((layerId: string): boolean => {
    if (!layerId || typeof layerId !== 'string') {
      return false
    }

    if (layerId === 'three-d-sectors-layer') {
      return false
    }

    if (layerId.startsWith('map-widget-')) {
      return false
    }

    if (layerId.includes('-geojson-')) {
      return false
    }

    // Exclude runtime overlay layers generated from style overlays (coverage/meta/clicked-sector/etc)
    if (layerId.includes('-lyr-')) {
      return false
    }

    // Exclude IQI runtime overlay layers
    if (layerId.startsWith('iqi-')) {
      return false
    }

    if (/^(coverage|sector|meta|bbox)-lyr-/.test(layerId)) {
      return false
    }

    if (/^(coverage|sector|meta|bbox)-src-/.test(layerId)) {
      return false
    }

    if (layerId.startsWith('optimization-layer')) {
      return false
    }

    return true
  }, [])

  const isAllowedBasemapLayer = React.useCallback((layerId: string): boolean => {
    return ALLOWED_BASEMAP_LAYER_KEYS.has(normalizeBasemapLayerKey(layerId))
  }, [])

  const isToggleableBasemapLayer = React.useCallback((layerId: string): boolean => {
    return TOGGLEABLE_BASEMAP_LAYER_KEYS.has(normalizeBasemapLayerKey(layerId))
  }, [])

  const classifyBasemapLayer = React.useCallback((layer: any): BasemapLayerEntry['category'] => {
    const type = String(layer?.type ?? '').toLowerCase()
    const id = String(layer?.id ?? '').toLowerCase()
    const sourceLayer = String(layer?.['source-layer'] ?? '').toLowerCase()
    const haystack = `${id} ${sourceLayer}`

    if (type === 'background') {
      return 'background'
    }

    if (haystack.includes('water') || haystack.includes('waterway')) {
      return 'water'
    }

    const isRoadLike =
      haystack.includes('road') ||
      haystack.includes('street') ||
      haystack.includes('highway') ||
      haystack.includes('motorway') ||
      haystack.includes('trunk') ||
      haystack.includes('primary') ||
      haystack.includes('secondary') ||
      haystack.includes('tertiary') ||
      haystack.includes('minor') ||
      haystack.includes('transportation') ||
      haystack.includes('bridge') ||
      haystack.includes('tunnel') ||
      haystack.includes('path')

    if (isRoadLike) {
      return 'road'
    }

    return 'other'
  }, [])

  const refreshBasemapLayerControls = React.useCallback(() => {
    if (!mapRef.current) {
      return
    }

    const map = mapRef.current
    const styleLayers = map.getStyle()?.layers ?? []

    const allManagedEntries: BasemapLayerEntry[] = styleLayers
      .filter((layer: any) => isManagedBasemapLayer(String(layer?.id ?? '')))
      .map((layer: any) => {
        const id = String(layer.id)
        const type = String(layer.type ?? '')
        const label = id.replace(/[-_]+/g, ' ')
        const category = classifyBasemapLayer(layer)
        return { id, type, label, category }
      })

    const allowedEntries = allManagedEntries.filter((entry: BasemapLayerEntry) => isAllowedBasemapLayer(entry.id))
    const toggleableEntries = allowedEntries.filter((entry: BasemapLayerEntry) => isToggleableBasemapLayer(entry.id))

    const styleTerrain = (map.getStyle() as any)?.terrain
    if (styleTerrain && !terrainStyleRef.current) {
      terrainStyleRef.current = styleTerrain
    }

    const terrainEntry: BasemapLayerEntry | null = terrainStyleRef.current
      ? {
          id: TERRAIN_TOGGLE_ID,
          label: 'terrain',
          type: 'terrain',
          category: 'terrain'
        }
      : null

    setBasemapLayers(terrainEntry ? [...toggleableEntries, terrainEntry] : toggleableEntries)

    setBasemapLayerVisibility((prev: Record<string, boolean>) => {
      const next: Record<string, boolean> = {}

      allManagedEntries.forEach((entry: BasemapLayerEntry) => {
        const isAllowed = isAllowedBasemapLayer(entry.id)
        const isToggleable = isToggleableBasemapLayer(entry.id)

        const desiredVisible = !isAllowed
          ? false
          : isToggleable
            ? (typeof prev[entry.id] === 'boolean' ? prev[entry.id] : true)
            : true

        if (isToggleable) {
          next[entry.id] = desiredVisible
        }

        try {
          map.setLayoutProperty(entry.id, 'visibility', desiredVisible ? 'visible' : 'none')
        } catch (_ignored) {
          // Layer may not be style-toggleable; ignore.
        }
      })

      if (terrainStyleRef.current) {
        const terrainEnabled = typeof prev[TERRAIN_TOGGLE_ID] === 'boolean' ? prev[TERRAIN_TOGGLE_ID] : false
        next[TERRAIN_TOGGLE_ID] = terrainEnabled
        try {
          map.setTerrain(terrainEnabled ? terrainStyleRef.current : null)
          terrainChangedRef.current = true
        } catch (_ignored) {
          // ignore terrain update errors
        }
      }

      return next
    })
  }, [classifyBasemapLayer, isManagedBasemapLayer, isAllowedBasemapLayer, isToggleableBasemapLayer])

  const setBasemapLayerVisible = React.useCallback((layerId: string, visible: boolean) => {
    if (!mapRef.current) {
      return
    }

    if (layerId === TERRAIN_TOGGLE_ID) {
      try {
        mapRef.current.setTerrain(visible ? terrainStyleRef.current : null)
        terrainChangedRef.current = true
      } catch (_ignored) {
        // ignore terrain update errors
      }
      return
    }

    if (!mapRef.current.getLayer(layerId)) {
      return
    }

    mapRef.current.setLayoutProperty(layerId, 'visibility', visible ? 'visible' : 'none')
  }, [])

  const applyMinimalBasemapPaint = React.useCallback((entry: BasemapLayerEntry) => {
    if (!mapRef.current || !mapRef.current.getLayer(entry.id)) {
      return
    }

    const map = mapRef.current

    try {
      if (entry.category === 'background' && entry.type === 'background') {
        map.setPaintProperty(entry.id, 'background-color', '#ffffff')
        return
      }

      if (entry.category === 'water') {
        if (entry.type === 'fill') {
          map.setPaintProperty(entry.id, 'fill-color', '#d9d9d9')
        } else if (entry.type === 'line') {
          map.setPaintProperty(entry.id, 'line-color', '#d0d0d0')
        }
        return
      }

      if (entry.category === 'road') {
        if (entry.type === 'line') {
          const roadColor = entry.id.toLowerCase().includes('casing') ? '#cfcfcf' : '#f2f2f2'
          map.setPaintProperty(entry.id, 'line-color', roadColor)
        } else if (entry.type === 'fill') {
          map.setPaintProperty(entry.id, 'fill-color', '#f2f2f2')
        }
      }
    } catch (_ignored) {
      // Some style layers may have paint properties not compatible with this override.
    }
  }, [])

  // Get logged-in user identity from Experience Builder app store
  React.useEffect(() => {
    try {
      const state = getAppStore().getState()
      console.log('[Portal] App store state keys:', Object.keys(state))
      const userInfo = state?.user
      console.log('[Portal] state.user:', userInfo)
      if (userInfo?.username) {
        const user = { username: userInfo.username, fullName: userInfo.fullName || userInfo.username }
        setPortalUser(user)
        console.log('[Portal] Logged-in user:', user.fullName, '(' + user.username + ')')
      } else {
        // Try portalSelf as fallback
        const portalSelf = state?.portalSelf
        console.log('[Portal] state.portalSelf:', portalSelf)
        if (portalSelf?.user?.username) {
          const user = { username: portalSelf.user.username, fullName: portalSelf.user.fullName || portalSelf.user.username }
          setPortalUser(user)
          console.log('[Portal] Logged-in user (from portalSelf):', user.fullName, '(' + user.username + ')')
        } else {
          console.warn('[Portal] No user found in app store. Available state keys:', Object.keys(state))
        }
      }
    } catch (error) {
      console.error('[Portal] Failed to get user from app store:', error)
    }
  }, [])

  // Check if logged-in user belongs to the OptoUser group
  React.useEffect(() => {
    if (!portalUser) return
    const checkGroupMembership = async () => {
      try {
        // Fetch token using same IQI token endpoint
        const tokenResponse = await fetch('https://egisportal.dev.abc.com/egis-js-app/token', {
          method: 'GET',
          mode: 'cors',
          cache: 'no-store'
        })
        if (!tokenResponse.ok) {
          console.warn('[Portal] Token fetch failed for group check:', tokenResponse.status)
          return
        }
        const tokenData = await tokenResponse.json()
        const token = tokenData.access_token
        if (!token) {
          console.warn('[Portal] No token available for group check')
          return
        }

        // Paginate through all users in the group (API caps at 100 per page)
        const allUsers: any[] = []
        let start = 1
        const pageSize = 100
        let foundEarly = false

        console.log('[Portal] Fetching group user list (paginated)...')
        while (true) {
          const groupUrl = `https://egisportal.dev.abc.com/egisweb/sharing/rest/community/groups/group1/userList?f=json&start=${start}&num=${pageSize}&token=${encodeURIComponent(token)}`
          const groupResponse = await fetch(groupUrl, { method: 'GET', mode: 'cors' })
          if (!groupResponse.ok) {
            console.warn('[Portal] Group user list fetch failed:', groupResponse.status)
            break
          }
          const groupData = await groupResponse.json()
          const pageUsers: any[] = groupData?.users || []
          allUsers.push(...pageUsers)

          // Check this page immediately — stop early if user is found
          if (pageUsers.some((u: any) => u?.fullName === portalUser.fullName)) {
            foundEarly = true
            console.log('[Portal] Found user on page starting at', start)
            break
          }

          const nextStart = groupData?.nextStart
          console.log(`[Portal] Page start=${start}: ${pageUsers.length} users, nextStart=${nextStart}, total so far=${allUsers.length}`)

          // nextStart === -1 means no more pages
          if (!nextStart || nextStart === -1 || pageUsers.length === 0) {
            break
          }
          start = nextStart
        }

        console.log('[Portal] Total users fetched:', allUsers.length)
        console.log('[Portal] Looking for fullName:', portalUser.fullName)
        const found = foundEarly || allUsers.some((u: any) => u?.fullName === portalUser.fullName)
        console.log('[Portal] User', portalUser.fullName, found ? 'IS in OptoUser group' : 'is NOT in OptoUser group')
        setIsOptoUser(found)
      } catch (error) {
        console.error('[Portal] Failed to check group membership:', error)
      }
    }
    void checkGroupMembership()
  }, [portalUser])

  React.useEffect(() => {
    // Seed known APIs so the list is visible before first successful fetch.
    registerApi('sector', 'Sector')
    registerApi('bbox', 'BBox Coverage')
    registerApi('coverage', 'Coverage')
    registerApi('meta', 'Metadata')
  }, [registerApi])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    refreshBasemapLayerControls()

    const map = mapRef.current
    const handleStyleData = () => {
      refreshBasemapLayerControls()
    }

    map.on('styledata', handleStyleData)
    return () => {
      map.off('styledata', handleStyleData)
    }
  }, [mapReady, refreshBasemapLayerControls])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    basemapLayers.forEach((layer: BasemapLayerEntry) => {
      const desired = basemapLayerVisibility[layer.id]
      if (typeof desired === 'boolean') {
        setBasemapLayerVisible(layer.id, desired)
      }
    })
  }, [mapReady, basemapLayers, basemapLayerVisibility, setBasemapLayerVisible])

  const clearOverlay = React.useCallback((overlayKey: string) => {
    if (!mapRef.current) {
      overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }
      return
    }

    const map = mapRef.current
    const prior = overlayRef.current[overlayKey]
    if (!prior) {
      overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }
      return
    }

    prior.layerIds.forEach((layerId: string) => {
      if (map.getLayer(layerId)) {
        map.removeLayer(layerId)
      }
    })

    prior.sourceIds.forEach((sourceId: string) => {
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId)
      }
    })

    overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }
  }, [])

  const applyGeoJsonOverlay = React.useCallback((overlayKey: string, geojson: any) => {
    registerApi(overlayKey)

    if (!isApiEnabled(overlayKey)) {
      clearOverlay(overlayKey)
      return
    }

    if (!mapRef.current) {
      return
    }

    const map = mapRef.current

    const isGeoJsonFeatureCollection = geojson && typeof geojson === 'object' && geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)
    const isGeoJsonFeature = geojson && typeof geojson === 'object' && geojson.type === 'Feature' && geojson.geometry
    if (!isGeoJsonFeatureCollection && !isGeoJsonFeature) {
      throw new Error('Response is not a MapLibre style or GeoJSON')
    }

    clearOverlay(overlayKey)

    const sourceId = `${overlayKey}-geojson-src`
    const fillLayerId = `${overlayKey}-geojson-fill`
    const lineLayerId = `${overlayKey}-geojson-line`

    if (map.getSource(sourceId)) {
      map.removeSource(sourceId)
    }

    map.addSource(sourceId, {
      type: 'geojson',
      data: geojson
    } as any)

    const beforeLayerId = findOverlayBeforeLayerId(map)

    if (map.getLayer(fillLayerId)) {
      map.removeLayer(fillLayerId)
    }
    map.addLayer({
      id: fillLayerId,
      type: 'fill',
      source: sourceId,
      paint: {
        'fill-color': '#fff',
        'fill-opacity': 0.2
      }
    } as any, beforeLayerId)

    if (map.getLayer(lineLayerId)) {
      map.removeLayer(lineLayerId)
    }
    map.addLayer({
      id: lineLayerId,
      type: 'line',
      source: sourceId,
      paint: {
        'line-color': '#fff',
        'line-width': 2
      }
    } as any, beforeLayerId)

    overlayRef.current[overlayKey] = { sourceIds: [sourceId], layerIds: [fillLayerId, lineLayerId] }
  }, [clearOverlay, isApiEnabled, registerApi])

  const applyOverlayStyle = React.useCallback((overlayKey: string, styleJson: any) => {
    registerApi(overlayKey)

    if (!isApiEnabled(overlayKey)) {
      clearOverlay(overlayKey)
      return
    }

    if (!mapRef.current) {
      return
    }

    const map = mapRef.current
    const style = styleJson as Partial<StyleSpecification>

    const sources = style?.sources
    const layers = style?.layers

    if (!sources || typeof sources !== 'object' || !Array.isArray(layers)) {
      throw new Error('Response is not a valid MapLibre style (missing sources/layers)')
    }

    const prior = overlayRef.current[overlayKey]
    if (prior) {
      prior.layerIds.forEach((layerId: string) => {
        if (map.getLayer(layerId)) {
          map.removeLayer(layerId)
        }
      })
      prior.sourceIds.forEach((sourceId: string) => {
        if (map.getSource(sourceId)) {
          map.removeSource(sourceId)
        }
      })
    }
    overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }

    const sourceIdMap = new Map<string, string>()
    Object.entries(sources).forEach(([sourceKey, sourceValue]) => {
      const newSourceId = `${overlayKey}-src-${sourceKey}`
      sourceIdMap.set(sourceKey, newSourceId)

      if (map.getSource(newSourceId)) {
        map.removeSource(newSourceId)
      }
      map.addSource(newSourceId, sourceValue as any)
      overlayRef.current[overlayKey].sourceIds.push(newSourceId)
    })

    const beforeLayerId = findOverlayBeforeLayerId(map)

    // Map layer ids so styles that use `ref` (layer references) keep working.
    const layerIdMap = new Map<string, string>()
    layers.forEach((layer: any) => {
      const originalId = typeof layer?.id === 'string' ? layer.id : undefined
      if (!originalId) {
        return
      }
      layerIdMap.set(originalId, `${overlayKey}-lyr-${originalId}`)
    })

    layers.forEach((layer: any) => {
      if (!layer || typeof layer !== 'object') {
        return
      }

      if (layer.type === 'background') {
        return
      }

      const originalId = typeof layer.id === 'string' ? layer.id : undefined
      const mappedSource = typeof layer.source === 'string' ? sourceIdMap.get(layer.source) : undefined
      if (typeof layer.source === 'string' && !mappedSource) {
        return
      }

      const newLayerId = originalId ? (layerIdMap.get(originalId) ?? `${overlayKey}-lyr-${originalId}`) : `${overlayKey}-lyr-${String(Math.random()).slice(2)}`
      const newLayer: any = { ...layer, id: newLayerId }
      if (mappedSource) {
        newLayer.source = mappedSource
      }

      if (typeof newLayer.ref === 'string') {
        const mappedRef = layerIdMap.get(newLayer.ref)
        if (mappedRef) {
          newLayer.ref = mappedRef
        }
      }

      if (map.getLayer(newLayerId)) {
        map.removeLayer(newLayerId)
      }
      map.addLayer(newLayer as any, beforeLayerId)
      overlayRef.current[overlayKey].layerIds.push(newLayerId)
      
      // Store original opacity values for coverage layers
      if (overlayKey === 'coverage') {
        const paint = newLayer.paint || {}
        const layerType = newLayer.type
        if (layerType === 'fill' && typeof paint['fill-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['fill-opacity']
        } else if (layerType === 'line' && typeof paint['line-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['line-opacity']
        } else if (layerType === 'circle' && typeof paint['circle-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['circle-opacity']
        } else if (layerType === 'heatmap' && typeof paint['heatmap-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['heatmap-opacity']
        } else if (layerType === 'symbol') {
          if (typeof paint['text-opacity'] === 'number') {
            coverageOriginalOpacityRef.current[`${newLayerId}-text`] = paint['text-opacity']
          }
          if (typeof paint['icon-opacity'] === 'number') {
            coverageOriginalOpacityRef.current[`${newLayerId}-icon`] = paint['icon-opacity']
          }
        }
      }
    })
  }, [clearOverlay, isApiEnabled, registerApi])

  // Effect to apply opacity to optimization layers
  React.useEffect(() => {
    if (!mapRef.current) return

    const map = mapRef.current
    const opacityValue = optimizationLayerOpacity / 100 // Convert percentage to 0-1 range

    // Apply opacity to all optimization layers
    Object.keys(overlayRef.current).forEach((overlayKey) => {
      if (overlayKey.startsWith('optimization-layer')) {
        const overlay = overlayRef.current[overlayKey]
        if (overlay?.layerIds) {
          overlay.layerIds.forEach((layerId: string) => {
            if (map.getLayer(layerId)) {
              const layer = map.getLayer(layerId)
              if (!layer) return

              const layerType = layer.type

              // Apply opacity based on layer type
              if (layerType === 'fill') {
                map.setPaintProperty(layerId, 'fill-opacity', opacityValue)
              } else if (layerType === 'line') {
                map.setPaintProperty(layerId, 'line-opacity', opacityValue)
              } else if (layerType === 'circle') {
                map.setPaintProperty(layerId, 'circle-opacity', opacityValue)
              } else if (layerType === 'heatmap') {
                map.setPaintProperty(layerId, 'heatmap-opacity', opacityValue)
              } else if (layerType === 'symbol') {
                map.setPaintProperty(layerId, 'text-opacity', opacityValue)
                map.setPaintProperty(layerId, 'icon-opacity', opacityValue)
              }
            }
          })
        }
      }
    })
  }, [optimizationLayerOpacity, optimizationLayerStatus, resultLayerTypes])

  // Effect to handle hover on coverage layers (usid_poly and sector_id_poly)
  React.useEffect(() => {
    if (!mapRef.current || !mapReady) return
    if (coverageLayer !== 'usid_poly' && coverageLayer !== 'sector_id_poly') {
      setHoveredCoverageabcribute(null)
      return
    }

    const map = mapRef.current

    const onCoverageMouseMove = (e: maplibregl.MapMouseEvent) => {
      // Get all layers related to coverage overlay
      const coverageOverlay = overlayRef.current['coverage']
      if (!coverageOverlay?.layerIds?.length) {
        setHoveredCoverageabcribute(null)
        return
      }

      // Query features at the mouse point for coverage layers
      const features = map.queryRenderedFeatures(e.point, {
        layers: coverageOverlay.layerIds
      })

      if (features && features.length > 0) {
        const feature = features[0]
        const properties = feature.properties

        // Extract the appropriate abcribute based on coverage layer type
        if (coverageLayer === 'usid_poly' && properties?.usid) {
          setHoveredCoverageabcribute(properties.usid)
        } else if (coverageLayer === 'sector_id_poly' && properties?.sector_id) {
          setHoveredCoverageabcribute(properties.sector_id)
        } else {
          setHoveredCoverageabcribute(null)
        }
      } else {
        setHoveredCoverageabcribute(null)
      }
    }

    map.on('mousemove', onCoverageMouseMove)

    return () => {
      map.off('mousemove', onCoverageMouseMove)
    }
  }, [mapReady, coverageLayer])

  const styleUrl = React.useMemo(() => {
    const configuredStyle = runtimeConfig?.mapStyleUrl?.trim()
    return configuredStyle && configuredStyle.length > 0 ? configuredStyle : DEFAULT_BASEMAP_STYLE_URL
  }, [runtimeConfig?.mapStyleUrl])

  const pixelRatio = React.useMemo(() => {
    const fallback = typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1
    const configuredRatio = runtimeConfig?.pixelRatio
    const desired = typeof configuredRatio === 'number' && Number.isFinite(configuredRatio)
      ? configuredRatio
      : fallback
    return Math.min(Math.max(desired, 1), 3)
  }, [runtimeConfig?.pixelRatio])

  const refreshToken = React.useCallback(async () => {
    setTokenStatus('loading')
    setTokenError(null)
    setLastTokenUrlTried(DEFAULT_TOKEN_URL)

    try {
      const response = await fetch(DEFAULT_TOKEN_URL, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json'
        }
      })

      if (!response.ok) {
        throw new Error(`Token fetch failed with status ${response.status}`)
      }

      const tokenData = await response.json()
      
      if (!tokenData.access_token || typeof tokenData.access_token !== 'string') {
        throw new Error('Invalid token response: missing or invalid access_token field')
      }

      const accessToken = tokenData.access_token.trim()
      const expiresIn = typeof tokenData.expires_in === 'number' ? tokenData.expires_in : DEFAULT_TOKEN_EXPIRY_SECONDS

      setAuthState({ accessToken, expiresIn })
      authTokenRef.current = accessToken
      setLastAccessToken(accessToken)
      setTokenStatus('success')
      setTokenError(null)

      // Schedule next token refresh with safety margin
      const refreshIntervalMs = Math.max((expiresIn - MIN_REFRESH_OFFSET_SECONDS) * 1000, 60000)
      if (tokenRefreshTimerRef.current) {
        window.clearTimeout(tokenRefreshTimerRef.current)
      }
      tokenRefreshTimerRef.current = window.setTimeout(() => {
        void refreshToken()
      }, refreshIntervalMs)

      return accessToken
    } catch (error) {
      console.error('Failed to fetch token from', DEFAULT_TOKEN_URL, error)
      setAuthState({ accessToken: null, expiresIn: null })
      authTokenRef.current = null
      setLastAccessToken(null)
      setTokenStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching token endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setTokenError(message)

      if (tokenRefreshTimerRef.current) {
        window.clearTimeout(tokenRefreshTimerRef.current)
        tokenRefreshTimerRef.current = null
      }

      return null
    }
  }, [])

  // ─── IQI LAYER TOKEN MANAGEMENT ───────────────────────────────────────────────

  const fetchIqiToken = React.useCallback(async (): Promise<string | null> => {
    const IQI_TOKEN_URL = 'https://egisportal.dev.abc.com/egis-js-app/token'
    
    try {
      const response = await fetch(IQI_TOKEN_URL, {
        method: 'GET',
        mode: 'cors',
        cache: 'no-store'
      })
      
      if (!response.ok) {
        throw new Error(`IQI token fetch failed with status ${response.status}`)
      }
      
      const result = await response.json()
      const rawToken = result.access_token
      const expiresIn = result.expires_in || 7200
      
      if (!rawToken || typeof rawToken !== 'string') {
        throw new Error('Invalid IQI token response: missing or invalid access_token field')
      }
      
      const tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000)
      setIqiToken(rawToken)
      setIqiTokenExpiresAt(tokenExpiresAt)
      
      // Schedule next token refresh with safety margin
      const refreshIntervalMs = Math.max((expiresIn - 60) * 1000, 60000)
      if (iqiTokenRefreshTimerRef.current) {
        window.clearTimeout(iqiTokenRefreshTimerRef.current)
      }
      iqiTokenRefreshTimerRef.current = window.setTimeout(() => {
        void fetchIqiToken()
      }, refreshIntervalMs)
      
      return rawToken
    } catch (error) {
      console.error('Failed to fetch IQI token from', IQI_TOKEN_URL, error)
      setIqiToken(null)
      setIqiTokenExpiresAt(null)
      setIqiError(error instanceof Error ? error.message : 'Failed to fetch IQI token')
      
      if (iqiTokenRefreshTimerRef.current) {
        window.clearTimeout(iqiTokenRefreshTimerRef.current)
        iqiTokenRefreshTimerRef.current = null
      }
      
      return null
    }
  }, [])

  const ensureIqiToken = React.useCallback(async (): Promise<string | null> => {
    if (iqiToken && iqiTokenExpiresAt && Date.now() < iqiTokenExpiresAt) {
      return iqiToken
    }
    return await fetchIqiToken()
  }, [iqiToken, iqiTokenExpiresAt, fetchIqiToken])

  // ─── IQI LAYER DATA FETCHING ──────────────────────────────────────────────────

  const fetchIqiBbox = async (
    bbox: any,
    token: string,
    signal: AbortSignal,
    featureServerUrl: string,
    maxRecords: number,
    depth: number = 0
  ): Promise<{ features: any[]; truncatedCells: number; failedCells: number }> => {
    if (signal.aborted) return { features: [], truncatedCells: 0, failedCells: 0 }

    let tokenParam = encodeURIComponent(token)
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E'
    }

    const geometryFilter = encodeURIComponent(JSON.stringify({
      ...bbox,
      spatialReference: { wkid: 4326 }
    }))

    const url = `${featureServerUrl}/query?where=1=1&outFields=OBJECTID,rsrp&resultRecordCount=${maxRecords}&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`

    try {
      const res = await fetch(url, { signal })

      if (!res.ok) {
        console.warn(`IQI: HTTP ${res.status} for cell, skipping`)
        return { features: [], truncatedCells: 0, failedCells: 1 }
      }

      const text = await res.text()

      if (text.startsWith('<')) {
        console.warn('IQI: HTML response received, skipping')
        return { features: [], truncatedCells: 0, failedCells: 1 }
      }

      const json = JSON.parse(text)

      if (json.error) {
        console.warn('IQI: ArcGIS error:', json.error.message)
        return { features: [], truncatedCells: 0, failedCells: 1 }
      }

      const features = json.features || []

      // Adaptive subdivision: if we hit the record limit, subdivide into 4 quadrants
      if (features.length >= maxRecords && depth < 3) {
        console.log(`IQI: Cell returned ${features.length} features (limit ${maxRecords}), subdividing at depth ${depth + 1}`)
        const midX = (bbox.xmin + bbox.xmax) / 2
        const midY = (bbox.ymin + bbox.ymax) / 2
        const quadrants = [
          { xmin: bbox.xmin, ymin: bbox.ymin, xmax: midX, ymax: midY },
          { xmin: midX, ymin: bbox.ymin, xmax: bbox.xmax, ymax: midY },
          { xmin: bbox.xmin, ymin: midY, xmax: midX, ymax: bbox.ymax },
          { xmin: midX, ymin: midY, xmax: bbox.xmax, ymax: bbox.ymax }
        ]
        const results = await Promise.all(
          quadrants.map(q => fetchIqiBbox(q, token, signal, featureServerUrl, maxRecords, depth + 1))
        )
        let allFeatures: any[] = []
        let totalTruncated = 0
        let totalFailed = 0
        for (const r of results) {
          allFeatures = allFeatures.concat(r.features)
          totalTruncated += r.truncatedCells
          totalFailed += r.failedCells
        }
        return { features: allFeatures, truncatedCells: totalTruncated, failedCells: totalFailed }
      }

      // At max depth and still truncated — flag it
      if (features.length >= maxRecords && depth >= 3) {
        console.warn(`IQI: Cell still truncated at max depth ${depth} (${features.length} features)`)
        return { features, truncatedCells: 1, failedCells: 0 }
      }

      return { features, truncatedCells: 0, failedCells: 0 }
    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') {
        return { features: [], truncatedCells: 0, failedCells: 0 }
      }
      console.warn('IQI fetch error:', err)
      return { features: [], truncatedCells: 0, failedCells: 1 }
    }
  }

  const renderIqiFeatures = React.useCallback((features: any[]) => {
    if (!mapRef.current || features.length === 0) {
      return
    }

    const map = mapRef.current
    const geojson: any = { type: 'FeatureCollection', features }

    const sourceId = 'iqi-data-source'
    const fillLayerId = 'iqi-fill-layer'
    const outlineLayerId = 'iqi-outline-layer'

    // If source already exists, just update data in-place (no flicker)
    if (iqiSourceExistsRef.current && map.getSource(sourceId)) {
      ;(map.getSource(sourceId) as any).setData(geojson)
      return
    }

    // Source was unexpectedly removed (e.g. style change) — clean up stale state
    if (iqiSourceExistsRef.current && !map.getSource(sourceId)) {
      if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId)
      if (map.getLayer(fillLayerId)) map.removeLayer(fillLayerId)
      iqiSourceExistsRef.current = false
    }

    // First call: create source + layers
    map.addSource(sourceId, {
      type: 'geojson',
      data: geojson
    } as any)

    const beforeLayerId = findLabelLayerId(map)
    const opacityValue = iqiOpacity / 100

    map.addLayer({
      id: fillLayerId,
      type: 'fill',
      source: sourceId,
      paint: {
        'fill-color': [
          'step',
          ['get', 'rsrp'],
          '#9c27b0',        // < -118
          -118, '#f44336',  // -118 to -115
          -115, '#ff9800',  // -115 to -110
          -110, '#ffeb3b',  // -110 to -105
          -105, '#80deea',  // -105 to -95
          -95, '#2196f3',   // -95 to -85
          -85, '#4caf50'    // >= -85
        ],
        'fill-opacity': opacityValue
      }
    } as any, beforeLayerId)

    map.addLayer({
      id: outlineLayerId,
      type: 'line',
      source: sourceId,
      paint: {
        'line-color': '#ffffff',
        'line-width': 0.5,
        'line-opacity': opacityValue
      }
    } as any, beforeLayerId)

    overlayRef.current['iqi'] = {
      sourceIds: [sourceId],
      layerIds: [fillLayerId, outlineLayerId]
    }
    iqiSourceExistsRef.current = true
  }, [iqiOpacity])

  const fetchIqiData = React.useCallback(async () => {
    if (!mapRef.current) {
      return
    }

    const map = mapRef.current
    const zoom = map.getZoom()

    // Only load at zoom level 12+
    if (zoom < 12) {
      setIqiStatus('idle')
      setIqiFeatureCount(0)
      setIqiError(`Zoom in to 12+ to load features (current: ${Math.floor(zoom)})`)
      clearOverlay('iqi')
      iqiSourceExistsRef.current = false
      return
    }

    // Abort any previous fetch and clear batch timer
    if (iqiFetchControllerRef.current) {
      iqiFetchControllerRef.current.abort()
    }
    if (iqiBatchTimerRef.current) {
      window.clearTimeout(iqiBatchTimerRef.current)
      iqiBatchTimerRef.current = null
    }
    iqiFetchControllerRef.current = new AbortController()
    const signal = iqiFetchControllerRef.current.signal

    // Generation counter — all callbacks check this to discard stale results
    const generation = ++iqiGenerationRef.current

    setIqiStatus('loading-token')
    setIqiError(null)

    const token = await ensureIqiToken()
    if (!token) {
      setIqiStatus('error')
      setIqiError('Failed to get IQI token')
      return
    }

    if (signal.aborted || generation !== iqiGenerationRef.current) return

    const bounds = map.getBounds()
    const bbox = {
      xmin: bounds.getWest(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      ymax: bounds.getNorth()
    }

    const FEATURE_SERVER_URL = 'https://egisarcgis.dev.abc.com/arcgissecure/rest/services/INP/IQI_700_202511/FeatureServer/5'
    const MAX_RECORDS = 2000

    // Grid size based on zoom level
    const gridSize = zoom >= 15 ? 1 : zoom >= 14 ? 2 : zoom >= 13 ? 4 : 6

    setIqiStatus('loading-data')

    try {
      // Build grid cells
      const cellWidth = (bbox.xmax - bbox.xmin) / gridSize
      const cellHeight = (bbox.ymax - bbox.ymin) / gridSize
      const cells: any[] = []
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          cells.push({
            xmin: bbox.xmin + c * cellWidth,
            ymin: bbox.ymin + r * cellHeight,
            xmax: bbox.xmin + (c + 1) * cellWidth,
            ymax: bbox.ymin + (r + 1) * cellHeight
          })
        }
      }

      const seen = new Set<string>()
      const featureBuffer: any[] = []
      let completed = 0
      let totalTruncated = 0
      let totalFailed = 0
      const total = cells.length
      let renderScheduled = false

      // Dedup helper
      const addFeatures = (features: any[]) => {
        for (const f of features) {
          const id = f.id || f.properties?.OBJECTID || f.properties?.objectid
          if (id != null) {
            const key = String(id)
            if (seen.has(key)) continue
            seen.add(key)
          }
          featureBuffer.push(f)
        }
      }

      // Batched render — at most every 200ms during progressive loading
      const scheduleBatchRender = () => {
        if (renderScheduled || generation !== iqiGenerationRef.current) return
        renderScheduled = true
        iqiBatchTimerRef.current = window.setTimeout(() => {
          iqiBatchTimerRef.current = null
          renderScheduled = false
          if (generation !== iqiGenerationRef.current) return
          if (featureBuffer.length > 0) {
            renderIqiFeatures(featureBuffer)
          }
          setIqiFeatureCount(featureBuffer.length)
        }, 200)
      }

      // Fire all requests — browser manages concurrency (6 parallel)
      const promises = cells.map(cell =>
        fetchIqiBbox(cell, token, signal, FEATURE_SERVER_URL, MAX_RECORDS).then(result => {
          if (signal.aborted || generation !== iqiGenerationRef.current) return

          addFeatures(result.features)
          totalTruncated += result.truncatedCells
          totalFailed += result.failedCells
          completed++

          setIqiError(`Loading ${completed}/${total}... (${featureBuffer.length.toLocaleString()})`)
          scheduleBatchRender()
        })
      )

      await Promise.all(promises)

      if (signal.aborted || generation !== iqiGenerationRef.current) return

      // Clear any pending batch timer and do final render
      if (iqiBatchTimerRef.current) {
        window.clearTimeout(iqiBatchTimerRef.current)
        iqiBatchTimerRef.current = null
      }

      if (featureBuffer.length === 0) {
        setIqiStatus('idle')
        setIqiFeatureCount(0)
        setIqiError('No IQI features in viewport')
        clearOverlay('iqi')
        iqiSourceExistsRef.current = false
        return
      }

      renderIqiFeatures(featureBuffer)
      setIqiFeatureCount(featureBuffer.length)
      setIqiStatus('success')

      // Report partial-success warnings
      if (totalFailed > 0 || totalTruncated > 0) {
        const parts: string[] = []
        if (totalFailed > 0) parts.push(`${totalFailed} cell${totalFailed > 1 ? 's' : ''} failed`)
        if (totalTruncated > 0) parts.push(`${totalTruncated} cell${totalTruncated > 1 ? 's' : ''} truncated`)
        setIqiError(`Loaded ${featureBuffer.length.toLocaleString()} features (${parts.join(', ')})`)
      } else {
        setIqiError(null)
      }
    } catch (error) {
      if (signal.aborted || generation !== iqiGenerationRef.current) return

      console.error('IQI data fetch error:', error)
      setIqiStatus('error')
      setIqiError(error instanceof Error ? error.message : 'Failed to fetch IQI data')
      setIqiFeatureCount(0)
      clearOverlay('iqi')
      iqiSourceExistsRef.current = false
    }
  }, [ensureIqiToken, clearOverlay, renderIqiFeatures])

  const fetchOptimizationSectors = React.useCallback(async (activeToken: string, bounds: BBoxBounds) => {
    const requestUrl = `https://bird.web.abc.com/oauth21/api/metadata/sector/list/opto_area/frequency/${formatCoord(bounds.minLng)}/${formatCoord(bounds.minLat)}/${formatCoord(bounds.maxLng)}/${formatCoord(bounds.maxLat)}/`

    setOptimizationStatus('loading')
    setOptimizationError(null)
    setLastOptimizationUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        // The API returns a raw HTTP response in the body for 400 errors,
        // e.g. "HTTP/1.1 400 Bad Request\r\n...headers...\r\nConnection: close\r\n\r\nChoose smaller area"
        // The actual user message comes after the blank line that separates headers from body.
        let errorMsg = `Optimization request failed with status ${response.status}`
        try {
          const errorBody = await response.text()
          console.log('[Optimization] Error response body:', errorBody)
          if (errorBody) {
            // Try to extract the message after the header/body separator (double newline)
            const headerBodySplit = errorBody.split(/\r?\n\r?\n/)
            if (headerBodySplit.length > 1) {
              // The actual message is everything after the headers
              const bodyPart = headerBodySplit.slice(1).join('\n').trim()
              if (bodyPart) {
                errorMsg = bodyPart
              }
            } else {
              // No header separator found — use the whole text, stripped of HTML tags
              const plainText = errorBody.replace(/<[^>]*>/g, '').trim()
              if (plainText) {
                errorMsg = plainText
              }
            }
          }
        } catch {
          // Ignore body read errors, use default message
        }
        throw new Error(errorMsg)
      }

      const body = await response.json()
      if (Array.isArray(body)) {
        setOptimizationSectors(body)
        setOptimizationStatus('success')
        if (body.length > 0) {
          setSelectedOptimizationSector(body[0])
        }
      } else {
        throw new Error('Expected array response from optimization API')
      }
    } catch (error) {
      console.error('Failed to load optimization sectors', error)
      setOptimizationSectors([])
      setOptimizationStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching optimization endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationError(message)
    }
  }, [])

  const runOptimizationFetch = React.useCallback(async () => {
    const token = authTokenRef.current
    const bounds = optimizationBoundsRef.current
    if (!token) {
      setOptimizationError('Missing token')
      return
    }
    if (!bounds) {
      setOptimizationError('Draw a bounding box first')
      return
    }
    await fetchOptimizationSectors(token, bounds)
  }, [fetchOptimizationSectors])

  const submitOptimizationJob = React.useCallback(async () => {
    const token = authTokenRef.current
    const bounds = optimizationBoundsRef.current
    const sector = selectedOptimizationSector

    if (!token) {
      setOptimizationJobError('Missing authentication token')
      return
    }
    if (!bounds) {
      setOptimizationJobError('Missing bounding box')
      return
    }
    if (!sector) {
      setOptimizationJobError('Please select a sector')
      return
    }
    if (!sessionId || !jobId) {
      setOptimizationJobError('Session/Job IDs not generated')
      return
    }

    const requestUrl = `https://bird.web.abc.com/oauth21/api/bird/bbox/optimize/${encodeURIComponent(sessionId)}/?output=json&job_id=${encodeURIComponent(jobId)}`

    // Store job parameters for later retrieval when results are loaded
    const jobKey = `${sessionId}-${jobId}`
    submittedJobParamsRef.current[jobKey] = {
      frequency: sector,
      networkType: selectedNetworkType,
      hyperparameters: { ...hyperparameters },
      availableFrequencies: [...optimizationSectors]
    }

    setOptimizationJobStatus('polling')
    setOptimizationJobError(null)
    setStatusMessage('')
    setSubmissionResponse(null)
    setLastSubmissionUrl(requestUrl)
    console.log('[Optimization] Submitting job to:', requestUrl)

    // Start polling the status URL immediately — the server begins
    // writing progress messages as soon as it receives the POST.
    void pollOptimizationStatus()

    try {
      const basePayload = {
        min_latitude: bounds.minLat,
        min_longitude: bounds.minLng,
        max_latitude: bounds.maxLat,
        max_longitude: bounds.maxLng,
        frequencies: [sector],
        technologies: [selectedNetworkType]
      }

      // Add hyperparameters only if they've been modified from defaults
      const payload = hasHyperparametersChanged()
        ? { ...basePayload, ...hyperparameters }
        : basePayload

      console.log('[Optimization] Request payload:', JSON.stringify(payload, null, 2))

      const response = await fetch(requestUrl, {
        method: 'POST',
        cache: 'no-store',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(payload)
      })

      console.log('[Optimization] Response status:', response.status, response.statusText)

      let body: any = null
      let bodyText = ''
      try {
        bodyText = await response.text()
        console.log('[Optimization] Response body (raw):', bodyText)
        if (bodyText) {
          body = JSON.parse(bodyText)
          console.log('[Optimization] Response body (parsed):', body)
        }
      } catch (parseError) {
        console.error('[Optimization] Failed to parse response:', parseError)
        body = { raw: bodyText }
      }

      setSubmissionResponse(body)

      if (!response.ok) {
        // Don't throw — the statusUrl polling will pick up the real error
        // message from the API. Just log the HTTP status for debugging.
        console.warn('[Optimization] POST returned', response.status, response.statusText, '— status polling will report the error')
        return
      }

      console.log('[Optimization] Checking for results in response...')
      console.log('[Optimization] Has results property?', !!body?.results)
      console.log('[Optimization] Response keys:', Object.keys(body || {}))

      // Check if response contains complete results data (with histograms, scores, etc.)
      // If results exist, we can display them immediately without polling
      const hasCompleteResults = body?.results?.histograms && body?.results?.total_scores

      if (hasCompleteResults) {
        console.log('[Optimization] ✓ Complete results found in submission response - NO POLLING NEEDED')
        // Stop polling — we already have everything
        if (pollingTimerRef.current) {
          window.clearTimeout(pollingTimerRef.current)
          pollingTimerRef.current = null
        }
        setOptimizationResults(body)
        setOptimizationJobStatus('completed')
      }
      // Otherwise polling continues automatically via pollOptimizationStatus
    } catch (error) {
      console.error('[Optimization] Failed to submit job:', error)
      // Stop polling on submission error
      if (pollingTimerRef.current) {
        window.clearTimeout(pollingTimerRef.current)
        pollingTimerRef.current = null
      }
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching optimization endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationJobError(message)
      setStatusMessage(message)
      setOptimizationJobStatus('error')
    }
  }, [sessionId, jobId, selectedOptimizationSector])

  const pollOptimizationStatus = React.useCallback(async () => {
    const token = authTokenRef.current

    if (!token || !sessionId || !jobId) {
      console.log('[Optimization] Polling aborted: missing token or IDs')
      return
    }

    const statusUrl = `https://bird.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(sessionId)}/${encodeURIComponent(jobId)}/status.json`
    setLastStatusUrl(statusUrl)

    try {
      const response = await fetch(statusUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        }
      })

      let body: any = null
      try {
        const bodyText = await response.text()
        if (bodyText) body = JSON.parse(bodyText)
      } catch {
        // keep body null on parse failure
      }


      const status: string = body?.status ?? ''
      const message: string = body?.message ?? ''

      if (status === 'TRACE_ENDING') {
        // Job complete — fetch results
        console.log('[Optimization] ✓ Job completed (TRACE_ENDING)')
        if (message) setStatusMessage(message)
        setOptimizationJobStatus('completed')
        if (pollingTimerRef.current) {
          window.clearTimeout(pollingTimerRef.current)
          pollingTimerRef.current = null
        }
        setTimeout(() => { void fetchOptimizationResults() }, 500)
      } else if (status === 'ERROR' || status === 'FAILED') {
        // Job failed — show message, no more polling
        console.log('[Optimization] ✗ Job failed:', status, message)
        setStatusMessage(message || 'Optimization failed')
        setOptimizationJobError(message || 'Optimization failed')
        setOptimizationJobStatus('error')
        if (pollingTimerRef.current) {
          window.clearTimeout(pollingTimerRef.current)
          pollingTimerRef.current = null
        }
      } else {
        // status === 'OK' or any in-progress state — update message, keep polling
        if (message) setStatusMessage(message)
        if (pollingTimerRef.current) window.clearTimeout(pollingTimerRef.current)
        pollingTimerRef.current = window.setTimeout(() => {
          void pollOptimizationStatus()
        }, STATUS_POLL_INTERVAL_MS)
      }
    } catch (error) {
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching status endpoint'
        : error instanceof Error ? error.message : 'Unknown error'
      setStatusMessage(message)
      setOptimizationJobError(message)
      setOptimizationJobStatus('error')
      if (pollingTimerRef.current) {
        window.clearTimeout(pollingTimerRef.current)
        pollingTimerRef.current = null
      }
    }
  }, [sessionId, jobId])

  // Cleanup polling timer on unmount
  React.useEffect(() => {
    return () => {
      if (pollingTimerRef.current) {
        window.clearTimeout(pollingTimerRef.current)
        pollingTimerRef.current = null
      }
    }
  }, [])

  const fetchOptimizationLayer = React.useCallback(async (activeToken: string, layerType: OptimizationLayerType) => {
    if (layerType === 'none') {
      // Clear the result-specific optimization layer
      if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
        const resultId = optimizationResultsArray[activeResultIndex].id
        clearOverlay(`optimization-layer-${resultId}`)
      }
      // Also clear the generic optimization-layer key for backward compatibility
      clearOverlay('optimization-layer')
      setOptimizationLayerData(null)
      setOptimizationLayerStatus('idle')
      setOptimizationLayerError(null)
      return
    }

    // Get session/job IDs from active result instead of component state
    let activeSessionId = sessionId
    let activeJobId = jobId

    if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
      const activeResult = optimizationResultsArray[activeResultIndex]
      activeSessionId = activeResult.sessionId
      activeJobId = activeResult.jobId
    }

    if (!activeSessionId || !activeJobId) {
      setOptimizationLayerError('Session ID and Job ID are required')
      return
    }

    const layerPathMap: Record<string, string> = {
      bin_state_pre: `bin_state/pre_data`,
      bin_state_post: `bin_state/post_data`,
      bin_state_diff: `bin_state/diff_data`,
      sinr_pre: `sinr/pre_data`,
      sinr_post: `sinr/post_data`,
      sinr_floor: `sinr/floor_data`,
      sinr_delta: `sinr/delta_data`,
      sector_id_pre: `sector_id/pre_data`,
      sector_id_post: `sector_id/post_data`,
      sector_id_diff: `sector_id/diff_data`,
      rsrp_pre: `rsrp_dbm/pre_data`,
      rsrp_post: `rsrp_dbm/post_data`,
      rsrp_diff: `rsrp_dbm/diff_data`,
      user_density: `user_density/any`
    }

    const layerPath = layerPathMap[layerType]
    if (!layerPath) {
      setOptimizationLayerError(`Unknown layer type: ${layerType}`)
      return
    }

    const requestUrl = `https://bird.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(activeSessionId)}/${encodeURIComponent(activeJobId)}/${layerPath}/style.json`

    setOptimizationLayerStatus('loading')
    setOptimizationLayerError(null)

    try {
      const response = await fetch(requestUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Layer request failed with status ${response.status}`)
      }

      const body = await response.json()

      // Store data per result if we have an active result
      if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
        const resultId = optimizationResultsArray[activeResultIndex].id
        resultLayerDataRef.current[resultId] = body
        resultLayerStatusRef.current[resultId] = 'success'

        // Apply overlay with result-specific key - each result gets its own visualization layer
        applyOverlayStyle(`optimization-layer-${resultId}`, body)

        setOptimizationLayerStatus('success')
      }
    } catch (error) {
      console.error('Failed to load optimization layer', error)

      // Update per-result status if we have an active result
      if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
        const resultId = optimizationResultsArray[activeResultIndex].id
        resultLayerStatusRef.current[resultId] = 'error'
      }

      setOptimizationLayerData(null)
      setOptimizationLayerStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching layer endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationLayerError(message)
    }
  }, [sessionId, jobId, activeResultIndex, optimizationResultsArray, clearOverlay, applyOverlayStyle])

  const fetchOptimizationResults = React.useCallback(async () => {
    const token = authTokenRef.current

    if (!token || !sessionId || !jobId) {
      console.log('[Optimization] Cannot fetch results: missing token or IDs')
      return
    }

    const resultsUrl = `https://bird.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(sessionId)}/${encodeURIComponent(jobId)}/data.json`
    console.log('[Optimization] Fetching results from:', resultsUrl)
    setResultsError(null)

    try {
      const response = await fetch(resultsUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        }
      })

      console.log('[Optimization] Results response:', response.status, response.statusText)

      let body: any = null
      let bodyText = ''
      try {
        bodyText = await response.text()
        console.log('[Optimization] Results body (raw, first 500 chars):', bodyText.substring(0, 500))
        if (bodyText) {
          body = JSON.parse(bodyText)
          console.log('[Optimization] Results parsed successfully')
        }
      } catch (parseError) {
        console.error('[Optimization] Failed to parse results:', parseError)
        throw new Error('Failed to parse results JSON')
      }

      if (!response.ok) {
        const errorMsg = body?.message || body?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(`Results fetch failed: ${errorMsg}`)
      }

      // Dual-write: Keep old state for backward compatibility
      setOptimizationResults(body)
      setShowResultsView(true)

      // New: Add to results array
      const bounds: BBoxBounds = optimizationBoundsRef.current || { minLng: 0, minLat: 0, maxLng: 0, maxLat: 0 }
      const colorIndex = optimizationResultsArray.length % RESULT_COLORS.length
      const color = RESULT_COLORS[colorIndex]

      // Retrieve saved job parameters
      const jobKey = `${sessionId}-${jobId}`
      const savedParams = submittedJobParamsRef.current[jobKey]

      // Extract the submission time from the API response
      // The "time" field may be at the top level or nested under "results"
      const apiTime: string | undefined = body?.time || body?.results?.time
      console.log('[Optimization] API response top-level keys:', Object.keys(body || {}))
      console.log('[Optimization] body.time:', body?.time, '| body.results?.time:', body?.results?.time)
      console.log('[Optimization] Resolved apiTime:', apiTime)

      const newResult: OptimizationResult = {
        id: generateUniqueId(),
        sessionId,
        jobId,
        bounds,
        data: body,
        timestamp: Date.now(),
        label: apiTime ? `Submitted: ${apiTime}` : `Submitted: ${new Date().toLocaleString()}`,
        color,
        source: 'submitted',
        submittedTime: apiTime,
        // Store optimization parameters with this result - use saved params if available
        frequency: savedParams?.frequency ?? selectedOptimizationSector,
        networkType: savedParams?.networkType ?? selectedNetworkType,
        hyperparameters: savedParams?.hyperparameters ?? { ...hyperparameters },
        availableFrequencies: savedParams?.availableFrequencies ?? [...optimizationSectors]
      }

      // Clean up saved params after use
      if (savedParams) {
        delete submittedJobParamsRef.current[jobKey]
      }

      // Check if we've reached the limit of 4 results
      if (optimizationResultsArray.length >= 4) {
        console.warn('[Optimization] Maximum of 4 results reached')
        return
      }

      setOptimizationResultsArray((prev: OptimizationResult[]) => [...prev, newResult])
      setActiveResultIndex(optimizationResultsArray.length)
      setShowResultsPanel(true)

      // Clear the drawing state so input controls hide and read-only display shows
      setOptimizationBounds(null)
      optimizationBoundsRef.current = null
      setOptimizationStatus('idle')

      console.log('[Optimization] Results loaded successfully, added to array:', newResult.id)
    } catch (error) {
      console.error('[Optimization] Failed to fetch results:', error)
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching results endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setResultsError(message)
    }
  }, [sessionId, jobId])

  const recallOptimizationResult = React.useCallback(async (recallSessionId: string, recallJobId: string) => {
    const token = authTokenRef.current

    if (!token) {
      setRecallForm((prev: RecallFormState) => ({ ...prev, error: 'No authentication token available', loading: false }))
      return
    }

    const trimmedSessionId = recallSessionId.trim()
    const trimmedJobId = recallJobId.trim()

    if (!trimmedSessionId || !trimmedJobId) {
      setRecallForm((prev: RecallFormState) => ({ ...prev, error: 'Session ID and Job ID are required', loading: false }))
      return
    }

    setRecallForm((prev: RecallFormState) => ({ ...prev, loading: true, error: null }))

    const resultsUrl = `https://bird.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(trimmedSessionId)}/${encodeURIComponent(trimmedJobId)}/data.json`
    console.log('[Recall] Fetching results from:', resultsUrl)

    try {
      const response = await fetch(resultsUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        }
      })

      console.log('[Recall] Response:', response.status, response.statusText)

      if (!response.ok) {
        let body: any = {}
        try {
          const bodyText = await response.text()
          body = JSON.parse(bodyText)
        } catch {
          // Ignore parse errors
        }
        const errorMsg = body?.message || body?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(`Failed to recall results: ${errorMsg}`)
      }

      const data = await response.json()
      console.log('[Recall] Results loaded successfully')

      // Extract bounding box from results data if available, otherwise use placeholder
      const bounds: BBoxBounds = extractBoundsFromResults(data) || {
        minLng: 0,
        minLat: 0,
        maxLng: 0,
        maxLat: 0
      }

      // Assign color from palette based on current array length
      const colorIndex = optimizationResultsArray.length % RESULT_COLORS.length
      const color = RESULT_COLORS[colorIndex]

      // Extract the original submission time from the API response
      // The "time" field may be at the top level or nested under "results"
      const apiTime: string | undefined = data?.time || data?.results?.time
      console.log('[Recall] API response top-level keys:', Object.keys(data || {}))
      console.log('[Recall] data.time:', data?.time, '| data.results?.time:', data?.results?.time)
      console.log('[Recall] Resolved apiTime:', apiTime)

      const newResult: OptimizationResult = {
        id: generateUniqueId(),
        sessionId: trimmedSessionId,
        jobId: trimmedJobId,
        bounds,
        data,
        timestamp: Date.now(),
        label: 'Recalled',
        color,
        source: 'recalled',
        submittedTime: apiTime
      }

      // Check if we've reached the limit of 4 results
      if (optimizationResultsArray.length >= 4) {
        setRecallForm((prev: RecallFormState) => ({
          ...prev,
          error: 'Maximum of 4 optimization results reached. Please remove one before adding another.',
          loading: false
        }))
        return
      }

      // Add to results array and set as active
      setOptimizationResultsArray((prev: OptimizationResult[]) => [...prev, newResult])
      setActiveResultIndex(optimizationResultsArray.length)
      setShowResultsPanel(true)

      // Clear the drawing state so input controls don't show
      setOptimizationBounds(null)
      optimizationBoundsRef.current = null
      setOptimizationStatus('idle')

      // Clear and hide recall form
      setRecallForm({ sessionId: '', jobId: '', error: null, loading: false })
      setRecallFormVisible(false)

      console.log('[Recall] Result added to array:', newResult.id)
    } catch (error) {
      console.error('[Recall] Failed to fetch results:', error)
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching results endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setRecallForm((prev: RecallFormState) => ({ ...prev, error: message, loading: false }))
    }
  }, [optimizationResultsArray])

  const fetchMetadataSectorStyle = React.useCallback(async (activeToken: string) => {
    const requestUrl = DEFAULT_METADATA_SECTOR_STYLE_URL
    setMetadataStyleStatus('loading')
    setMetadataStyleError(null)
    setLastMetadataStyleUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Metadata sector style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setMetadataStyleData(body)
      setMetadataStyleStatus('success')
    } catch (error) {
      console.error('Failed to load metadata sector style', error)
      setMetadataStyleData(null)
      setMetadataStyleStatus('error')
      setMetadataStyleError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const fetchCoverageStyle = React.useCallback(async (activeToken: string, layer: CoverageLayer) => {
    const requestUrl = DEFAULT_COVERAGE_STYLE_URL.replace('{coverage_layer}', encodeURIComponent(layer))
    setCoverageStyleStatus('loading')
    setCoverageStyleError(null)
    setLastCoverageStyleUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Coverage style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setCoverageStyleData(body)
      setCoverageStyleStatus('success')
    } catch (error) {
      console.error('Failed to load coverage style', error)
      setCoverageStyleData(null)
      setCoverageStyleStatus('error')
      setCoverageStyleError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const fetchSectorMetadata = React.useCallback(async (activeToken: string, sectorName: string) => {
    const metadataUrl = `https://bird.web.abc.com/oauth21/api/metadata/sector/name/${encodeURIComponent(sectorName)}`
    setSectorMetadataStatus('loading')
    setSectorMetadataError(null)

    try {
      const response = await fetch(metadataUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Sector metadata request failed with status ${response.status}`)
      }

      const body = await response.json()
      setSectorMetadata(body)
      setSectorMetadataStatus('success')
      // Initialize selected tilt to current_tilt
      if (body.current_tilt !== undefined) {
        setSelectedSectorTilt(body.current_tilt)
      }
      return body
    } catch (error) {
      console.error('Failed to load sector metadata', error)
      setSectorMetadata(null)
      setSectorMetadataStatus('error')
      setSectorMetadataError(error instanceof Error ? error.message : 'Unknown error')
      return null
    }
  }, [])

  const fetchSectorStyle = React.useCallback(async (activeToken: string, sectorName: string, tilt: number, coverageType: 'RSRP' | 'los_poly') => {
    const requestUrl = `https://bird.web.abc.com/oauth21/api/sector/tile/${encodeURIComponent(sectorName)}/${tilt}/${coverageType}/style.json`
    setSectorStyleStatus('loading')
    setSectorStyleError(null)
    setLastSectorStyleUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Sector style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setSectorStyleData(body)
      setSectorStyleStatus('success')
    } catch (error) {
      console.error('Failed to load sector style', error)
      setSectorStyleData(null)
      setSectorStyleStatus('error')
      setSectorStyleError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const clearSectorView = React.useCallback(() => {
    setClickedSectorData(null)
    setSectorStyleData(null)
    setSectorStyleStatus('idle')
    setSectorStyleError(null)
    setLastSectorStyleUrl(null)
    setSectorMetadata(null)
    setSectorMetadataStatus('idle')
    setSectorMetadataError(null)
    setSelectedSectorTilt(null)
    setSectorCoverageType('RSRP')
    if (mapRef.current && mapReady) {
      clearOverlay('clicked-sector')
    }
  }, [mapReady, clearOverlay])

  React.useEffect(() => {
    // When user switches the coverageLayer option, clear the old overlay/state.
    setCoverageStyleData(null)
    setCoverageStyleStatus('idle')
    setCoverageStyleError(null)
    setLastCoverageStyleUrl(null)
    coverageOriginalOpacityRef.current = {}
    if (mapReady) {
      clearOverlay('coverage')
    }
  }, [coverageLayer, mapReady, clearOverlay])

  // Note: Global optimization layer removed - now using per-result layers only
  // Each result's visualization layer is managed independently with key: optimization-layer-${resultId}
  // This allows multiple results to have their visualizations visible simultaneously

  React.useEffect(() => {
    const handler = (event: Event) => {
      const detail = (event as CustomEvent)?.detail as { sectorName?: string }
      if (typeof detail?.sectorName === 'string' && detail.sectorName.trim().length > 0) {
        setSectorName(detail.sectorName.trim())
      }
    }

    window.addEventListener('map-widget:set-sector', handler as EventListener)
    return () => window.removeEventListener('map-widget:set-sector', handler as EventListener)
  }, [])

  React.useEffect(() => {
    const win = window as Window & { mapWidgetSetSector?: (sector: string) => void }
    win.mapWidgetSetSector = (sector: string) => {
      if (typeof sector === 'string' && sector.trim().length > 0) {
        setSectorName(sector.trim())
      }
    }
    return () => {
      if (win.mapWidgetSetSector) {
        delete win.mapWidgetSetSector
      }
    }
  }, [])

  React.useEffect(() => {
    void refreshToken()

    return () => {
      if (tokenRefreshTimerRef.current) {
        window.clearTimeout(tokenRefreshTimerRef.current)
      }
    }
  }, [refreshToken])

  React.useEffect(() => {
    if (!authState.accessToken) {
      return
    }

    if (isApiEnabled('meta')) {
      void fetchMetadataSectorStyle(authState.accessToken)
    }

    if (isApiEnabled('coverage')) {
      void fetchCoverageStyle(authState.accessToken, coverageLayer)
    }
  }, [authState.accessToken, coverageLayer, fetchMetadataSectorStyle, fetchCoverageStyle, isApiEnabled])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !coverageStyleData) {
      return
    }

    if (!isApiEnabled('coverage')) {
      clearOverlay('coverage')
      return
    }

    try {
      applyOverlayStyle('coverage', coverageStyleData)
      
      // If coverage is not visible, immediately hide all layers
      if (!coverageVisible && mapRef.current) {
        const overlay = overlayRef.current['coverage']
        if (overlay?.layerIds?.length) {
          const map = mapRef.current
          overlay.layerIds.forEach((layerId: string) => {
            if (map.getLayer(layerId)) {
              map.setLayoutProperty(layerId, 'visibility', 'none')
            }
          })
        }
      }
    } catch (error) {
      console.error('Failed to apply coverage style', error)
      setCoverageStyleStatus('error')
      setCoverageStyleError(error instanceof Error ? error.message : 'Failed to apply coverage style')
    }
  }, [mapReady, coverageStyleData, applyOverlayStyle, clearOverlay, isApiEnabled, coverageVisible])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    if (!isApiEnabled('coverage')) {
      return
    }

    const overlay = overlayRef.current['coverage']
    if (!overlay?.layerIds?.length) {
      return
    }

    const map = mapRef.current
    const opacityMultiplier = coverageVisible ? coverageOpacity / 50 : 0

    overlay.layerIds.forEach((layerId: string) => {
      const layer: any = map.getLayer(layerId)
      if (!layer) {
        return
      }

      // Apply opacity to all coverage layers by multiplying original opacity with slider value
      const layerType = layer.type
      if (layerType === 'fill') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'fill-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'line') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'line-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'circle') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'circle-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'heatmap') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'heatmap-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'symbol') {
        const originalTextOpacity = coverageOriginalOpacityRef.current[`${layerId}-text`] ?? 1
        const originalIconOpacity = coverageOriginalOpacityRef.current[`${layerId}-icon`] ?? 1
        map.setPaintProperty(layerId, 'text-opacity', originalTextOpacity * opacityMultiplier)
        map.setPaintProperty(layerId, 'icon-opacity', originalIconOpacity * opacityMultiplier)
      }

      // Handle visibility based on coverageVisible flag
      if (!coverageVisible) {
        map.setLayoutProperty(layerId, 'visibility', 'none')
        return
      }

      // Match website behavior:
      // - Show bins ON  => show dots, hide blended/heatmap layers
      // - Show bins OFF => hide dots, show blended/heatmap layers
      if (looksLikeBinLayer(layer)) {
        // If this style has *only* bin layers, don't hide them (otherwise we'd blank the overlay).
        const shouldHideBins = !coverageShowBins && coverageStyleLayerSummary.nonBinCount > 0
        map.setLayoutProperty(layerId, 'visibility', shouldHideBins ? 'none' : 'visible')
        return
      }

      if (looksLikeAggregatedLayer(layer)) {
        map.setLayoutProperty(layerId, 'visibility', coverageShowBins ? 'none' : 'visible')
      } else {
        map.setLayoutProperty(layerId, 'visibility', 'visible')
      }
    })
  }, [mapReady, coverageShowBins, coverageOpacity, coverageVisible, coverageStyleData, coverageStyleLayerSummary.nonBinCount, isApiEnabled])

  // ─── IQI LAYER EFFECTS ─────────────────────────────────────────────────────────

  // Handle IQI visibility toggle
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    if (iqiVisible) {
      // Fetch IQI data when toggled on
      void fetchIqiData()
    } else {
      // Clear IQI overlay when toggled off
      clearOverlay('iqi')
      iqiSourceExistsRef.current = false
      setIqiStatus('idle')
      setIqiFeatureCount(0)
      setIqiError(null)

      // Abort any in-flight fetches and clear batch timer
      if (iqiFetchControllerRef.current) {
        iqiFetchControllerRef.current.abort()
        iqiFetchControllerRef.current = null
      }
      if (iqiBatchTimerRef.current) {
        window.clearTimeout(iqiBatchTimerRef.current)
        iqiBatchTimerRef.current = null
      }
    }
  }, [mapReady, iqiVisible, fetchIqiData, clearOverlay])

  // Handle IQI opacity changes
  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !iqiVisible) {
      return
    }

    const overlay = overlayRef.current['iqi']
    if (!overlay?.layerIds?.length) {
      return
    }

    const map = mapRef.current
    const opacityValue = iqiOpacity / 100

    overlay.layerIds.forEach((layerId: string) => {
      const layer: any = map.getLayer(layerId)
      if (!layer) {
        return
      }

      if (layer.type === 'fill') {
        map.setPaintProperty(layerId, 'fill-opacity', opacityValue)
      } else if (layer.type === 'line') {
        map.setPaintProperty(layerId, 'line-opacity', opacityValue)
      }
    })
  }, [mapReady, iqiOpacity, iqiVisible])

  // Handle map move/zoom for dynamic IQI loading
  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !iqiVisible) {
      return
    }

    const map = mapRef.current
    let debounceTimer: number | null = null

    const handleMapChange = () => {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer)
      }
      debounceTimer = window.setTimeout(() => {
        void fetchIqiData()
      }, 500)
    }

    map.on('moveend', handleMapChange)
    map.on('zoomend', handleMapChange)

    return () => {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer)
      }
      map.off('moveend', handleMapChange)
      map.off('zoomend', handleMapChange)
    }
  }, [mapReady, iqiVisible, fetchIqiData])

  // Cleanup IQI timers and controllers on unmount
  React.useEffect(() => {
    return () => {
      if (iqiTokenRefreshTimerRef.current) {
        window.clearTimeout(iqiTokenRefreshTimerRef.current)
        iqiTokenRefreshTimerRef.current = null
      }
      if (iqiFetchControllerRef.current) {
        iqiFetchControllerRef.current.abort()
        iqiFetchControllerRef.current = null
      }
      if (iqiBatchTimerRef.current) {
        window.clearTimeout(iqiBatchTimerRef.current)
        iqiBatchTimerRef.current = null
      }
    }
  }, [])

  // ─── END IQI LAYER EFFECTS ─────────────────────────────────────────────────────

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !metadataStyleData) {
      return
    }

    if (!isApiEnabled('meta')) {
      clearOverlay('meta')
      return
    }

    try {
      applyOverlayStyle('meta', metadataStyleData)
      console.log('[3D Sectors] Metadata layer loaded, triggering 3D scene update')
      
      // Trigger 3D sectors to update after metadata layer is added
      setTimeout(() => {
        if (mapRef.current && show3DSectors) {
          const updated = threeDSceneRef.current.updateAfterMove()
          if (updated) {
            console.log('[3D Sectors] Scene updated after metadata load')
            mapRef.current.triggerRepaint()
          }
        }
      }, 500)
    } catch (error) {
      console.error('Failed to apply metadata sector style', error)
      setMetadataStyleStatus('error')
      setMetadataStyleError(error instanceof Error ? error.message : 'Failed to apply metadata sector style')
    }
  }, [mapReady, metadataStyleData, applyOverlayStyle, clearOverlay, isApiEnabled, show3DSectors])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !sectorStyleData) {
      return
    }

    try {
      // Hide coverage layer when showing sector view
      if (coverageStyleData) {
        clearOverlay('coverage')
      }
      
      applyOverlayStyle('clicked-sector', sectorStyleData)
    } catch (error) {
      console.error('Failed to apply sector style', error)
      setSectorStyleStatus('error')
      setSectorStyleError(error instanceof Error ? error.message : 'Failed to apply sector style')
    }
  }, [mapReady, sectorStyleData, applyOverlayStyle, coverageStyleData, clearOverlay])

  React.useEffect(() => {
    // Re-show coverage layer when sector view is cleared
    if (!clickedSectorData && !sectorStyleData && coverageStyleData && mapReady && mapRef.current) {
      try {
        applyOverlayStyle('coverage', coverageStyleData)
        
        // If coverage is not visible, immediately hide all layers
        if (!coverageVisible && mapRef.current) {
          const overlay = overlayRef.current['coverage']
          if (overlay?.layerIds?.length) {
            const map = mapRef.current
            overlay.layerIds.forEach((layerId: string) => {
              if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', 'none')
              }
            })
          }
        }
      } catch (error) {
        console.error('Failed to re-apply coverage style', error)
      }
    }
  }, [clickedSectorData, sectorStyleData, coverageStyleData, mapReady, applyOverlayStyle, coverageVisible])

  // Define sector color theme
  const getSectorColor = React.useCallback((data: SectorData): number => {
    // Color by band - using softer, more muted tones
    const bandColors: Record<string, number> = {
      // 700 MHz bands - Soft Coral
      '700': 0xcc7a7a,
      '700_B14': 0xcc7a7a,
      'LTE700': 0xcc7a7a,
      
      // 850 MHz band - Soft Orange
      '850': 0xcc9966,
      'LTE850': 0xcc9966,
      
      // 1900 MHz / PCS band - Soft Green
      'PCS': 0x7fbc7f,
      '1900': 0x7fbc7f,
      'LTE1900': 0x7fbc7f,
      
      // 2100 MHz / AWS band - Soft Teal
      'AWS': 0x70b8b8,
      'AWS-1': 0x70b8b8,
      '2100': 0x70b8b8,
      'LTE2100': 0x70b8b8,
      
      // 2300 MHz / WCS band - Soft Blue
      'WCS': 0x7a9fd9,
      '2300': 0x7a9fd9,
      'LTE2300': 0x7a9fd9,
      
      // 2500 MHz band - Soft Lavender
      '2500': 0xbf8fbf,
      'LTE2500': 0xbf8fbf,
      
      // 3500 MHz / n77/n78 5G band - Soft Yellow
      '3500': 0xcccc7a,
      'NR3500': 0xcccc7a,
      'n77': 0xcccc7a,
      'n78': 0xcccc7a,
      
      // mmWave / 28 GHz - Soft Pink
      '28000': 0xd98fad,
      'NR28000': 0xd98fad,
      'n261': 0xd98fad
    }
    const color = bandColors[data.band] ?? 0xcccccc
    return color
  }, [])

  React.useEffect(() => {
    if (!mapRef.current) {
      return
    }

    const handleError = (event: any) => {
      const message = event?.error?.message || 'Map error'
      console.error('MapLibre error event', event)
      setLastMapError(message)
    }

    mapRef.current.on('error', handleError)
    return () => {
      mapRef.current?.off('error', handleError)
    }
  }, [mapReady])

  React.useEffect(() => {
    if (!mapContainerRef.current) {
      return
    }

    let map: MapLibreMap | null = null
    let disposed = false
    let handleLoad: (() => void) | null = null
    let handleMouseMove: ((e: maplibregl.MapLayerMouseEvent) => void) | null = null
    let handleClick: ((e: maplibregl.MapLayerMouseEvent) => void) | null = null
    let handleMoveEnd: (() => void) | null = null
    let handleIdle: (() => void) | null = null

    const cleanupMap = () => {
      if (!map) {
        return
      }

      if (handleLoad) map.off('load', handleLoad)
      if (handleMouseMove) map.off('mousemove', handleMouseMove)
      if (handleClick) map.off('click', handleClick)
      if (handleMoveEnd) map.off('moveend', handleMoveEnd)
      if (handleIdle) map.off('idle', handleIdle)

      const overlays = Object.values(overlayRef.current) as Array<{ sourceIds: string[], layerIds: string[] }>
      overlays.forEach((overlay) => {
        overlay.layerIds.forEach((layerId: string) => {
          if (map?.getLayer(layerId)) {
            map.removeLayer(layerId)
          }
        })
        overlay.sourceIds.forEach((sourceId: string) => {
          if (map?.getSource(sourceId)) {
            map.removeSource(sourceId)
          }
        })
      })
      overlayRef.current = {}

      map.remove()
      mapRef.current = null
      map = null
      setMapReady(false)
    }

    const initializeMap = async () => {
      if (isbirdProtectedUrl(styleUrl) && !authTokenRef.current) {
        const token = await refreshToken()
        if (!token || disposed || !mapContainerRef.current) {
          return
        }
      }

      if (disposed || !mapContainerRef.current) {
        return
      }

      const mapOptions: maplibregl.MapOptions & { antialias?: boolean } = {
        container: mapContainerRef.current,
        style: styleUrl,
        center: DEFAULT_CENTER,
        zoom: DEFAULT_ZOOM,
        bearing: DEFAULT_BEARING,
        pitch: DEFAULT_PITCH,
        antialias: true,
        pixelRatio,
        transformRequest: (url: string) => {
          const token = authTokenRef.current
          if (!token || !isbirdProtectedUrl(url)) {
            return { url }
          }

          return {
            url,
            headers: {
              Authorization: `Bearer ${token}`
            }
          }
        }
      }

      map = new maplibregl.Map(mapOptions)
      map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'bottom-left')
      mapRef.current = map

      handleLoad = () => {
        if (!map) {
          return
        }

        if (!map.getLayer('three-d-sectors-layer')) {
          console.log('[3D Sectors] Adding 3D sectors custom layer')
          map.addLayer({
            id: 'three-d-sectors-layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd: function (_map: MapLibreMap, gl: WebGLRenderingContext | WebGL2RenderingContext) {
              console.log('[3D Sectors] Initializing 3D scene')
              threeDSceneRef.current.initialize(_map, gl)
              threeDSceneRef.current.setLayerProps(ThreeD.LayerType.Sectors, {
                getSectorColor: getSectorColor,
                visible: show3DSectors,
                scale: sectorScale
              })
              console.log('[3D Sectors] Initial scene update (metadata layer may not be ready yet)')
              const updated = threeDSceneRef.current.updateAfterMove()
              if (updated) {
                console.log('[3D Sectors] Initial update successful')
                _map.triggerRepaint()
              } else {
                console.log('[3D Sectors] Waiting for metadata layer to load...')
              }
            },
            render: function (_gl: WebGLRenderingContext | WebGL2RenderingContext, args: any) {
              threeDSceneRef.current.render(args as CustomRenderMethodInput)
            }
          } as any)
        }

        setMapReady(true)
      }

      handleMouseMove = (e: maplibregl.MapLayerMouseEvent) => {
        if (!map) {
          return
        }

        const hoverStateChange = threeDSceneRef.current.hoverAtPoint(e.point)
        if (hoverStateChange.changed()) {
          const canvas = map.getCanvas()
          if (hoverStateChange.selected()) {
            canvas.style.cursor = 'pointer'
          } else if (hoverStateChange.deselected()) {
            canvas.style.cursor = ''
          }
          map.triggerRepaint()
        }
      }

      handleClick = (e: maplibregl.MapLayerMouseEvent) => {
        if (!map) {
          return
        }

        const selectionStateChange = threeDSceneRef.current.selectAtPoint(e.point)
        if (selectionStateChange.changed()) {
          if (selectionStateChange.after?.mesh?.userData) {
            const sectorData = selectionStateChange.after.mesh.userData as SectorData
            console.log('Selected sector:', sectorData.sector_name, sectorData)
            setClickedSectorData(sectorData)

            const token = authTokenRef.current
            if (token && sectorData.sector_name) {
              void fetchSectorMetadata(token, sectorData.sector_name).then((metadata: any) => {
                if (metadata && metadata.current_tilt !== undefined) {
                  void fetchSectorStyle(token, sectorData.sector_name, metadata.current_tilt, 'RSRP')
                }
              })
            }
          }
          map.triggerRepaint()
        }
      }

      handleMoveEnd = () => {
        if (!map) {
          return
        }

        let updateFromTerrain = false
        if (terrainChangedRef.current) {
          terrainChangedRef.current = false
          updateFromTerrain = threeDSceneRef.current.updateAfterTerrainChange()
        }

        const currentZoom = map.getZoom()
        const minZoom = threeDSceneRef.current.minZoom
        console.log(`[3D Sectors] Zoom: ${currentZoom.toFixed(1)} (min required: ${minZoom})`)

        const updated = threeDSceneRef.current.updateAfterMove()
        if (updated || updateFromTerrain) {
          console.log('[3D Sectors] Scene updated after map move')
          map.triggerRepaint()
        } else if (currentZoom < minZoom) {
          console.log(`[3D Sectors] Zoom too low for 3D sectors (need ${minZoom}+)`)
        }
      }

      handleIdle = () => {
        if (!map) {
          return
        }

        let updated = false
        if (terrainChangedRef.current) {
          terrainChangedRef.current = false
          updated = threeDSceneRef.current.updateAfterTerrainChange()
        }

        if (updated) {
          map.triggerRepaint()
        }
      }

      map.on('load', handleLoad)
      map.on('mousemove', handleMouseMove)
      map.on('click', handleClick)
      map.on('moveend', handleMoveEnd)
      map.on('idle', handleIdle)

      if (disposed) {
        cleanupMap()
      }
    }

    void initializeMap()

    return () => {
      disposed = true
      cleanupMap()
    }
  }, [runtimeConfig?.initialView, styleUrl, pixelRatio, refreshToken])

  // Optimization drawing effect - keeps box visible on map until cleared
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current
    const sourceId = 'map-widget-optimization-draw-src'
    const fillLayerId = 'map-widget-optimization-draw-fill'
    const lineLayerId = 'map-widget-optimization-draw-line'

    // Helper to update the drawn feature
    const setDrawFeature = (bounds: BBoxBounds | null) => {
      const source = map.getSource(sourceId) as any
      if (!source) {
        return
      }

      if (!bounds) {
        source.setData({ type: 'FeatureCollection', features: [] })
        return
      }

      const ring = [
        [bounds.minLng, bounds.minLat],
        [bounds.maxLng, bounds.minLat],
        [bounds.maxLng, bounds.maxLat],
        [bounds.minLng, bounds.maxLat],
        [bounds.minLng, bounds.minLat]
      ]

      source.setData({
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [ring] },
            properties: {}
          }
        ]
      })
    }

    // Ensure source and layers exist
    if (!map.getSource(sourceId)) {
      map.addSource(sourceId, {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      } as any)
    }

    if (!map.getLayer(fillLayerId)) {
      map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: sourceId,
        paint: {
          'fill-color': '#00ff00',
          'fill-opacity': 0
        }
      } as any)
    }

    if (!map.getLayer(lineLayerId)) {
      map.addLayer({
        id: lineLayerId,
        type: 'line',
        source: sourceId,
        paint: {
          'line-color': '#00ff00',
          'line-width': 2
        }
      } as any)
    }

    optimizationDrawRef.current = { sourceId, fillLayerId, lineLayerId }

    // If we have bounds but not drawing, show the static box
    if (!optimizationDrawEnabled && optimizationBounds) {
      setDrawFeature(optimizationBounds)
      map.dragPan.enable()
      if (map.getCanvas()) {
        map.getCanvas().style.cursor = ''
      }
      return
    }

    // If not drawing and no bounds, clear the box
    if (!optimizationDrawEnabled && !optimizationBounds) {
      setDrawFeature(null)
      optimizationDrawingStateRef.current = null
      map.dragPan.enable()
      if (map.getCanvas()) {
        map.getCanvas().style.cursor = ''
      }
      return
    }

    // Drawing mode is active
    if (map.getCanvas()) {
      map.getCanvas().style.cursor = 'crosshair'
    }

    const onMouseDown = (e: any) => {
      if (!optimizationDrawEnabled) {
        return
      }

      e.preventDefault?.()
      setOptimizationStatus('drawing')
      setOptimizationError(null)

      optimizationDrawingStateRef.current = {
        active: true,
        startPoint: e.point,
        startLngLat: e.lngLat
      }
      map.dragPan.disable()
    }

    const onMouseMove = (e: any) => {
      const drawState = optimizationDrawingStateRef.current
      if (!drawState?.active) {
        return
      }

      const a = clampLngLat((drawState.startLngLat as any).lng, (drawState.startLngLat as any).lat)
      const b = clampLngLat(e.lngLat.lng, e.lngLat.lat)
      const bounds = normalizeBBox(a, b)
      setOptimizationBounds(bounds)
      optimizationBoundsRef.current = bounds
      setDrawFeature(bounds)
    }

    const onMouseUp = () => {
      const drawState = optimizationDrawingStateRef.current
      if (!drawState?.active) {
        return
      }

      optimizationDrawingStateRef.current = null
      map.dragPan.enable()
      const hasValidBounds = Boolean(optimizationBoundsRef.current)
      setOptimizationStatus(hasValidBounds ? 'ready' : 'idle')
      setOptimizationDrawEnabled(false)
      
      // Auto-generate unique session ID and job ID when drawing completes
      if (hasValidBounds) {
        setSessionId(generateUniqueId())
        setJobId(generateUniqueId())
        // Reset job status to idle for new optimization
        setOptimizationJobStatus('idle')
      }

      // Automatically fetch frequencies when drawing completes
      if (hasValidBounds && authTokenRef.current && optimizationBoundsRef.current) {
        void fetchOptimizationSectors(authTokenRef.current, optimizationBoundsRef.current)
      }
    }

    map.on('mousedown', onMouseDown)
    map.on('mousemove', onMouseMove)
    map.on('mouseup', onMouseUp)

    return () => {
      map.off('mousedown', onMouseDown)
      map.off('mousemove', onMouseMove)
      map.off('mouseup', onMouseUp)
      map.dragPan.enable()
      if (map.getCanvas()) {
        map.getCanvas().style.cursor = ''
      }
    }
  }, [mapReady, optimizationDrawEnabled, optimizationBounds, fetchOptimizationSectors])

  // Multi-bounding box visualization effect
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current

    // Clean up all result layers first
    optimizationResultsArray.forEach((result: OptimizationResult) => {
      const sourceId = `map-widget-optimization-result-${result.id}-src`
      const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
      const lineLayerId = `map-widget-optimization-result-${result.id}-line`

      if (map.getLayer(lineLayerId)) {
        map.removeLayer(lineLayerId)
      }
      if (map.getLayer(fillLayerId)) {
        map.removeLayer(fillLayerId)
      }
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId)
      }
    })

    // Re-add visible result layers
    optimizationResultsArray.forEach((result: OptimizationResult, index: number) => {
      if (!visibleBoundingBoxes.has(result.id)) {
        return
      }

      // Skip if bounds are all zeros (placeholder)
      if (result.bounds.minLng === 0 && result.bounds.minLat === 0 &&
          result.bounds.maxLng === 0 && result.bounds.maxLat === 0) {
        return
      }

      const sourceId = `map-widget-optimization-result-${result.id}-src`
      const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
      const lineLayerId = `map-widget-optimization-result-${result.id}-line`

      // Create GeoJSON feature
      const ring = [
        [result.bounds.minLng, result.bounds.minLat],
        [result.bounds.maxLng, result.bounds.minLat],
        [result.bounds.maxLng, result.bounds.maxLat],
        [result.bounds.minLng, result.bounds.maxLat],
        [result.bounds.minLng, result.bounds.minLat]
      ]

      // Add source
      map.addSource(sourceId, {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: [{
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [ring] },
            properties: { resultId: result.id }
          }]
        }
      } as any)

      // Add fill layer (transparent with tint)
      map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: sourceId,
        paint: {
          'fill-color': result.color,
          'fill-opacity': 0.05
        }
      } as any)

      // Add line layer (colored border, solid for active, dashed for inactive)
      const isActive = activeResultIndex === index
      map.addLayer({
        id: lineLayerId,
        type: 'line',
        source: sourceId,
        paint: {
          'line-color': result.color,
          'line-width': isActive ? 3 : 2,
          'line-dasharray': isActive ? [1] : [3, 3]
        }
      } as any)
    })

    return () => {
      // Cleanup on unmount
      optimizationResultsArray.forEach((result: OptimizationResult) => {
        const sourceId = `map-widget-optimization-result-${result.id}-src`
        const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
        const lineLayerId = `map-widget-optimization-result-${result.id}-line`

        if (map.getLayer(lineLayerId)) {
          map.removeLayer(lineLayerId)
        }
        if (map.getLayer(fillLayerId)) {
          map.removeLayer(fillLayerId)
        }
        if (map.getSource(sourceId)) {
          map.removeSource(sourceId)
        }
      })
    }
  }, [mapReady, optimizationResultsArray, visibleBoundingBoxes, activeResultIndex])

  // Auto-initialize visibility for new results
  React.useEffect(() => {
    setVisibleBoundingBoxes((prev: Set<string>) => {
      const newSet = new Set(prev)
      optimizationResultsArray.forEach((result: OptimizationResult) => {
        if (!newSet.has(result.id)) {
          newSet.add(result.id) // Show new boxes by default
        }
      })
      return newSet
    })
  }, [optimizationResultsArray])

  // Auto-zoom to bounding box when a result is activated
  React.useEffect(() => {
    if (!mapReady || !mapRef.current || activeResultIndex === null) {
      return
    }

    const activeResult = optimizationResultsArray[activeResultIndex]
    if (!activeResult || !activeResult.bounds) {
      return
    }

    const bounds = activeResult.bounds
    // Skip if bounds are placeholder (all zeros)
    if (bounds.minLng === 0 && bounds.minLat === 0 && bounds.maxLng === 0 && bounds.maxLat === 0) {
      return
    }

    const map = mapRef.current
    try {
      map.fitBounds(
        [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],
        {
          padding: 50,
          duration: 1000
        }
      )
    } catch (error) {
      console.error('[Auto-zoom] Failed to fit bounds:', error)
    }
  }, [mapReady, activeResultIndex, optimizationResultsArray])

  // Load result-specific parameters when switching between results
  React.useEffect(() => {
    if (activeResultIndex === null || !optimizationResultsArray[activeResultIndex]) {
      return
    }

    const activeResult = optimizationResultsArray[activeResultIndex]

    // Only load parameters for submitted results that have them stored
    if (activeResult.source === 'submitted') {
      // Load frequency/optimization sector
      if (activeResult.frequency !== undefined) {
        setSelectedOptimizationSector(activeResult.frequency)
      }

      // Load network type
      if (activeResult.networkType) {
        setSelectedNetworkType(activeResult.networkType)
      }

      // Load hyperparameters
      if (activeResult.hyperparameters) {
        setHyperparameters({ ...activeResult.hyperparameters })
      }

      // Load available frequencies
      if (activeResult.availableFrequencies) {
        setOptimizationSectors([...activeResult.availableFrequencies])
      }

      console.log('[Parameter Switch] Loaded parameters for result:', activeResult.id, {
        frequency: activeResult.frequency,
        networkType: activeResult.networkType
      })
    }
  }, [activeResultIndex, optimizationResultsArray])

  // Note: All optimization layers stay visible - we only move the camera when switching results
  // This effect is intentionally removed to keep all visualization layers visible

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    mapRef.current.easeTo({
      center: DEFAULT_CENTER,
      zoom: DEFAULT_ZOOM,
      bearing: DEFAULT_BEARING,
      pitch: DEFAULT_PITCH,
      duration: 600
    })
  }, [mapReady])

  const layersHash = React.useMemo(() => {
    return JSON.stringify(runtimeConfig?.layers ?? [])
  }, [runtimeConfig?.layers])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    if (!ENABLE_WIDGET_3D_BUILDINGS_LAYER) {
      return
    }

    const map = mapRef.current
    const layers = runtimeConfig?.layers ?? []
    const addLayers = () => {
      layers.forEach((layerConfig: LayerConfig) => {
        if (!layerConfig?.id || !layerConfig?.sourceId) {
          return
        }

        if (map.getLayer(layerConfig.id)) {
          map.removeLayer(layerConfig.id)
        }
        if (map.getSource(layerConfig.sourceId)) {
          map.removeSource(layerConfig.sourceId)
        }

        map.addSource(layerConfig.sourceId, layerConfig.source as any)
        map.addLayer({
          id: layerConfig.id,
          source: layerConfig.sourceId,
          ...layerConfig.layer
        } as LayerSpecification)

        if (layerConfig.visible === false) {
          map.setLayoutProperty(layerConfig.id, 'visibility', 'none')
        }
      })
    }

    addLayers()

    return () => {
      layers.forEach((layerConfig: LayerConfig) => {
        if (map.getLayer(layerConfig.id)) {
          map.removeLayer(layerConfig.id)
        }
        if (map.getSource(layerConfig.sourceId)) {
          map.removeSource(layerConfig.sourceId)
        }
      })
    }
  }, [mapReady, layersHash])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current

    const hidePoiLayers = () => {
      const style = map.getStyle()
      if (!style?.layers) {
        return
      }

      style.layers.forEach((layer: LayerSpecification) => {
        const layerId = layer.id
        if (!layerId || layer.type !== 'symbol') {
          return
        }

        const metadataGroup = (layer as any)?.metadata?.group
        const isPoiLayer = /poi/i.test(layerId) || (typeof metadataGroup === 'string' && /poi/i.test(metadataGroup))

        if (isPoiLayer && map.getLayer(layerId)) {
          map.setLayoutProperty(layerId, 'visibility', 'none')
        }
      })
    }

    hidePoiLayers()
    map.on('style.load', hidePoiLayers)

    return () => {
      map.off('style.load', hidePoiLayers)
    }
  }, [mapReady])



  React.useEffect(() => {
    if (!mapContainerRef.current) {
      return
    }

    const observer = new ResizeObserver(() => {
      mapRef.current?.resize()
    })

    observer.observe(mapContainerRef.current)

    return () => observer.disconnect()
  }, [])

  // 3D Sectors visibility and scale effect
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    console.log('[3D Sectors] Visibility:', show3DSectors, 'Scale:', sectorScale)
    const propChanges = threeDSceneRef.current.setLayerProps(ThreeD.LayerType.Sectors, {
      getSectorColor: getSectorColor,
      visible: show3DSectors,
      scale: sectorScale
    })
    const repaintableChange = threeDSceneRef.current.updateAfterPropsChanges(ThreeD.LayerType.Sectors, propChanges)
    if (repaintableChange) {
      console.log('[3D Sectors] Props changed, triggering repaint')
      mapRef.current.triggerRepaint()
    }
  }, [mapReady, show3DSectors, sectorScale, getSectorColor])

  return (
    <div className="maplibre-widget__map" ref={mapContainerRef} role="presentation">
      <style>
        {`
          @keyframes spinLoader {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          @keyframes progressSlide {
            0%   { left: -50%; }
            100% { left: 110%; }
          }
        `}
      </style>
      {(optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling' || optimizationJobStatus === 'error') && (
        <div style={{
          position: 'absolute',
          top: 12,
          left: '50%',
          transform: 'translateX(-50%)',
          zIndex: 10,
          background: optimizationJobStatus === 'error' ? 'rgba(30,12,12,0.94)' : 'rgba(12,18,28,0.94)',
          color: '#fff',
          borderRadius: 8,
          border: `1px solid ${optimizationJobStatus === 'error' ? 'rgba(239,83,80,0.35)' : 'rgba(79,195,247,0.18)'}`,
          boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
          maxWidth: 520,
          minWidth: 280,
          overflow: 'hidden'
        }}>
          {/* Thin animated progress bar */}
          <div style={{ height: 3, background: 'rgba(255,255,255,0.04)', position: 'relative', overflow: 'hidden' }}>
            {optimizationJobStatus !== 'error' && (
              <div style={{
                position: 'absolute',
                top: 0,
                height: '100%',
                width: '35%',
                background: 'linear-gradient(90deg, transparent 0%, #4fc3f7 50%, transparent 100%)',
                animation: 'progressSlide 1.4s cubic-bezier(0.4,0,0.2,1) infinite'
              }} />
            )}
            {optimizationJobStatus === 'error' && (
              <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', background: '#ef5350' }} />
            )}
          </div>
          {/* Content row */}
          <div style={{ padding: '8px 14px', display: 'flex', alignItems: 'center', gap: 10 }}>
            {optimizationJobStatus !== 'error' && (
              <div style={{
                width: 14,
                height: 14,
                border: '2px solid rgba(79,195,247,0.2)',
                borderTop: '2px solid #4fc3f7',
                borderRadius: '50%',
                flexShrink: 0,
                animation: 'spinLoader 0.8s linear infinite'
              }} />
            )}
            {optimizationJobStatus === 'error' && (
              <div style={{
                width: 14,
                height: 14,
                borderRadius: '50%',
                background: '#ef5350',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                flexShrink: 0,
                fontSize: 8,
                fontWeight: 700
              }}>✕</div>
            )}
            <div style={{
              flex: 1,
              minWidth: 0,
              fontSize: 11,
              lineHeight: 1.4,
              color: 'rgba(255,255,255,0.88)',
              wordBreak: 'break-word'
            }}>
              {statusMessage || (optimizationJobStatus === 'error' ? (optimizationJobError || 'An error occurred') : 'Processing...')}
            </div>
          </div>
        </div>
      )}
      
      {/* Top Control Bar - Layer Controls & bird */}
      <div style={{
        position: 'absolute',
        top: 8,
        left: 8,
        zIndex: 2,
        display: 'flex',
        gap: 10,
        alignItems: 'center'
      }}>
        {/* Layer Control Button */}
        <button
          type="button"
          onClick={() => setShowLayerControls(!showLayerControls)}
          style={{
            padding: '10px 18px',
            borderRadius: 6,
            border: '2px solid rgba(255,255,255,0.4)',
            background: showLayerControls ? 'rgba(0,0,0,0.85)' : 'rgba(0,0,0,0.65)',
            color: '#fff',
            cursor: 'pointer',
            fontSize: 13,
            fontWeight: '600',
            transition: 'all 0.2s',
            boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            display: 'flex',
            alignItems: 'center',
            gap: 8
          }}
          title={showLayerControls ? 'Hide Layer Controls' : 'Show Layer Controls'}
        >
          <span style={{ fontSize: 16 }}>☰</span>
          <span>Layers</span>
        </button>

        {/* bird Button with integrated toggle */}
        <button
          type="button"
          onClick={() => setShowOptimizationSection(!showOptimizationSection)}
          style={{
            padding: '8px 12px 8px 16px',
            borderRadius: 8,
            border: showOptimizationSection 
              ? '2px solid rgba(100, 200, 255, 0.8)' 
              : '2px solid rgba(33, 150, 243, 0.5)',
            background: showOptimizationSection 
              ? 'linear-gradient(135deg, rgba(33, 150, 243, 0.95) 0%, rgba(21, 101, 192, 0.95) 100%)'
              : 'linear-gradient(135deg, rgba(33, 150, 243, 0.75) 0%, rgba(21, 101, 192, 0.75) 100%)',
            cursor: 'pointer',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            boxShadow: showOptimizationSection
              ? '0 4px 16px rgba(33, 150, 243, 0.6), 0 2px 8px rgba(0, 0, 0, 0.4)'
              : '0 2px 12px rgba(33, 150, 243, 0.4), 0 1px 4px rgba(0, 0, 0, 0.3)',
            display: 'flex',
            alignItems: 'center',
            gap: 8,
            fontSize: 13,
            fontWeight: '600',
            color: '#fff',
            position: 'relative',
            textShadow: '0 1px 2px rgba(0, 0, 0, 0.3)'
          }}
          onMouseEnter={(e) => {
            e.currentTarget.style.transform = 'translateY(-1px)';
            e.currentTarget.style.boxShadow = showOptimizationSection
              ? '0 6px 20px rgba(33, 150, 243, 0.7), 0 3px 10px rgba(0, 0, 0, 0.4)'
              : '0 4px 16px rgba(33, 150, 243, 0.5), 0 2px 6px rgba(0, 0, 0, 0.3)';
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.transform = 'translateY(0)';
            e.currentTarget.style.boxShadow = showOptimizationSection
              ? '0 4px 16px rgba(33, 150, 243, 0.6), 0 2px 8px rgba(0, 0, 0, 0.4)'
              : '0 2px 12px rgba(33, 150, 243, 0.4), 0 1px 4px rgba(0, 0, 0, 0.3)';
          }}
          title={showOptimizationSection ? 'Disable bird Mode' : 'Enable bird Mode'}
        >
          <img 
            src={logoImage} 
            alt="bird" 
            style={{ 
              width: 40,
              height: 40,
              objectFit: 'contain',
              filter: showOptimizationSection 
                ? 'brightness(1.1) drop-shadow(0 0 3px rgba(255, 255, 255, 0.5))' 
                : 'brightness(1) drop-shadow(0 0 2px rgba(255, 255, 255, 0.3))',
              margin: '-9px 0'
            }} 
          />
          <span>bird Optimization</span>
          
          {/* Compact Toggle Switch */}
          <div 
            style={{
              position: 'relative',
              width: 36,
              height: 18,
              background: showOptimizationSection ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.2)',
              borderRadius: 9,
              transition: 'all 0.3s',
              border: '1px solid rgba(255,255,255,0.4)',
              marginLeft: 2,
              flexShrink: 0
            }}
          >
            <div style={{
              position: 'absolute',
              top: 2,
              left: showOptimizationSection ? 18 : 2,
              width: 12,
              height: 12,
              background: '#fff',
              borderRadius: '50%',
              transition: 'all 0.3s',
              boxShadow: '0 1px 3px rgba(0, 0, 0, 0.3)'
            }} />
          </div>
        </button>
      </div>

      {/* User Badge - Top Right */}
      {portalUser && (
        <div style={{
          position: 'absolute',
          top: 8,
          right: 8,
          zIndex: 2,
          display: 'flex',
          alignItems: 'center',
          gap: 6,
          background: 'rgba(0,0,0,0.7)',
          color: '#fff',
          padding: '6px 12px',
          borderRadius: 20,
          fontSize: 12,
          fontWeight: 500,
          boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
          border: '1px solid rgba(255,255,255,0.15)'
        }}>
          <span style={{ fontSize: 14 }}>&#x1F464;</span>
          <span>{portalUser.fullName}</span>
          {isOptoUser && (
            <span style={{
              background: 'rgba(76,175,80,0.25)',
              color: '#81c784',
              fontSize: 10,
              fontWeight: 600,
              padding: '2px 6px',
              borderRadius: 10,
              border: '1px solid rgba(76,175,80,0.4)',
              marginLeft: 2
            }}>OptoUser</span>
          )}
        </div>
      )}

      {/* Layer Controls Sidebar */}
      {showLayerControls && (
      <div style={{ position: 'absolute', top: 58, left: 8, zIndex: 1, background: 'rgba(0,0,0,0.75)', color: '#fff', padding: '10px 12px', borderRadius: 6, fontSize: 11, lineHeight: 1.4, boxShadow: '0 2px 8px rgba(0,0,0,0.3)', width: 320 }}>
        <div style={{ marginBottom: 10 }}>
          <label style={{ display: 'flex', alignItems: 'center', marginBottom: coverageVisible ? 6 : 0, cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={coverageVisible}
              onChange={(e) => setCoverageVisible(e.target.checked)}
              style={{ marginRight: 6 }}
            />
            <span style={{ fontSize: 11 }}>Coverage Layer</span>
          </label>
          {coverageVisible && (
            <>
              <select
                value={coverageLayer}
                onChange={(e) => setCoverageLayer(e.target.value as CoverageLayer)}
                style={{ width: '100%', padding: '4px 6px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer', marginBottom: 6 }}
              >
                {COVERAGE_LAYER_OPTIONS.map((opt) => (
                  <option key={opt.value} value={opt.value}>
                    {opt.label}
                  </option>
                ))}
              </select>
              <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                <strong style={{ fontSize: 10, minWidth: 45 }}>Opacity</strong>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={coverageOpacity}
                  onChange={(e) => setCoverageOpacity(Number(e.target.value))}
                  style={{ flex: 1, cursor: 'pointer', height: 4 }}
                />
                <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{coverageOpacity}%</span>
              </div>
              
              {/* Display hovered abcribute for usid_poly and sector_id_poly layers */}
              {(coverageLayer === 'usid_poly' || coverageLayer === 'sector_id_poly') && (
                <div style={{ marginTop: 6, paddingTop: 6, borderTop: '1px solid rgba(255,255,255,0.1)', fontSize: 9, display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ opacity: 0.7 }}>
                    {coverageLayer === 'usid_poly' ? 'USID' : 'SECTOR ID'}:
                  </span>
                  <span style={{ 
                    fontSize: 11,
                    fontWeight: 'bold', 
                    color: hoveredCoverageabcribute ? '#4CAF50' : '#888',
                    fontFamily: 'monospace'
                  }}>
                    {hoveredCoverageabcribute || 'None'}
                  </span>
                </div>
              )}
            </>
          )}
        </div>

        <div style={{ marginBottom: 10, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
          <label style={{ display: 'flex', alignItems: 'center', marginBottom: show3DSectors ? 6 : 0, cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={show3DSectors}
              onChange={(e) => setShow3DSectors(e.target.checked)}
              style={{ marginRight: 6 }}
            />
            <span style={{ fontSize: 11 }}>3D Sectors</span>
          </label>
          {show3DSectors && (
            <div style={{ display: 'flex', alignItems: 'center', gap: 6, paddingLeft: 22 }}>
              <label style={{ fontSize: 10, minWidth: 45 }}>Scale:</label>
              <input
                type="range"
                min="0.5"
                max="3"
                step="0.1"
                value={sectorScale}
                onChange={(e) => setSectorScale(parseFloat(e.target.value))}
                style={{ flex: 1, cursor: 'pointer', height: 4 }}
              />
              <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{sectorScale.toFixed(1)}x</span>
            </div>
          )}
        </div>

        <div style={{ marginBottom: 10, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
          <label style={{ display: 'flex', alignItems: 'center', marginBottom: iqiVisible ? 6 : 0, cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={iqiVisible}
              onChange={(e) => setIqiVisible(e.target.checked)}
              style={{ marginRight: 6 }}
            />
            <span style={{ fontSize: 11 }}>IQI Layer</span>
          </label>
          {iqiVisible && (
            <>
              <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 6 }}>
                <strong style={{ fontSize: 10, minWidth: 45 }}>Opacity</strong>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={iqiOpacity}
                  onChange={(e) => setIqiOpacity(Number(e.target.value))}
                  style={{ flex: 1, cursor: 'pointer', height: 4 }}
                />
                <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{iqiOpacity}%</span>
              </div>
              {iqiStatus === 'loading-token' && (
                <div style={{ fontSize: 10, color: '#80deea', paddingLeft: 22 }}>Getting token...</div>
              )}
              {iqiStatus === 'loading-data' && (
                <div style={{ fontSize: 10, color: '#80deea', paddingLeft: 22 }}>Loading features...</div>
              )}
              {iqiStatus === 'success' && iqiFeatureCount > 0 && !iqiError && (
                <div style={{ fontSize: 10, color: '#4caf50', paddingLeft: 22 }}>✓ {iqiFeatureCount.toLocaleString()} features loaded</div>
              )}
              {iqiStatus === 'success' && iqiError && (
                <div style={{ fontSize: 10, color: '#ff9800', paddingLeft: 22 }}>⚠ {iqiError}</div>
              )}
              {iqiStatus === 'error' && iqiError && (
                <div style={{ fontSize: 10, color: '#f44336', paddingLeft: 22 }}>{iqiError}</div>
              )}
              {iqiStatus === 'idle' && iqiError && (
                <div style={{ fontSize: 10, color: '#ff9800', paddingLeft: 22 }}>{iqiError}</div>
              )}
            </>
          )}
        </div>

        <div style={{ display: 'flex', flexDirection: 'column', gap: 6, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
          <button
            type="button"
            onClick={() => setShowApiControls(!showApiControls)}
            style={{ padding: '6px 10px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.35)', background: showApiControls ? 'rgba(0,150,255,0.3)' : 'rgba(255,255,255,0.1)', color: '#fff', cursor: 'pointer', fontSize: 12, fontWeight: 500, transition: 'all 0.2s' }}
            aria-expanded={showApiControls}
          >
            {showApiControls ? '▼ ' : '▶ '}Map Layers
          </button>
        </div>

        {showApiControls && (
          <div style={{ marginTop: 8, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
            <div style={{ marginBottom: 8 }}>
              <strong style={{ fontSize: 12 }}>Additional Map Layers</strong>
            </div>

            <div style={{ marginBottom: 8 }}>
              <div style={{ fontSize: 10, opacity: 0.8, marginBottom: 4 }}>Basemap Style Layers</div>
              <div style={{ display: 'grid', gap: 4, maxHeight: 180, overflow: 'auto' }}>
                {basemapLayers.map((layer: BasemapLayerEntry) => (
                  <label key={layer.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 10, padding: '4px 8px', borderRadius: 4, background: 'rgba(0,0,0,0.3)', cursor: 'pointer', transition: 'all 0.2s' }}>
                    <span style={{ fontSize: 11, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }} title={layer.id}>
                      {layer.label}
                    </span>
                    <input
                      type="checkbox"
                      checked={basemapLayerVisibility[layer.id] ?? true}
                      onChange={() => {
                        const nextEnabled = !(basemapLayerVisibility[layer.id] ?? true)
                        setBasemapLayerVisibility((prev: Record<string, boolean>) => ({
                          ...prev,
                          [layer.id]: nextEnabled
                        }))
                        setBasemapLayerVisible(layer.id, nextEnabled)
                      }}
                      style={{ cursor: 'pointer', width: 16, height: 16 }}
                    />
                  </label>
                ))}
              </div>
            </div>

            <div style={{ fontSize: 10, opacity: 0.8, marginBottom: 4 }}>API Overlays</div>

            <div style={{ display: 'grid', gap: 4, maxHeight: 180, overflow: 'auto' }}>
              {(Object.entries(apiVisibility) as Array<[string, ApiVisibilityEntry]>)
                .filter(([key]) => key !== 'bbox' && key !== 'coverage' && key !== 'sector' && !key.startsWith('optimization-layer'))
                .sort((a, b) => String(a[1]?.label ?? a[0]).localeCompare(String(b[1]?.label ?? b[0])))
                .map(([key, entry]: [string, ApiVisibilityEntry]) => (
                  <label key={key} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 10, padding: '4px 8px', borderRadius: 4, background: 'rgba(0,0,0,0.3)', cursor: 'pointer', transition: 'all 0.2s' }}>
                    <span style={{ fontSize: 11, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{entry?.label ?? key}</span>
                    <input
                      type="checkbox"
                      checked={entry?.enabled ?? true}
                      onChange={() => {
                        const currentlyEnabled = Boolean(entry?.enabled)

                        setApiVisibility((prev: Record<string, ApiVisibilityEntry>) => {
                          const current = prev[key]
                          const enabled = !(current?.enabled ?? true)
                          return {
                            ...prev,
                            [key]: {
                              label: current?.label ?? defaultApiLabel(key),
                              enabled
                            }
                          }
                        })

                        if (currentlyEnabled) {
                          clearOverlay(key)
                        }
                      }}
                      style={{ cursor: 'pointer', width: 16, height: 16 }}
                    />
                  </label>
                ))}
            </div>
          </div>
        )}
      </div>
      )}

      {/* Sector View Panel - Bottom Left of Loaded Results */}
      {clickedSectorData && (
        <div style={{
          position: 'absolute',
          bottom: 8,
          left: 'max(8px, calc(50% - 440px))',
          zIndex: 1000,
          background: 'linear-gradient(135deg, rgba(30,30,35,0.98) 0%, rgba(45,45,50,0.98) 100%)',
          border: '1px solid rgba(100,200,100,0.4)',
          borderRadius: 6,
          boxShadow: '0 8px 32px rgba(0,0,0,0.5), 0 2px 8px rgba(100,200,100,0.2)',
          minWidth: 240,
          maxWidth: 280
        }}>
          {/* Header Bar */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '6px 10px',
            borderBottom: sectorPanelExpanded ? '1px solid rgba(100,200,100,0.2)' : 'none',
            background: 'linear-gradient(90deg, rgba(0,150,80,0.15) 0%, rgba(0,100,50,0.1) 100%)'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
              <div style={{
                width: 6,
                height: 6,
                borderRadius: '50%',
                background: sectorStyleStatus === 'success' ? '#4ade80' : sectorStyleStatus === 'loading' ? '#60a5fa' : sectorStyleStatus === 'error' ? '#f87171' : '#94a3b8',
                boxShadow: sectorStyleStatus === 'success' ? '0 0 6px rgba(74,222,128,0.6)' : sectorStyleStatus === 'loading' ? '0 0 6px rgba(96,165,250,0.6)' : 'none'
              }} />
              <strong style={{ 
                fontSize: 11, 
                color: '#e2e8f0',
                letterSpacing: '0.2px',
                fontWeight: 600
              }}>Sector Analysis</strong>
            </div>
            <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
              <button
                onClick={() => setSectorPanelExpanded(!sectorPanelExpanded)}
                style={{
                  background: 'rgba(255,255,255,0.08)',
                  border: '1px solid rgba(255,255,255,0.15)',
                  color: '#cbd5e1',
                  width: 20,
                  height: 20,
                  borderRadius: 3,
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 11,
                  fontWeight: 'bold',
                  padding: 0
                }}
                title={sectorPanelExpanded ? 'Collapse' : 'Expand'}
              >
                {sectorPanelExpanded ? '−' : '+'}
              </button>
              <button
                onClick={clearSectorView}
                style={{
                  background: 'rgba(239,68,68,0.15)',
                  border: '1px solid rgba(239,68,68,0.3)',
                  color: '#fca5a5',
                  width: 20,
                  height: 20,
                  borderRadius: 3,
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 14,
                  fontWeight: 'bold',
                  lineHeight: 1,
                  padding: 0
                }}
                title="Close sector view"
              >
                ×
              </button>
            </div>
          </div>

          {/* Panel Content */}
          {sectorPanelExpanded && (
            <div style={{ padding: '8px 10px' }}>
              {/* Compact Info Display */}
              <div style={{ fontSize: 9, color: '#cbd5e1', lineHeight: 1.6, marginBottom: 6 }}>
                <div><span style={{ color: '#94a3b8' }}>Sector:</span> <span style={{ color: '#e2e8f0', fontWeight: 500 }}>{clickedSectorData.sector_name}</span></div>
                {sectorMetadata && <div><span style={{ color: '#94a3b8' }}>USID:</span> <span style={{ color: '#e2e8f0', fontWeight: 500 }}>{sectorMetadata.usid || 'N/A'}</span></div>}
                <div><span style={{ color: '#94a3b8' }}>Site:</span> <span style={{ color: '#e2e8f0' }}>{clickedSectorData.site_name}</span> | <span style={{ color: '#94a3b8' }}>Band:</span> <span style={{ color: '#e2e8f0' }}>{clickedSectorData.band}</span></div>
                <div><span style={{ color: '#94a3b8' }}>Tech:</span> <span style={{ color: '#e2e8f0' }}>{clickedSectorData.technology}</span> | <span style={{ color: '#94a3b8' }}>Az:</span> <span style={{ color: '#e2e8f0' }}>{clickedSectorData.azimuth}°</span></div>
              </div>

              {/* Metadata Status */}
              {sectorMetadataStatus === 'loading' && (
                <div style={{ padding: '4px', background: 'rgba(59,130,246,0.1)', border: '1px solid rgba(59,130,246,0.3)', borderRadius: 3, color: '#93c5fd', fontSize: 7, textAlign: 'center', marginBottom: 6 }}>
                  Loading metadata...
                </div>
              )}
              {sectorMetadataStatus === 'error' && (
                <div style={{ padding: '4px', background: 'rgba(239,68,68,0.1)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: 3, color: '#fca5a5', fontSize: 7, textAlign: 'center', marginBottom: 6 }}>
                  Metadata Error
                </div>
              )}

              {/* Metadata Info - Compact */}
              {sectorMetadata && sectorMetadataStatus === 'success' && (
                <>
                  <div style={{ fontSize: 9, color: '#cbd5e1', lineHeight: 1.6, padding: '6px', background: 'rgba(0,150,80,0.08)', borderRadius: 4, border: '1px solid rgba(100,200,100,0.15)', marginBottom: 6 }}>
                    <div><span style={{ color: '#94a3b8' }}>Antenna:</span> <span style={{ color: '#a7f3d0', fontWeight: 500 }}>{sectorMetadata.antenna_family || 'N/A'}</span></div>
                    <div><span style={{ color: '#94a3b8' }}>Height:</span> <span style={{ color: '#a7f3d0' }}>{sectorMetadata.sector_height_meters ? `${sectorMetadata.sector_height_meters.toFixed(2)}m` : 'N/A'}</span> | <span style={{ color: '#94a3b8' }}>Beam:</span> <span style={{ color: '#a7f3d0' }}>{sectorMetadata.beamwidth || 'N/A'}°</span></div>
                    <div><span style={{ color: '#94a3b8' }}>Min Tilt:</span> <span style={{ color: '#a7f3d0' }}>{sectorMetadata.min_tilt !== undefined ? `${sectorMetadata.min_tilt}°` : 'N/A'}</span> | <span style={{ color: '#94a3b8' }}>Max Tilt:</span> <span style={{ color: '#a7f3d0' }}>{sectorMetadata.max_tilt !== undefined ? `${sectorMetadata.max_tilt}°` : 'N/A'}</span></div>
                  </div>

                  {/* Tilt Dropdown - Compact */}
                  {sectorMetadata.min_tilt !== undefined && sectorMetadata.max_tilt !== undefined && (
                    <div style={{ marginBottom: 6 }}>
                      <label style={{ display: 'block', marginBottom: 3, fontSize: 8, color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '0.3px', fontWeight: 600 }}>
                        Tilt Angle - <span style={{ color: '#a7f3d0', fontWeight: 500, textTransform: 'none' }}>Current Tilt: {sectorMetadata.current_tilt || 'N/A'}°</span>
                      </label>
                      <select
                        value={selectedSectorTilt || sectorMetadata.current_tilt}
                        onChange={(e) => {
                          const newTilt = Number(e.target.value)
                          setSelectedSectorTilt(newTilt)
                          const token = authTokenRef.current
                          if (token && clickedSectorData.sector_name) {
                            void fetchSectorStyle(token, clickedSectorData.sector_name, newTilt, sectorCoverageType)
                          }
                        }}
                        style={{
                          width: '100%',
                          padding: '4px 6px',
                          fontSize: '9px',
                          background: 'rgba(30,30,35,0.8)',
                          border: '1px solid rgba(100,200,100,0.3)',
                          color: '#e2e8f0',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          outline: 'none'
                        }}
                      >
                        {Array.from(
                          { length: sectorMetadata.max_tilt - sectorMetadata.min_tilt + 1 },
                          (_, i) => sectorMetadata.min_tilt + i
                        ).map(tilt => (
                          <option key={tilt} value={tilt} style={{ background: '#1e1e23', color: '#e2e8f0' }}>
                            {tilt}°
                          </option>
                        ))}
                      </select>
                    </div>
                  )}

                  {/* Coverage Type - Compact */}
                  <div>
                    <label style={{ display: 'block', marginBottom: 3, fontSize: 8, color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '0.3px', fontWeight: 600 }}>
                      Coverage Type
                    </label>
                    <div style={{ display: 'flex', gap: 6 }}>
                      <label style={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 4, 
                        cursor: 'pointer',
                        padding: '4px 8px',
                        background: sectorCoverageType === 'RSRP' ? 'rgba(0,150,80,0.2)' : 'rgba(255,255,255,0.05)',
                        border: `1px solid ${sectorCoverageType === 'RSRP' ? 'rgba(100,200,100,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: 4,
                        flex: 1,
                        justifyContent: 'center'
                      }}>
                        <input
                          type="radio"
                          checked={sectorCoverageType === 'RSRP'}
                          onChange={() => {
                            setSectorCoverageType('RSRP')
                            const token = authTokenRef.current
                            if (token && clickedSectorData.sector_name && selectedSectorTilt !== null) {
                              void fetchSectorStyle(token, clickedSectorData.sector_name, selectedSectorTilt, 'RSRP')
                            }
                          }}
                          style={{ cursor: 'pointer', accentColor: '#10b981', width: 10, height: 10, margin: 0 }}
                        />
                        <span style={{ fontSize: 9, color: sectorCoverageType === 'RSRP' ? '#a7f3d0' : '#cbd5e1', fontWeight: 500 }}>RSRP</span>
                      </label>
                      <label style={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 4, 
                        cursor: 'pointer',
                        padding: '4px 8px',
                        background: sectorCoverageType === 'los_poly' ? 'rgba(0,150,80,0.2)' : 'rgba(255,255,255,0.05)',
                        border: `1px solid ${sectorCoverageType === 'los_poly' ? 'rgba(100,200,100,0.4)' : 'rgba(255,255,255,0.1)'}`,
                        borderRadius: 4,
                        flex: 1,
                        justifyContent: 'center'
                      }}>
                        <input
                          type="radio"
                          checked={sectorCoverageType === 'los_poly'}
                          onChange={() => {
                            setSectorCoverageType('los_poly')
                            const token = authTokenRef.current
                            if (token && clickedSectorData.sector_name && selectedSectorTilt !== null) {
                              void fetchSectorStyle(token, clickedSectorData.sector_name, selectedSectorTilt, 'los_poly')
                            }
                          }}
                          style={{ cursor: 'pointer', accentColor: '#10b981', width: 10, height: 10, margin: 0 }}
                        />
                        <span style={{ fontSize: 9, color: sectorCoverageType === 'los_poly' ? '#a7f3d0' : '#cbd5e1', fontWeight: 500 }}>LOS</span>
                      </label>
                    </div>
                  </div>
                </>
              )}

              {/* Coverage Status - Compact */}
              {sectorStyleStatus === 'loading' && (
                <div style={{ marginTop: 6, padding: '3px', background: 'rgba(59,130,246,0.1)', border: '1px solid rgba(59,130,246,0.3)', borderRadius: 3, color: '#93c5fd', fontSize: 7, textAlign: 'center' }}>
                  Loading...
                </div>
              )}
              {sectorStyleStatus === 'error' && (
                <div style={{ marginTop: 6, padding: '3px', background: 'rgba(239,68,68,0.1)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: 3, color: '#fca5a5', fontSize: 7, textAlign: 'center' }}>
                  Error
                </div>
              )}
              {sectorStyleStatus === 'success' && (
                <div style={{ marginTop: 6, padding: '3px', background: 'rgba(34,197,94,0.1)', border: '1px solid rgba(34,197,94,0.3)', borderRadius: 3, color: '#86efac', fontSize: 7, textAlign: 'center' }}>
                  ✓ Loaded
                </div>
              )}
            </div>
          )}
        </div>
      )}

      {/* bird Optimization Section - Left Panel Below Layer Controls */}
      {showOptimizationSection && (
        <div style={{ 
          position: 'absolute', 
          top: showLayerControls ? 345 : 60,
          left: 8,
          zIndex: 998, 
          background: 'rgba(0,40,80,0.95)', 
          border: '2px solid rgba(33,150,243,0.6)',
          color: '#fff', 
          padding: '6px 12px 10px', 
          borderRadius: 6, 
          fontSize: 11, 
          lineHeight: 1.4, 
          boxShadow: '0 4px 16px rgba(0,0,0,0.5)', 
          width: 316,
          maxHeight: showLayerControls ? 'calc(100vh - 365px)' : 'calc(100vh - 76px)',
          overflowY: 'auto'
        }}>
            <div style={{ 
              marginBottom: 6, 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'space-between'
            }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                <img src={logoImage} alt="bird" style={{ width: 40, height: 40, objectFit: 'contain' }} />
                <strong style={{ fontSize: 12 }}>bird Optimization</strong>
              </div>
              <button
                type="button"
                onClick={() => setShowOptimizationSection(false)}
                style={{
                  background: 'rgba(255,255,255,0.1)',
                  border: '1px solid rgba(255,255,255,0.3)',
                  color: '#fff',
                  width: 20,
                  height: 20,
                  borderRadius: 3,
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 14,
                  fontWeight: 'bold',
                  lineHeight: 1,
                  padding: 0
                }}
                title="Close bird Optimization"
              >
                ×
              </button>
            </div>

            <div style={{ height: 1, background: 'rgba(255,255,255,0.18)', margin: '4px 0 6px' }} />

            <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
              <div style={{ fontSize: 10, color: '#fff', opacity: 0.85, lineHeight: 1.3 }}>
                Start a new optimization request or recall an existing one. Select an option to proceed. Maximum of 4 total results allowed.
              </div>
              <div style={{ height: 1, background: 'rgba(255,255,255,0.12)', margin: '0 0 4px' }} />
              {/* Always show options to add new optimizations */}
              <div style={{ display: 'flex', gap: 6 }}>
                <button
                  type="button"
                  onClick={() => setOptimizationDrawEnabled(true)}
                  disabled={optimizationResultsArray.length >= 4}
                  style={{
                    flex: 1,
                    padding: '6px 8px',
                    borderRadius: 4,
                    border: '1px solid rgba(255,255,255,0.35)',
                    background: optimizationResultsArray.length >= 4 ? 'rgba(100,100,100,0.2)' : (optimizationDrawEnabled ? 'rgba(0,255,0,0.4)' : 'rgba(64,156,255,0.4)'),
                    color: '#fff',
                    cursor: optimizationResultsArray.length >= 4 ? 'not-allowed' : 'pointer',
                    fontWeight: 500,
                    fontSize: 11,
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    gap: 4,
                    justifyContent: 'center',
                    opacity: optimizationResultsArray.length >= 4 ? 0.5 : 1
                  }}
                  title={optimizationResultsArray.length >= 4 ? 'Maximum 4 optimizations reached' : 'Draw new optimization area'}
                >
                  <span>📐</span>
                  <span>{optimizationDrawEnabled ? 'Drawing...' : 'New Request'}</span>
                </button>

                <button
                  type="button"
                  onClick={() => setRecallFormVisible(!recallFormVisible)}
                  disabled={optimizationResultsArray.length >= 4}
                  style={{
                    flex: 1,
                    padding: '6px 8px',
                    borderRadius: 4,
                    border: '1px solid rgba(255,255,255,0.35)',
                    background: optimizationResultsArray.length >= 4 ? 'rgba(100,100,100,0.2)' : (recallFormVisible ? 'rgba(33,150,243,0.5)' : 'rgba(33,150,243,0.3)'),
                    color: '#fff',
                    cursor: optimizationResultsArray.length >= 4 ? 'not-allowed' : 'pointer',
                    fontWeight: 500,
                    fontSize: 11,
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    gap: 4,
                    justifyContent: 'center',
                    opacity: optimizationResultsArray.length >= 4 ? 0.5 : 1
                  }}
                  title={optimizationResultsArray.length >= 4 ? 'Maximum 4 optimizations reached' : 'Recall existing optimization'}
                >
                  <span>🔍</span>
                  <span>Recall</span>
                </button>
              </div>

              {/* Show message when at limit */}
              {optimizationResultsArray.length >= 4 && (
                <div style={{
                  padding: '6px 8px',
                  background: 'rgba(255,165,0,0.2)',
                  border: '1px solid rgba(255,165,0,0.4)',
                  borderRadius: 3,
                  fontSize: 10,
                  color: '#ffcc80',
                  textAlign: 'center'
                }}>
                  Maximum 4 optimizations reached. Remove one to add another.
                </div>
              )}

              {recallFormVisible && (
                <div style={{
                  background: 'rgba(33,150,243,0.15)',
                  border: '1px solid rgba(33,150,243,0.4)',
                  borderRadius: 4,
                  padding: 8
                }}>
                  <div style={{ fontSize: 10, fontWeight: 'bold', marginBottom: 6, color: '#64B5F6' }}>
                    Recall Optimization Results
                  </div>
                  <div style={{ marginBottom: 8 }}>
                    <label style={{ fontSize: 9, display: 'block', marginBottom: 3 }}>Session ID:</label>
                    <input
                      type="text"
                      value={recallForm.sessionId}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setRecallForm((prev: RecallFormState) => ({ ...prev, sessionId: e.target.value }))}
                      placeholder="Enter session ID"
                      style={{
                        width: '100%',
                        padding: '5px 7px',
                        fontSize: 10,
                        borderRadius: 3,
                        border: '1px solid rgba(255,255,255,0.35)',
                        background: 'rgba(0,0,0,0.7)',
                        color: '#fff'
                      }}
                    />
                  </div>

                  <div style={{ marginBottom: 8 }}>
                    <label style={{ fontSize: 9, display: 'block', marginBottom: 3 }}>Job ID:</label>
                    <input
                      type="text"
                      value={recallForm.jobId}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setRecallForm((prev: RecallFormState) => ({ ...prev, jobId: e.target.value }))}
                      placeholder="Enter job ID"
                      style={{
                        width: '100%',
                        padding: '5px 7px',
                        fontSize: 10,
                        borderRadius: 3,
                        border: '1px solid rgba(255,255,255,0.35)',
                        background: 'rgba(0,0,0,0.7)',
                        color: '#fff'
                      }}
                    />
                  </div>

                  {recallForm.error && (
                    <div style={{
                      marginBottom: 8,
                      padding: '5px 7px',
                      background: 'rgba(255,0,0,0.2)',
                      border: '1px solid rgba(255,0,0,0.5)',
                      borderRadius: 3,
                      fontSize: 9,
                      color: '#ffb3b3'
                    }}>
                      {recallForm.error}
                    </div>
                  )}

                  <button
                    type="button"
                    onClick={() => recallOptimizationResult(recallForm.sessionId, recallForm.jobId)}
                    disabled={recallForm.loading || !recallForm.sessionId.trim() || !recallForm.jobId.trim()}
                    style={{
                      width: '100%',
                      padding: '6px 10px',
                      fontSize: 11,
                      fontWeight: 'bold',
                      borderRadius: 3,
                      border: '1px solid rgba(255,255,255,0.35)',
                      background: recallForm.loading ? 'rgba(33,150,243,0.3)' : 'rgba(33,150,243,0.5)',
                      color: '#fff',
                      cursor: recallForm.loading ? 'not-allowed' : 'pointer',
                      opacity: recallForm.loading || !recallForm.sessionId.trim() || !recallForm.jobId.trim() ? 0.5 : 1
                    }}
                  >
                    {recallForm.loading ? 'Loading...' : 'Recall Results'}
                  </button>
                </div>
              )}

              {(optimizationResultsArray.length > 0 || optimizationBounds) && (
                <button
                  type="button"
                  onClick={() => {
                    // Clear the optimization state - useEffect will handle map cleanup
                    if (pollingTimerRef.current) {
                      window.clearTimeout(pollingTimerRef.current)
                      pollingTimerRef.current = null
                    }
                    setOptimizationStatus('idle')
                    setOptimizationBounds(null)
                    optimizationBoundsRef.current = null
                    setOptimizationSectors([])
                    setSelectedOptimizationSector(null)
                    setOptimizationError(null)
                    setOptimizationJobStatus('idle')
                    setOptimizationJobError(null)
                    setStatusMessage('')
                                    setSubmissionResponse(null)
                    setSessionId('')
                    setJobId('')
                    setOptimizationResults(null)
                    setShowResultsView(false)
                    setResultsError(null)
                    setOptimizationLayerType('none')
                    setOptimizationLayerData(null)
                    setOptimizationLayerStatus('idle')
                    setOptimizationLayerError(null)
                    clearOverlay('optimization-layer')

                    // Clear all result-specific layers before clearing the array
                    optimizationResultsArray.forEach((result: OptimizationResult) => {
                      clearOverlay(`optimization-layer-${result.id}`)
                    })

                    // Clear multi-result state
                    setOptimizationResultsArray([])
                    setActiveResultIndex(null)
                    setShowResultsPanel(false)

                    // Clear recall form
                    setRecallFormVisible(false)
                    setRecallForm({ sessionId: '', jobId: '', error: null, loading: false })

                    // Clear visibility
                    setVisibleBoundingBoxes(new Set())

                    // Clear per-result layer data
                    setResultLayerTypes({})
                    resultLayerDataRef.current = {}
                    resultLayerStatusRef.current = {}
                  }}
                  style={{
                    width: '100%',
                    padding: '8px 10px',
                    borderRadius: 4,
                    border: '1px solid rgba(255,0,0,0.5)',
                    background: 'rgba(255,0,0,0.3)',
                    color: '#fff',
                    cursor: 'pointer',
                    fontWeight: 500,
                    fontSize: 12,
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: 6
                  }}
                  title="Clear all optimizations and start over"
                >
                  🗑️ Clear All Optimizations
                </button>
              )}

              {/* Optimization Configuration Section - Shown during/after drawing */}
              {(optimizationStatus !== 'idle' && optimizationBounds) || (activeResultIndex !== null && optimizationResultsArray[activeResultIndex] && optimizationResultsArray[activeResultIndex].source === 'submitted') ? (
                <div style={{ marginTop: 8, paddingTop: 8, borderTop: '1px solid rgba(33,150,243,0.3)' }}>
                  {/* Show inputs when actively drawing/configuring, otherwise show read-only for submitted results */}
                  {optimizationStatus === 'success' && optimizationSectors.length > 0 && optimizationBounds ? (
              <div style={{ marginTop: 8 }}>
                {/* Input Controls - shown when drawing/configuring new optimization */}
                <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
                  <div style={{ flex: 1 }}>
                    <div style={{ marginBottom: 4, fontSize: 11, fontWeight: 'bold' }}>Frequency:</div>
                    <select
                      value={selectedOptimizationSector ?? ''}
                      onChange={(e) => setSelectedOptimizationSector(Number(e.target.value))}
                      style={{ width: '100%', padding: '4px 6px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer' }}
                    >
                      {optimizationSectors.map((sector: number) => (
                        <option key={sector} value={sector}>
                          {sector}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div style={{ flex: 1 }}>
                    <div style={{ marginBottom: 4, fontSize: 11, fontWeight: 'bold' }}>Network:</div>
                    <select
                      value={selectedNetworkType}
                      onChange={(e) => setSelectedNetworkType(e.target.value)}
                      style={{ width: '100%', padding: '4px 6px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer' }}
                    >
                      <option value="LTE">LTE</option>
                      <option value="5G">5G</option>
                      <option value="FNET">FNET</option>
                    </select>
                  </div>
                </div>

                {/* Optimization Hyperparameters Section */}
                <div style={{ marginTop: 10, marginBottom: 8 }}>
                  <div
                    onClick={() => setHyperparametersExpanded(!hyperparametersExpanded)}
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      cursor: 'pointer',
                      padding: '6px 8px',
                      background: 'rgba(0,0,0,0.4)',
                      borderRadius: 3,
                      border: '1px solid rgba(255,255,255,0.2)',
                      transition: 'all 0.2s'
                    }}
                  >
                    <span style={{ fontSize: 11, marginRight: 6 }}>{hyperparametersExpanded ? '▼' : '▶'}</span>
                    <span style={{ fontSize: 10, fontWeight: 'bold' }}>Optimization Hyperparameters (Optional)</span>
                    {hasHyperparametersChanged() && (
                      <span style={{ marginLeft: 'auto', fontSize: 8, padding: '2px 6px', background: 'rgba(76, 175, 80, 0.3)', borderRadius: 2, color: '#4CAF50' }}>Modified</span>
                    )}
                  </div>

                  {hyperparametersExpanded && (
                    <div style={{ marginTop: 6, padding: 10, background: 'rgba(0,0,0,0.3)', borderRadius: 3, border: '1px solid rgba(255,255,255,0.15)' }}>
                      <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: 8 }}>
                        {/* RSRP Threshold */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.rsrp_threshold}>
                            RSRP Threshold (dBm)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            value={hyperparameters.rsrp_threshold}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, rsrp_threshold: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* SINR Threshold */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.sinr_threshold}>
                            SINR Threshold (dBm)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            value={hyperparameters.sinr_threshold}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, sinr_threshold: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* Alpha Condition Change */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.alpha_condition_change}>
                            Alpha Condition Change
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="0"
                            max="1"
                            value={hyperparameters.alpha_condition_change}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, alpha_condition_change: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* Alpha Bin to Bin */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.alpha_bin_to_bin}>
                            Alpha Bin to Bin
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="0"
                            max="1"
                            value={hyperparameters.alpha_bin_to_bin}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, alpha_bin_to_bin: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* Condition Change Multiplier */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.condition_change_multiplier}>
                            Condition Change Multiplier
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.5"
                            value={hyperparameters.condition_change_multiplier}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, condition_change_multiplier: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* RSRP Bin to Bin Loss Tolerance */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.rsrp_bin_to_bin_loss_tolerance}>
                            RSRP Bin to Bin Loss Tol. (%)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="-100"
                            max="0"
                            value={hyperparameters.rsrp_bin_to_bin_loss_tolerance}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, rsrp_bin_to_bin_loss_tolerance: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* RSRP Condition Change Loss Tolerance */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.rsrp_condition_change_loss_tolerance}>
                            RSRP Cond. Change Loss Tol. (%)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="-100"
                            max="0"
                            value={hyperparameters.rsrp_condition_change_loss_tolerance}
                            readOnly={hyperparametersLocked}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, rsrp_condition_change_loss_tolerance: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff', opacity: hyperparametersLocked ? 0.6 : 1, cursor: hyperparametersLocked ? 'not-allowed' : 'auto' }}
                          />
                        </div>

                        {/* Use User Density Cache */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.use_user_density_cache}>
                            Use User Density Cache
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="checkbox"
                            checked={hyperparameters.use_user_density_cache}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, use_user_density_cache: e.target.checked })}
                            style={{ cursor: hyperparametersLocked ? 'not-allowed' : 'pointer', width: 16, height: 16, opacity: hyperparametersLocked ? 0.6 : 1 }}
                          />
                        </div>

                        {/* Use Default Antenna Pabcerns Only */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.use_default_antenna_pabcerns_only}>
                            Use Default Antenna Pabcerns Only
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="checkbox"
                            checked={hyperparameters.use_default_antenna_pabcerns_only}
                            disabled={hyperparametersLocked}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, use_default_antenna_pabcerns_only: e.target.checked })}
                            style={{ cursor: hyperparametersLocked ? 'not-allowed' : 'pointer', width: 16, height: 16, opacity: hyperparametersLocked ? 0.6 : 1 }}
                          />
                        </div>
                      </div>

                      {/* Reset Button */}
                      <button
                        type="button"
                        onClick={() => setHyperparameters(DEFAULT_HYPERPARAMETERS)}
                        disabled={hyperparametersLocked || !hasHyperparametersChanged()}
                        style={{
                          marginTop: 8,
                          width: '100%',
                          padding: '4px 8px',
                          fontSize: 10,
                          borderRadius: 2,
                          border: '1px solid rgba(255,255,255,0.3)',
                          background: hasHyperparametersChanged() && !hyperparametersLocked ? 'rgba(255,152,0,0.3)' : 'rgba(0,0,0,0.3)',
                          color: '#fff',
                          cursor: hasHyperparametersChanged() && !hyperparametersLocked ? 'pointer' : 'not-allowed',
                          opacity: hasHyperparametersChanged() && !hyperparametersLocked ? 1 : 0.5
                        }}
                      >
                        Reset to Defaults
                      </button>
                    </div>
                  )}
                </div>

                <div style={{ marginTop: 6 }}>
                  {/* Show different buttons when drawing second optimization */}
                  {optimizationResultsArray.length === 1 && optimizationBounds ? (
                    <div style={{ display: 'flex', gap: 6 }}>
                      <button
                        type="button"
                        onClick={() => { void submitOptimizationJob() }}
                        style={{
                          flex: 1,
                          padding: '5px 10px',
                          fontSize: 12,
                          fontWeight: 'bold',
                          borderRadius: 3,
                          border: '1px solid rgba(0,255,0,0.5)',
                          background: (optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') ? 'rgba(255,165,0,0.6)' : 'rgba(0,200,100,0.4)',
                          color: '#fff',
                          cursor: (sessionId.trim() && jobId.trim() && selectedOptimizationSector && optimizationJobStatus === 'idle') ? 'pointer' : 'not-allowed',
                          opacity: (sessionId.trim() && jobId.trim() && selectedOptimizationSector && optimizationJobStatus === 'idle') ? 1 : 0.5,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: 6
                        }}
                        disabled={!sessionId.trim() || !jobId.trim() || !selectedOptimizationSector || optimizationJobStatus !== 'idle'}
                      >
                        <span>➕</span>
                        <span>{(optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') ? 'Running...' : 'Run New'}</span>
                      </button>
                      <button
                        type="button"
                        onClick={() => {
                          // Clear the newly drawn optimization box
                          setOptimizationBounds(null)
                          optimizationBoundsRef.current = null
                          setOptimizationStatus('idle')
                          setOptimizationSectors([])
                          setSelectedOptimizationSector(null)
                          setSessionId('')
                          setJobId('')
                          setOptimizationJobStatus('idle')
                          setOptimizationJobError(null)
                          clearOverlay('optimization-layer')
                        }}
                        style={{
                          flex: 1,
                          padding: '5px 10px',
                          fontSize: 12,
                          fontWeight: 'bold',
                          borderRadius: 3,
                          border: '1px solid rgba(255,100,100,0.5)',
                          background: 'rgba(255,50,50,0.3)',
                          color: '#fff',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: 6
                        }}
                        title="Discard this drawn area"
                      >
                        <span>✖️</span>
                        <span>Clear</span>
                      </button>
                    </div>
                  ) : (
                    <button
                      type="button"
                      onClick={() => { void submitOptimizationJob() }}
                      style={{ width: '100%', padding: '5px 10px', fontSize: 12, fontWeight: 'bold', borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: optimizationJobStatus === 'completed' ? 'rgba(0,200,100,0.5)' : (optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') ? 'rgba(255,165,0,0.6)' : 'rgba(0,128,0,0.3)', color: '#fff', cursor: (sessionId.trim() && jobId.trim() && selectedOptimizationSector && optimizationJobStatus === 'idle') ? 'pointer' : 'not-allowed', opacity: (sessionId.trim() && jobId.trim() && selectedOptimizationSector && optimizationJobStatus === 'idle') ? 1 : 0.5, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6 }}
                      disabled={!sessionId.trim() || !jobId.trim() || !selectedOptimizationSector || optimizationJobStatus !== 'idle'}
                    >
                      <span>{(optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') ? 'Running...' : optimizationJobStatus === 'completed' ? '✓ Complete' : 'Submit Job'}</span>
                    </button>
                  )}
                </div>

                {/* Session/Job ID Display with single Copy button */}
                {sessionId && jobId && (
                  <div style={{ marginTop: 6, padding: '6px 8px', background: 'rgba(100,100,255,0.15)', borderRadius: 3, fontSize: 9, border: '1px solid rgba(100,100,255,0.3)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
                      <strong style={{ fontSize: 9, minWidth: 60 }}>Session ID:</strong>
                      <code style={{ flex: 1, fontSize: 8, background: 'rgba(0,0,0,0.3)', padding: '2px 4px', borderRadius: 2, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {sessionId}
                      </code>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 6 }}>
                      <strong style={{ fontSize: 9, minWidth: 60 }}>Job ID:</strong>
                      <code style={{ flex: 1, fontSize: 8, background: 'rgba(0,0,0,0.3)', padding: '2px 4px', borderRadius: 2, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {jobId}
                      </code>
                    </div>
                    <button
                      type="button"
                      onClick={() => {
                        const text = `Session ID: ${sessionId}, Job ID: ${jobId}`
                        navigator.clipboard.writeText(text)
                        console.log('IDs copied:', text)
                      }}
                      style={{
                        width: '100%',
                        padding: '3px 6px',
                        fontSize: 9,
                        borderRadius: 2,
                        border: '1px solid rgba(255,255,255,0.3)',
                        background: 'rgba(100,150,255,0.3)',
                        color: '#fff',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: 4
                      }}
                      title="Copy Session ID and Job ID"
                    >
                      📋 Copy IDs
                    </button>
                  </div>
                )}

                {(submissionResponse?.results || optimizationJobStatus === 'completed' || optimizationResults) && (
                  <button
                    type="button"
                    onClick={() => {
                      console.log('[Optimization] View Results clicked')
                      if (optimizationResults) {
                        setShowResultsView(true)
                      } else if (submissionResponse?.results) {
                        setOptimizationResults(submissionResponse)
                        setShowResultsView(true)
                      } else {
                        void fetchOptimizationResults()
                      }
                    }}
                    style={{ width: '100%', marginTop: 8, padding: '8px 10px', borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,200,100,0.5)', color: '#fff', cursor: 'pointer', fontWeight: 'bold', fontSize: 11, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4 }}
                  >
                    📊 View Results
                  </button>
                )}
                {resultsError && (
                  <div style={{ marginTop: 4, color: '#ffb3b3', fontSize: 10 }}>
                    <strong>Results Error:</strong> {resultsError}
                  </div>
                )}
              </div>
            ) : optimizationStatus === 'error' && optimizationError ? (
              <div style={{ marginTop: 8, padding: '10px 12px', background: 'rgba(255,0,0,0.15)', borderRadius: 4, border: '1px solid rgba(255,80,80,0.4)' }}>
                <div style={{ fontSize: 10, fontWeight: 'bold', color: '#F87171', marginBottom: 4 }}>Request Error</div>
                <div style={{ fontSize: 10, color: '#ffb3b3', lineHeight: 1.4, wordBreak: 'break-word' }}>{optimizationError}</div>
                <button
                  type="button"
                  onClick={() => {
                    setOptimizationStatus('idle')
                    setOptimizationError(null)
                    setOptimizationBounds(null)
                    optimizationBoundsRef.current = null
                  }}
                  style={{
                    marginTop: 8,
                    padding: '4px 10px',
                    fontSize: 10,
                    borderRadius: 3,
                    border: '1px solid rgba(255,255,255,0.3)',
                    background: 'rgba(255,255,255,0.1)',
                    color: '#fff',
                    cursor: 'pointer'
                  }}
                >
                  Dismiss
                </button>
              </div>
            ) : optimizationStatus === 'loading' && optimizationBounds ? (
              <div style={{ marginTop: 8, padding: '10px 12px', textAlign: 'center' }}>
                <div style={{ fontSize: 10, color: '#90CAF9' }}>Loading frequencies...</div>
              </div>
            ) : activeResultIndex !== null && optimizationResultsArray[activeResultIndex] && optimizationResultsArray[activeResultIndex].source === 'submitted' ? (
              <div style={{ marginTop: 8 }}>
              {/* Read-Only Parameter Display - shown when viewing submitted result */}
              <div style={{ padding: '8px 10px', background: 'rgba(0,100,200,0.15)', borderRadius: 4, border: '1px solid rgba(0,150,255,0.3)' }}>
                <div style={{ marginBottom: 8, fontSize: 10, fontWeight: 'bold', color: '#64B5F6' }}>Submitted Parameters:</div>

                <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
                  <div style={{ flex: 1 }}>
                    <div style={{ fontSize: 9, opacity: 0.7, marginBottom: 2 }}>Frequency:</div>
                    <div style={{ fontSize: 11, fontWeight: 'bold', color: '#fff' }}>
                      {optimizationResultsArray[activeResultIndex].frequency ?? 'N/A'}
                    </div>
                  </div>
                  <div style={{ flex: 1 }}>
                    <div style={{ fontSize: 9, opacity: 0.7, marginBottom: 2 }}>Network:</div>
                    <div style={{ fontSize: 11, fontWeight: 'bold', color: '#fff' }}>
                      {optimizationResultsArray[activeResultIndex].networkType ?? 'N/A'}
                    </div>
                  </div>
                </div>

                {optimizationResultsArray[activeResultIndex].hyperparameters && (
                  <div style={{ marginTop: 8, paddingTop: 8, borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                    <div style={{ fontSize: 9, opacity: 0.7, marginBottom: 4 }}>Hyperparameters:</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: 4, fontSize: 9 }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>RSRP Threshold:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.rsrp_threshold} dBm</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>SINR Threshold:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.sinr_threshold} dBm</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>Alpha Condition Change:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.alpha_condition_change}</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>Alpha Bin to Bin:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.alpha_bin_to_bin}</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>Condition Change Multiplier:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.condition_change_multiplier}</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>RSRP Bin to Bin Loss Tol.:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.rsrp_bin_to_bin_loss_tolerance}%</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>RSRP Cond. Change Loss Tol.:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.rsrp_condition_change_loss_tolerance}%</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>Use User Density Cache:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.use_user_density_cache ? '✓ Yes' : '✗ No'}</span>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <span style={{ opacity: 0.8 }}>Use Default Antenna Pabcerns:</span>
                        <span style={{ fontWeight: 'bold' }}>{optimizationResultsArray[activeResultIndex].hyperparameters.use_default_antenna_pabcerns_only ? '✓ Yes' : '✗ No'}</span>
                      </div>
                    </div>
                  </div>
                )}
              </div>

              {/* Session/Job IDs for the active result */}
              <div style={{ marginTop: 6, padding: '6px 8px', background: 'rgba(100,100,255,0.15)', borderRadius: 3, fontSize: 9, border: '1px solid rgba(100,100,255,0.3)' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
                  <strong style={{ fontSize: 9, minWidth: 60 }}>Session ID:</strong>
                  <code style={{ flex: 1, fontSize: 8, background: 'rgba(0,0,0,0.3)', padding: '2px 4px', borderRadius: 2, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                    {optimizationResultsArray[activeResultIndex].sessionId}
                  </code>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 6 }}>
                  <strong style={{ fontSize: 9, minWidth: 60 }}>Job ID:</strong>
                  <code style={{ flex: 1, fontSize: 8, background: 'rgba(0,0,0,0.3)', padding: '2px 4px', borderRadius: 2, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                    {optimizationResultsArray[activeResultIndex].jobId}
                  </code>
                </div>
                <button
                  type="button"
                  onClick={() => {
                    const text = `Session ID: ${optimizationResultsArray[activeResultIndex].sessionId}, Job ID: ${optimizationResultsArray[activeResultIndex].jobId}`
                    navigator.clipboard.writeText(text)
                    console.log('IDs copied:', text)
                  }}
                  style={{
                    width: '100%',
                    padding: '3px 6px',
                    fontSize: 9,
                    borderRadius: 2,
                    border: '1px solid rgba(255,255,255,0.3)',
                    background: 'rgba(100,150,255,0.3)',
                    color: '#fff',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: 4
                  }}
                  title="Copy Session ID and Job ID"
                >
                  📋 Copy IDs
                </button>
              </div>
              </div>
            ) : null}
                </div>
              ) : null}
            </div>
          </div>
      )}

      {/* Results List & Management Panel */}
      {optimizationResultsArray.length > 0 && (
        <div style={{
          position: 'absolute',
          bottom: 8,
          left: '50%',
          transform: 'translateX(-50%)',
          zIndex: 999,
          background: 'rgba(0,0,0,0.75)',
          color: '#fff',
          padding: 10,
          borderRadius: 6,
          width: 280,
          maxHeight: loadedResultsMinimized ? 'auto' : 'calc(50vh - 16px)',
          overflow: loadedResultsMinimized ? 'visible' : 'auto',
          boxShadow: '0 4px 20px rgba(0,0,0,0.5)'
        }}>
          <div style={{ marginBottom: loadedResultsMinimized ? 0 : 10, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <strong style={{ fontSize: 12 }}>Loaded Results ({optimizationResultsArray.length})</strong>
            <button
              type="button"
              onClick={() => setLoadedResultsMinimized(!loadedResultsMinimized)}
              style={{
                padding: '4px 8px',
                fontSize: 10,
                borderRadius: 3,
                border: '1px solid rgba(255,255,255,0.35)',
                background: 'rgba(100,100,100,0.3)',
                color: '#fff',
                cursor: 'pointer'
              }}
              title={loadedResultsMinimized ? 'Expand' : 'Collapse'}
            >
              {loadedResultsMinimized ? '▲' : '▼'}
            </button>
          </div>

          {/* Result Cards - only show when not minimized */}
          {!loadedResultsMinimized && optimizationResultsArray.map((result: OptimizationResult, idx: number) => (
            <div
              key={result.id}
              style={{
                marginBottom: 8,
                padding: 8,
                borderRadius: 4,
                background: activeResultIndex === idx ? 'rgba(0,128,255,0.3)' : 'rgba(0,0,0,0.3)',
                border: `2px solid ${result.color}`,
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
              onClick={() => {
                setActiveResultIndex(idx)
                setShowResultsPanel(true)

                // Zoom to the result's bounds
                if (mapRef.current && result.bounds) {
                  const bounds = result.bounds
                  // Only zoom if bounds are valid (not all zeros)
                  if (!(bounds.minLng === 0 && bounds.minLat === 0 && bounds.maxLng === 0 && bounds.maxLat === 0)) {
                    try {
                      mapRef.current.fitBounds(
                        [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],
                        {
                          padding: 50,
                          duration: 1000
                        }
                      )
                    } catch (error) {
                      console.error('[Zoom] Failed to fit bounds:', error)
                    }
                  }
                }
              }}
            >
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 4 }}>
                <span style={{ fontSize: 11, fontWeight: 'bold' }}>
                  {result.label}
                  {result.source === 'recalled' && result.submittedTime && (
                    <span style={{ fontWeight: 'normal', opacity: 0.8 }}> | Submitted on: {result.submittedTime}</span>
                  )}
                </span>
                <div style={{ display: 'flex', gap: 4 }}>
                  {/* Toggle Bounding Box Visibility */}
                  <button
                    type="button"
                    onClick={(e: React.MouseEvent) => {
                      e.stopPropagation()
                      setVisibleBoundingBoxes((prev: Set<string>) => {
                        const newSet = new Set(prev)
                        if (newSet.has(result.id)) {
                          newSet.delete(result.id)
                        } else {
                          newSet.add(result.id)
                        }
                        return newSet
                      })
                    }}
                    style={{
                      padding: '2px 6px',
                      fontSize: 9,
                      borderRadius: 2,
                      border: 'none',
                      background: visibleBoundingBoxes.has(result.id) ? 'rgba(0,255,0,0.3)' : 'rgba(255,0,0,0.3)',
                      color: '#fff',
                      cursor: 'pointer'
                    }}
                    title={visibleBoundingBoxes.has(result.id) ? 'Hide box' : 'Show box'}
                  >
                    {visibleBoundingBoxes.has(result.id) ? '👁️' : '🚫'}
                  </button>

                  {/* Delete Result */}
                  <button
                    type="button"
                    onClick={(e: React.MouseEvent) => {
                      e.stopPropagation()

                      // Remove bounding box visualization layers from map
                      if (mapRef.current) {
                        const map = mapRef.current
                        const sourceId = `map-widget-optimization-result-${result.id}-src`
                        const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
                        const lineLayerId = `map-widget-optimization-result-${result.id}-line`

                        if (map.getLayer(lineLayerId)) {
                          map.removeLayer(lineLayerId)
                        }
                        if (map.getLayer(fillLayerId)) {
                          map.removeLayer(fillLayerId)
                        }
                        if (map.getSource(sourceId)) {
                          map.removeSource(sourceId)
                        }
                      }

                      // Remove from visible bounding boxes
                      setVisibleBoundingBoxes((prev: Set<string>) => {
                        const newSet = new Set(prev)
                        newSet.delete(result.id)
                        return newSet
                      })

                      // Clear result-specific overlay layer
                      clearOverlay(`optimization-layer-${result.id}`)

                      // Remove from result layer tracking
                      setResultLayerTypes((prev: Record<string, OptimizationLayerType>) => {
                        const newTypes = { ...prev }
                        delete newTypes[result.id]
                        return newTypes
                      })
                      delete resultLayerDataRef.current[result.id]
                      delete resultLayerStatusRef.current[result.id]

                      // Remove from results array and update active index
                      setOptimizationResultsArray((prev: OptimizationResult[]) => {
                        const newArray = prev.filter((r: OptimizationResult) => r.id !== result.id)

                        // Update active index after deletion
                        if (activeResultIndex === idx) {
                          // If deleting the active result, set to null (no active result)
                          setActiveResultIndex(null)
                        } else if (activeResultIndex !== null && activeResultIndex > idx) {
                          // If deleting a result before the active one, adjust the index
                          setActiveResultIndex(activeResultIndex - 1)
                        }

                        return newArray
                      })
                    }}
                    style={{
                      padding: '2px 6px',
                      fontSize: 9,
                      borderRadius: 2,
                      border: 'none',
                      background: 'rgba(255,0,0,0.3)',
                      color: '#fff',
                      cursor: 'pointer'
                    }}
                    title="Delete result"
                  >
                    🗑️
                  </button>
                </div>
              </div>

              <div style={{ fontSize: 9, opacity: 0.7 }}>
                <div>Session: {result.sessionId.substring(0, 12)}...</div>
                <div>Job: {result.jobId.substring(0, 12)}...</div>
                {result.submittedTime && (
                  <div style={{ marginTop: 2, color: '#90CAF9' }}>Submitted on: {result.submittedTime}</div>
                )}
                <div style={{ display: 'flex', alignItems: 'center', gap: 4, marginTop: 2 }}>
                  <div style={{ width: 12, height: 12, background: result.color, borderRadius: 2 }} />
                  <span>{result.source === 'submitted' ? 'Submitted' : 'Recalled'}</span>
                </div>
              </div>

              {/* View Results Button */}
              <button
                type="button"
                onClick={(e: React.MouseEvent) => {
                  e.stopPropagation()
                  setActiveResultIndex(idx)
                  setShowResultsPanel(true)
                }}
                style={{
                  width: '100%',
                  marginTop: 6,
                  padding: '4px 8px',
                  fontSize: 9,
                  fontWeight: '600',
                  borderRadius: 3,
                  border: activeResultIndex === idx && showResultsPanel
                    ? '1px solid rgba(100,200,255,0.6)'
                    : '1px solid rgba(255,255,255,0.25)',
                  background: activeResultIndex === idx && showResultsPanel
                    ? 'rgba(100,200,255,0.25)'
                    : 'rgba(255,255,255,0.1)',
                  color: activeResultIndex === idx && showResultsPanel ? '#90CAF9' : '#fff',
                  cursor: activeResultIndex === idx && showResultsPanel ? 'default' : 'pointer',
                  transition: 'all 0.2s'
                }}
              >
                {activeResultIndex === idx && showResultsPanel ? 'Viewing Results' : 'View Results'}
              </button>
            </div>
          ))}
        </div>
      )}

      {/* Optimization Legend Panel - Next to Loaded Results */}
      {optimizationResultsArray.length > 0 && activeResultIndex !== null && (() => {
        const resultId = optimizationResultsArray[activeResultIndex]?.id
        const layerType = resultLayerTypes[resultId] || optimizationLayerType
        return layerType && layerType !== 'none'
      })() && (
        <div style={{
          position: 'absolute',
          bottom: 8,
          left: 'min(calc(100% - 208px), calc(50% + 160px))',
          zIndex: 999,
          background: 'rgba(0,0,0,0.75)',
          color: '#fff',
          borderRadius: 6,
          boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
          minWidth: 160,
          maxWidth: 200
        }}>
          <div 
            onClick={() => setOptimizationLegendExpanded(!optimizationLegendExpanded)}
            style={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 6,
              cursor: 'pointer',
              padding: '8px 12px',
              borderBottom: optimizationLegendExpanded ? '1px solid rgba(255,255,255,0.15)' : 'none'
            }}
          >
            <span style={{ 
              fontSize: 12, 
              transform: optimizationLegendExpanded ? 'rotate(180deg)' : 'rotate(0deg)', 
              transition: 'transform 0.2s' 
            }}>▼</span>
            <span style={{ fontSize: 11, fontWeight: 'bold' }}>OPTO Legends</span>
          </div>
          
          {optimizationLegendExpanded && (() => {
            const resultId = optimizationResultsArray[activeResultIndex]?.id
            const layerType = resultLayerTypes[resultId] || optimizationLayerType
            
            return (
              <div style={{ padding: '8px 12px' }}>
                {/* RSRP Pre/Post Optimization */}
                {(layerType === 'rsrp_pre' || layerType === 'rsrp_post') && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      RSRP {layerType === 'rsrp_pre' ? 'Pre' : 'Post'} Optimization
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {RSRP_OPTIMIZATION_LEGEND.map((item: { value: number, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* RSRP Difference */}
                {layerType === 'rsrp_diff' && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      RSRP Difference
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {RSRP_DIFF_LEGEND.map((item: { value: string, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* SINR Pre/Post Optimization */}
                {(layerType === 'sinr_pre' || layerType === 'sinr_post') && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      SNR {layerType === 'sinr_pre' ? 'Pre' : 'Post'} Optimization
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {SINR_OPTIMIZATION_LEGEND.map((item: { value: number, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* SINR Floor Data */}
                {layerType === 'sinr_floor' && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      SNR Floor Data
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {SINR_FLOOR_LEGEND.map((item: { value: number, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* SINR Delta */}
                {layerType === 'sinr_delta' && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      SNR Delta
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {SINR_DELTA_LEGEND.map((item: { value: number, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* User Density */}
                {layerType === 'user_density' && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      User Density | Downlink Volume (GB)
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {USER_DENSITY_LEGEND.map((item: { value: number, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* Bin State Pre/Post/Diff */}
                {(layerType === 'bin_state_pre' || layerType === 'bin_state_post' || layerType === 'bin_state_diff') && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      Bin State {layerType === 'bin_state_pre' ? 'Pre' : layerType === 'bin_state_post' ? 'Post' : 'Difference'}
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                      {BIN_STATE_OPTIMIZATION_LEGEND.map((item: { value: string, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {/* Sector ID Pre/Post/Diff */}
                {(layerType === 'sector_id_pre' || layerType === 'sector_id_post' || layerType === 'sector_id_diff') && (
                  <>
                    <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>
                      Sector ID {layerType === 'sector_id_pre' ? 'Pre' : layerType === 'sector_id_post' ? 'Post' : 'Difference'}
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: 2, maxHeight: 200, overflowY: 'auto' }}>
                      {SECTOR_ID_LEGEND.map((item: { value: number, color: string, label: string }) => (
                        <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                          <div style={{ 
                            width: 20, 
                            height: 14, 
                            background: item.color, 
                            border: '1px solid rgba(255,255,255,0.2)',
                            flexShrink: 0
                          }} />
                          <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
            )
          })()}
        </div>
      )}

      {(showResultsPanel && activeResultData) && (
        <div style={{ 
          position: 'absolute', 
          top: 60,
          right: 8,
          zIndex: 1000, 
          background: 'rgba(0,0,0,0.85)', 
          color: '#fff', 
          padding: 0,
          borderRadius: 6, 
          width: 340, 
          maxHeight: 'calc(100vh - 80px)',
          overflow: 'hidden',
          boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
          border: '1px solid rgba(255,255,255,0.15)'
        }}>
          {/* Header Section */}
          <div style={{ 
            padding: '12px 12px 10px 12px',
            borderBottom: '1px solid rgba(255,255,255,0.1)'
          }}>
            {/* Close button - absolute positioned in corner */}
            <button
              type="button"
              onClick={() => setShowResultsPanel(false)}
              style={{ 
                position: 'absolute',
                top: 8,
                right: 8,
                background: 'rgba(255,0,0,0.4)', 
                border: '1px solid rgba(255,0,0,0.6)', 
                color: '#fff', 
                width: 22, 
                height: 22, 
                borderRadius: 3, 
                cursor: 'pointer', 
                display: 'flex', 
                alignItems: 'center', 
                justifyContent: 'center', 
                fontSize: 14, 
                fontWeight: 'bold', 
                lineHeight: 1, 
                padding: 0,
                zIndex: 2,
                transition: 'all 0.2s'
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.background = 'rgba(255,0,0,0.6)'
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.background = 'rgba(255,0,0,0.4)'
              }}
              title="Close"
            >
              ×
            </button>
            
            {/* Title */}
            <div style={{ paddingRight: 28, marginBottom: 8 }}>
              <strong style={{ fontSize: 12, color: '#64B5F6' }}>Optimization Results</strong>
            </div>
            
            {/* Viewing Section */}
            {activeResultIndex !== null && optimizationResultsArray[activeResultIndex] && (
              <>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 8,
                  padding: '6px 10px',
                  background: `linear-gradient(135deg, ${optimizationResultsArray[activeResultIndex].color}22, ${optimizationResultsArray[activeResultIndex].color}11)`,
                  borderRadius: 4,
                  border: `1px solid ${optimizationResultsArray[activeResultIndex].color}66`,
                  marginBottom: optimizationResultsArray[activeResultIndex].submittedTime ? 4 : 8
                }}>
                  <div style={{
                    width: 8,
                    height: 8,
                    background: optimizationResultsArray[activeResultIndex].color,
                    borderRadius: '50%',
                    flexShrink: 0,
                    boxShadow: `0 0 8px ${optimizationResultsArray[activeResultIndex].color}`
                  }} />
                  <span style={{ fontSize: 10, fontWeight: '500', flex: 1 }}>
                    {optimizationResultsArray[activeResultIndex].label}
                    {optimizationResultsArray[activeResultIndex].source === 'recalled' && optimizationResultsArray[activeResultIndex].submittedTime && (
                      <span style={{ fontWeight: 'normal', opacity: 0.8 }}> | Submitted on: {optimizationResultsArray[activeResultIndex].submittedTime}</span>
                    )}
                  </span>
                  <span style={{ fontSize: 8, opacity: 0.6, textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                    {optimizationResultsArray[activeResultIndex].source === 'submitted' ? 'Submitted' : 'Recalled'}
                  </span>
                </div>
                {optimizationResultsArray[activeResultIndex].source === 'submitted' && optimizationResultsArray[activeResultIndex].submittedTime && (
                  <div style={{ fontSize: 9, color: '#90CAF9', marginBottom: 8 }}>
                    Submitted on: {optimizationResultsArray[activeResultIndex].submittedTime}
                  </div>
                )}
              </>
            )}
            
            {/* Tilt Optimization Button */}
            {activeResultData?.results?.['optimized tilt settings'] && Array.isArray(activeResultData.results['optimized tilt settings']) && (
              <button
                type="button"
                onClick={() => setShowTiltTableModal(true)}
                style={{ 
                  width: '100%',
                  padding: '7px 12px', 
                  borderRadius: 4, 
                  border: '1px solid rgba(100,200,255,0.4)', 
                  background: 'rgba(100,200,255,0.15)', 
                  color: '#fff', 
                  cursor: 'pointer', 
                  fontSize: 10, 
                  fontWeight: '600', 
                  display: 'flex', 
                  alignItems: 'center', 
                  justifyContent: 'center',
                  gap: 6,
                  transition: 'all 0.2s'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(100,200,255,0.25)'
                  e.currentTarget.style.borderColor = 'rgba(100,200,255,0.6)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(100,200,255,0.15)'
                  e.currentTarget.style.borderColor = 'rgba(100,200,255,0.4)'
                }}
              >
                <span>📋</span>
                <span>Tilt Recommendations ({activeResultData.results['optimized tilt settings'].length})</span>
              </button>
            )}
          </div>
          
          {/* Scrollable Content */}
          <div style={{ padding: '12px', overflowY: 'auto', maxHeight: 'calc(100vh - 180px)' }}>
            {/* Visualization Layer Dropdown */}
            <div style={{ marginBottom: 12, paddingBottom: 12, borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
              <div style={{ marginBottom: 6 }}><strong style={{ fontSize: 11 }}>Visualization Layer:</strong></div>
              <select
                value={(() => {
                  // Get layer type for active result
                  if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
                    const resultId = optimizationResultsArray[activeResultIndex].id
                    return resultLayerTypes[resultId] || 'none'
                  }
                  return optimizationLayerType
                })()}
                onChange={(e) => {
                  const newType = e.target.value as OptimizationLayerType

                  // Store layer type for current result
                  if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
                    const resultId = optimizationResultsArray[activeResultIndex].id
                    setResultLayerTypes((prev: Record<string, OptimizationLayerType>) => ({
                      ...prev,
                      [resultId]: newType
                    }))
                  }

                  // Also update global state for backward compatibility
                  setOptimizationLayerType(newType)

                  // Immediately apply visibility change
                  if (newType !== 'none') {
                    setCoverageVisible(false)

                    // Force immediate update of coverage layer visibility
                    if (mapRef.current) {
                      const overlay = overlayRef.current['coverage']
                      if (overlay?.layerIds?.length) {
                        overlay.layerIds.forEach((layerId: string) => {
                          if (mapRef.current?.getLayer(layerId)) {
                            mapRef.current.setLayoutProperty(layerId, 'visibility', 'none')
                          }
                        })
                      }
                    }
                  }

                  const token = authTokenRef.current
                  if (token) {
                    void fetchOptimizationLayer(token, newType)
                  }
                }}
                style={{ width: '100%', padding: '6px 8px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer', marginBottom: 6 }}
              >
                {(() => {
                  const grouped = new Map<string, typeof OPTIMIZATION_LAYER_OPTIONS>()
                  OPTIMIZATION_LAYER_OPTIONS.forEach(opt => {
                    if (!grouped.has(opt.category)) {
                      grouped.set(opt.category, [])
                    }
                    grouped.get(opt.category)!.push(opt)
                  })
                  
                  return Array.from(grouped.entries()).map(([category, options]) => (
                    <optgroup key={category} label={category} style={{ fontSize: 11, fontWeight: 'bold' }}>
                      {options.map(opt => (
                        <option key={opt.value} value={opt.value} style={{ padding: '6px', fontSize: 11 }}>{opt.label}</option>
                      ))}
                    </optgroup>
                  ))
                })()}
              </select>
              {optimizationLayerStatus === 'loading' && (
                <div style={{ fontSize: 9, opacity: 0.8 }}>⏳ Loading layer...</div>
              )}
              {optimizationLayerStatus === 'success' && optimizationLayerType !== 'none' && (
                <div style={{ fontSize: 9, color: '#4CAF50' }}>✓ Layer loaded</div>
              )}
              {optimizationLayerError && (
                <div style={{ fontSize: 9, color: '#ffb3b3' }}>✗ {optimizationLayerError}</div>
              )}
              
              {/* Opacity Slider - only show when a layer is selected */}
              {(() => {
                const resultId = activeResultIndex !== null && optimizationResultsArray[activeResultIndex]?.id
                const layerType = resultId ? (resultLayerTypes[resultId] || optimizationLayerType) : optimizationLayerType
                return layerType && layerType !== 'none'
              })() && (
                <div style={{ marginTop: 8, paddingTop: 8, borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                    <strong style={{ fontSize: 10, minWidth: 45 }}>Opacity</strong>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={optimizationLayerOpacity}
                      onChange={(e) => setOptimizationLayerOpacity(Number(e.target.value))}
                      style={{ flex: 1, cursor: 'pointer', height: 4 }}
                    />
                    <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{optimizationLayerOpacity}%</span>
                  </div>
                </div>
              )}
            </div>

            {/* RSRP & SINR Performance Analysis */}
            {activeResultData?.results?.total_scores && (() => {
              const scores = activeResultData.results.total_scores
              const sections = [
                {
                  title: 'RSRP',
                  delta: scores['Net RSRP Bin to Bin'] || 0,
                  degradation: [
                    { label: 'Flipped Bad', desc: 'Good to Bad', value: scores['RSRP Good to Bad'] || 0, color: '#EF4444' },
                    { label: 'Worse', desc: 'Degraded', value: (scores['RSRP Worse'] || 0) - (scores['RSRP Good to Bad'] || 0), color: '#F97316' },
                  ],
                  improvement: [
                    { label: 'Flipped Good', desc: 'Bad to Good', value: scores['RSRP Bad to Good'] || 0, color: '#EAB308' },
                    { label: 'Improve', desc: 'Enhanced', value: (scores['RSRP Improv'] || 0) - (scores['RSRP Bad to Good'] || 0), color: '#22C55E' },
                  ]
                },
                {
                  title: 'SINR',
                  delta: scores['Net SINR Bin to Bin'] || 0,
                  degradation: [
                    { label: 'Flipped Bad', desc: 'Good to Bad', value: scores['SINR Good to Bad'] || 0, color: '#EF4444' },
                    { label: 'Worse', desc: 'Degraded', value: (scores['SINR Worse'] || 0) - (scores['SINR Good to Bad'] || 0), color: '#F97316' },
                  ],
                  improvement: [
                    { label: 'Flipped Good', desc: 'Bad to Good', value: scores['SINR Bad to Good'] || 0, color: '#EAB308' },
                    { label: 'Improve', desc: 'Enhanced', value: (scores['SINR Improv'] || 0) - (scores['SINR Bad to Good'] || 0), color: '#22C55E' },
                  ]
                }
              ]
              const allBars = sections.flatMap(s => [...s.degradation, ...s.improvement])
              const maxVal = Math.max(...allBars.map(b => Math.abs(b.value)), 0.1)

              const renderBar = (bar: { label: string; desc: string; value: number; color: string }) => (
                <div key={bar.label} style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 4 }}>
                  <div style={{ width: 78, textAlign: 'right', flexShrink: 0 }}>
                    <div style={{ fontSize: 10, fontWeight: '600', color: bar.color }}>
                      {bar.label}
                    </div>
                  </div>
                  <div style={{
                    flex: 1, background: 'rgba(255,255,255,0.06)', borderRadius: 4,
                    height: 20, position: 'relative', overflow: 'hidden'
                  }}>
                    <div style={{
                      position: 'absolute', left: 0, top: 0, bottom: 0,
                      width: `${Math.min((Math.abs(bar.value) / maxVal) * 100, 100)}%`,
                      background: bar.color,
                      borderRadius: 3,
                      opacity: 0.85,
                      transition: 'width 0.5s ease-out'
                    }} />
                    <div style={{
                      position: 'relative', padding: '0 8px', lineHeight: '20px',
                      fontSize: 10, fontWeight: '600', color: '#fff'
                    }}>
                      {bar.value.toFixed(2)}%
                    </div>
                  </div>
                </div>
              )

              return (
                <div style={{ marginBottom: 12 }}>
                  {sections.map((section, sIdx) => (
                    <div key={section.title} style={{
                      marginBottom: sIdx < sections.length - 1 ? 10 : 0,
                      background: 'rgba(255,255,255,0.03)',
                      borderRadius: 8,
                      border: '1px solid rgba(255,255,255,0.08)',
                      overflow: 'hidden'
                    }}>
                      {/* Section Header */}
                      <div style={{
                        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                        padding: '8px 12px',
                        borderBottom: '1px solid rgba(255,255,255,0.06)'
                      }}>
                        <div style={{ display: 'flex', alignItems: 'baseline', gap: 5 }}>
                          <span style={{ fontSize: 12, fontWeight: '700', letterSpacing: '0.5px', color: '#E0E0E0' }}>
                            {section.title}
                          </span>
                          <span style={{ fontSize: 9, fontWeight: '500', color: 'rgba(255,255,255,0.3)', textTransform: 'uppercase' }}>
                            Summary
                          </span>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'baseline', gap: 4 }}>
                          <span style={{ fontSize: 9, fontWeight: '500', color: 'rgba(255,255,255,0.4)' }}>Delta:</span>
                          <span style={{
                            fontSize: 12, fontWeight: '700',
                            color: section.delta >= 0 ? '#4ADE80' : '#F87171',
                            fontFamily: 'monospace'
                          }}>
                            {section.delta >= 0 ? '+' : ''}{section.delta.toFixed(2)}%
                          </span>
                        </div>
                      </div>

                      {/* Chart Content */}
                      <div style={{ padding: '10px 14px 12px' }}>
                        {/* Degradation Group */}
                        <div style={{ marginBottom: 8 }}>
                          <div style={{
                            display: 'flex', alignItems: 'center', gap: 5, marginBottom: 6
                          }}>
                            <svg width="8" height="8" viewBox="0 0 10 10" style={{ flexShrink: 0 }}>
                              <path d="M5 8 L8.5 2.5 L1.5 2.5 Z" fill="#EF4444" opacity="0.8" />
                            </svg>
                            <span style={{
                              fontSize: 9, fontWeight: '600', color: '#EF4444', letterSpacing: '0.5px', textTransform: 'uppercase'
                            }}>
                              Degradation
                            </span>
                            <div style={{ flex: 1, height: 1, background: 'rgba(239,68,68,0.12)' }} />
                          </div>
                          {section.degradation.map(bar => renderBar(bar))}
                        </div>

                        {/* Improvement Group */}
                        <div>
                          <div style={{
                            display: 'flex', alignItems: 'center', gap: 5, marginBottom: 6
                          }}>
                            <svg width="8" height="8" viewBox="0 0 10 10" style={{ flexShrink: 0 }}>
                              <path d="M5 2 L8.5 7.5 L1.5 7.5 Z" fill="#22C55E" opacity="0.8" />
                            </svg>
                            <span style={{
                              fontSize: 9, fontWeight: '600', color: '#22C55E', letterSpacing: '0.5px', textTransform: 'uppercase'
                            }}>
                              Improvement
                            </span>
                            <div style={{ flex: 1, height: 1, background: 'rgba(34,197,94,0.12)' }} />
                          </div>
                          {section.improvement.map(bar => renderBar(bar))}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )
            })()}

            {/* Signal Distribution Line Chart - SINR Pre vs Post */}
            {activeResultData?.results?.histograms && activeResultData.results.histograms['SINR Pre'] && activeResultData.results.histograms['SINR Post'] && (
              <div style={{ marginBottom: 12 }}>
                <div style={{ fontSize: 12, fontWeight: 'bold', marginBottom: 8 }}>SINR Signal Distribution</div>
                {(() => {
                  const sinrPreData = activeResultData.results.histograms['SINR Pre']
                  const sinrPostData = activeResultData.results.histograms['SINR Post']
                  
                  if (!Array.isArray(sinrPreData) || !Array.isArray(sinrPostData)) return <div style={{ fontSize: 10 }}>No data available</div>
                  
                  const allVals = [...sinrPreData, ...sinrPostData].map((d: any) => d.val || 0)
                  const rawMaxVal = Math.max(...allVals, 0)
                  const yMin = 0
                  const yMax = Math.max(1, Math.ceil(rawMaxVal / 5) * 5)
                  const yRange = yMax - yMin
                  const xMin = -35
                  const xMax = 35
                  const xRange = xMax - xMin
                  
                  const createLinePoints = (data: any[]) => {
                    return data.map((d: any, idx: number) => {
                      const low = Number(d.low)
                      const high = Number(d.high)
                      const mid = Number.isFinite(low) && Number.isFinite(high) ? (low + high) / 2 : xMin + (idx / Math.max(data.length - 1, 1)) * xRange
                      const xVal = Math.max(xMin, Math.min(xMax, mid))
                      const x = 40 + ((xVal - xMin) / xRange) * 370
                      const y = 150 - ((d.val - yMin) / yRange) * 150
                      return { x, y, val: d.val, range: `${d.low}-${d.high}` }
                    })
                  }
                  
                  const prePoints = createLinePoints(sinrPreData)
                  const postPoints = createLinePoints(sinrPostData)
                  
                  const createPathD = (points: any[]) => {
                    if (points.length === 0) return ''
                    const start = `M ${points[0].x} ${points[0].y}`
                    const curves = points.slice(1).map((p: any) => `L ${p.x} ${p.y}`).join(' ')
                    return `${start} ${curves}`
                  }
                  
                  return (
                    <div style={{ background: 'rgba(255,255,255,0.05)', padding: 10, borderRadius: 4 }}>
                      <svg width="100%" height="180" viewBox="0 0 420 180" style={{ display: 'block' }}>
                        {/* Y-axis labels and grid */}
                        {[0, yMax * 0.25, yMax * 0.5, yMax * 0.75, yMax].map((y: number) => {
                          const yPos = 150 - ((y - yMin) / yRange) * 150 + 15
                          return (
                            <g key={`y-${y}`}>
                              <line x1="40" y1={yPos} x2="410" y2={yPos} stroke="rgba(255,255,255,0.1)" strokeWidth="1" strokeDasharray="2,2" />
                              <text x="35" y={yPos + 3} fontSize="9" fill="rgba(255,255,255,0.6)" textAnchor="end">{Math.round(y)}</text>
                            </g>
                          )
                        })}
                        
                        {/* Axes */}
                        <line x1="40" y1="15" x2="40" y2="165" stroke="rgba(255,255,255,0.3)" strokeWidth="1" />
                        <line x1="40" y1="165" x2="410" y2="165" stroke="rgba(255,255,255,0.3)" strokeWidth="1" />

                        {/* X-axis labels */}
                        {[-35, -25, -15, -5, 5, 15, 25, 35].map((xTick: number) => {
                          const xPos = 40 + ((xTick - xMin) / xRange) * 370
                          return (
                            <g key={`x-${xTick}`}>
                              <line x1={xPos} y1="165" x2={xPos} y2="170" stroke="rgba(255,255,255,0.2)" strokeWidth="1" />
                              <text x={xPos} y="178" fontSize="9" fill="rgba(255,255,255,0.6)" textAnchor="middle">{xTick}</text>
                            </g>
                          )
                        })}
                        
                        {/* SINR Pre line */}
                        <path d={createPathD(prePoints)} stroke="#2196F3" strokeWidth="2.5" fill="none" strokeLinecap="round" strokeLinejoin="round" />
                        
                        {/* SINR Post line */}
                        <path d={createPathD(postPoints)} stroke="#FF5252" strokeWidth="2.5" fill="none" strokeLinecap="round" strokeLinejoin="round" />
                        
                        {/* Data points */}
                        {prePoints.map((p: any, idx: number) => (
                          <circle key={`pre-${idx}`} cx={p.x} cy={p.y} r="2" fill="#2196F3" opacity="0.8" />
                        ))}
                        {postPoints.map((p: any, idx: number) => (
                          <circle key={`post-${idx}`} cx={p.x} cy={p.y} r="2" fill="#FF5252" opacity="0.8" />
                        ))}
                      </svg>
                      
                      {/* Legend */}
                      <div style={{ display: 'flex', gap: 16, marginTop: 8, fontSize: 10, justifyContent: 'center' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                          <div style={{ width: 14, height: 2, background: '#2196F3', borderRadius: 1 }} />
                          <span>Pre Optimization</span>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                          <div style={{ width: 14, height: 2, background: '#FF5252', borderRadius: 1 }} />
                          <span>Post Optimization</span>
                        </div>
                      </div>
                      
                      <div style={{ marginTop: 6, fontSize: 9, opacity: 0.6, textAlign: 'center' }}>SINR (dB)</div>
                    </div>
                  )
                })()}
              </div>
            )}

          </div>
        </div>
      )}

      {/* Tilt Table Modal */}
      {showTiltTableModal && activeResultData?.results?.['optimized tilt settings'] && (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 10000, background: 'rgba(0,0,0,0.85)', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <div style={{ background: '#1a1a1a', color: '#fff', borderRadius: 8, maxWidth: 1000, width: '100%', maxHeight: '90vh', overflow: 'auto', boxShadow: '0 4px 20px rgba(0,0,0,0.5)' }}>
            <div style={{ padding: '16px 20px', borderBottom: '1px solid rgba(255,255,255,0.1)', display: 'flex', justifyContent: 'space-between', alignItems: 'center', position: 'sticky', top: 0, background: '#1a1a1a', zIndex: 1 }}>
              <h2 style={{ margin: 0, fontSize: 18, fontWeight: 'bold', color: '#fff' }}>Optimized Tilt Recommendations</h2>
              <button
                type="button"
                onClick={() => setShowTiltTableModal(false)}
                style={{ padding: '6px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(255,0,0,0.3)', color: '#fff', cursor: 'pointer', fontSize: 14 }}
              >
                Close
              </button>
            </div>
            <div style={{ padding: 20 }}>
              <div style={{ overflowX: 'auto' }}>
                <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 13 }}>
                  <thead>
                    <tr style={{ background: 'rgba(255,255,255,0.1)' }}>
                      <th style={{ padding: 10, textAlign: 'left', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Sector Name</th>
                      <th style={{ padding: 10, textAlign: 'left', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Antenna Name</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Optimized Tilt</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Current Tilt</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Tilt Delta</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Min Tilt</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Max Tilt</th>
                      <th style={{ padding: 10, textAlign: 'right', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Height (m)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {activeResultData.results['optimized tilt settings'].map((setting: any, idx: number) => (
                      <tr key={idx} style={{ borderBottom: '1px solid rgba(255,255,255,0.1)', background: idx % 2 === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
                        <td style={{ padding: 10 }}>{setting.sector_name}</td>
                        <td style={{ padding: 10 }}>{setting.antenna_name}</td>
                        <td style={{ padding: 10, textAlign: 'center', fontWeight: 'bold', color: '#4CAF50', fontSize: 14 }}>{setting.tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'center' }}>{setting.current_tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'center', fontWeight: 'bold', color: setting.delta_tilt < 0 ? '#FF5722' : '#4CAF50' }}>
                          {setting.delta_tilt > 0 ? '+' : ''}{setting.delta_tilt}°
                        </td>
                        <td style={{ padding: 10, textAlign: 'center', opacity: 0.7 }}>{setting.min_tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'center', opacity: 0.7 }}>{setting.max_tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'right', opacity: 0.7 }}>{setting.height?.toFixed(2)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Floating Legend Panel - Bottom Right */}
      {coverageVisible && (coverageLayer === 'rsrp_dbm_poly' || coverageLayer === 'bin_state_poly' || coverageLayer === 'sector_counter_poly') && (
        <div style={{
          position: 'absolute',
          bottom: 8,
          right: 8,
          zIndex: 1,
          background: 'rgba(0,0,0,0.85)',
          color: '#fff',
          borderRadius: 6,
          boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
          minWidth: 160,
          maxWidth: 200
        }}>
          <div 
            onClick={() => setLegendExpanded(!legendExpanded)}
            style={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 6,
              cursor: 'pointer',
              padding: '8px 12px',
              borderBottom: legendExpanded ? '1px solid rgba(255,255,255,0.15)' : 'none'
            }}
          >
            <span style={{ 
              fontSize: 12, 
              transform: legendExpanded ? 'rotate(180deg)' : 'rotate(0deg)', 
              transition: 'transform 0.2s' 
            }}>▼</span>
            <span style={{ fontSize: 11, fontWeight: 'bold' }}>Legend</span>
          </div>
          
          {legendExpanded && (
            <div style={{ padding: '8px 12px' }}>
              <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>bird Coverage</div>
              
              {coverageLayer === 'rsrp_dbm_poly' && (
                <>
                  <div style={{ fontSize: 8, marginBottom: 8, opacity: 0.7 }}>Composite Coverage</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {RSRP_LEGEND.map((item: { value: number, color: string, label: string }) => (
                      <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <div style={{ 
                          width: 20, 
                          height: 14, 
                          background: item.color, 
                          border: '1px solid rgba(255,255,255,0.2)',
                          flexShrink: 0
                        }} />
                        <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}
              
              {coverageLayer === 'bin_state_poly' && (
                <>
                  <div style={{ fontSize: 8, marginBottom: 8, opacity: 0.7 }}>Composite State per Bin</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {BIN_STATE_LEGEND.map((item: { value: string, color: string, label: string }) => (
                      <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <div style={{ 
                          width: 20, 
                          height: 14, 
                          background: item.color, 
                          border: '1px solid rgba(255,255,255,0.2)',
                          flexShrink: 0
                        }} />
                        <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}

              {coverageLayer === 'sector_counter_poly' && (
                <>
                  <div style={{ fontSize: 8, marginBottom: 8, opacity: 0.7 }}>Sector Count per Bin</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {SECTOR_COUNTER_LEGEND.map((item: { value: number, color: string, label: string }) => (
                      <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <div style={{
                          width: 20,
                          height: 14,
                          background: item.color,
                          border: '1px solid rgba(255,255,255,0.2)',
                          flexShrink: 0
                        }} />
                        <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  )
}

export default MapLibreView
