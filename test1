// TOWER DATA COLLECTION - Terrain'i deÄŸiÅŸtirmeden sadece tower bilgilerini topla
  addPolygonHeights = async (profileData: any): Promise<any> => {
    if (!profileData || !profileData.lines || profileData.lines.length === 0) {
      return profileData
    }

    try {
      // Profile line geometry'sini al
      const profileGeometry = this._defaultViewModel?.input?.geometry
      if (!profileGeometry) {
        return profileData
      }

      // FeatureLayer instance oluÅŸtur
      const featureLayer = new FeatureLayer({
        url: this.state.polygonHeightLayerUrl
      })

      await featureLayer.load()

      // Query parametreleri
      const query = featureLayer.createQuery()
      query.geometry = profileGeometry
      query.spatialRelationship = 'intersects'
      query.returnGeometry = true
      query.outFields = ['usid', 'height_ft', 'azimuth', 'face']
      query.returnZ = true

      const queryResult = await featureLayer.queryFeatures(query)
      
      if (queryResult.features.length === 0) {
        console.log('ðŸ—¼ No towers found along profile')
        this._towerData = []
        return profileData // Orijinal data'yÄ± return et
      }

      // USID bazlÄ± tower mapping (unique towers only)
      const uniqueTowerMap = new Map()

      queryResult.features.forEach((feature) => {
        const usid = feature.attributes.usid
        const heightFt = feature.attributes.height_ft
        const azimuth = feature.attributes.azimuth
        const face = feature.attributes.face
        
        if (usid && heightFt && !isNaN(heightFt) && !uniqueTowerMap.has(usid)) {
          uniqueTowerMap.set(usid, {
            heightFt: heightFt,
            heightMeters: heightFt * 0.3048,
            azimuth: azimuth || 'N/A',
            face: face || 'N/A',
            geometry: feature.geometry
          })
        }
      })

      console.log(`ðŸ—¼ Found ${uniqueTowerMap.size} unique towers along profile`)

      // Terrain data'yÄ± deÄŸiÅŸtirmeden tower locations'larÄ± bul
      const originalSamples = profileData.lines[0].samples
      const towerDetails = []

      originalSamples.forEach((sample, sampleIndex) => {
        const samplePoint = new Point({
          x: sample.x,
          y: sample.y,
          spatialReference: profileGeometry.spatialReference
        })

        // Bu sample'da hangi tower'lar var?
        const towersAtThisPoint = []

        queryResult.features.forEach((feature) => {
          if (geometryEngine.intersects(samplePoint, feature.geometry)) {
            const usid = feature.attributes.usid
            const towerInfo = uniqueTowerMap.get(usid)
            
            if (usid && towerInfo && !towersAtThisPoint.find(t => t.usid === usid)) {
              towersAtThisPoint.push({
                usid: usid,
                heightFt: towerInfo.heightFt,
                heightMeters: towerInfo.heightMeters,
                azimuth: towerInfo.azimuth,
                face: towerInfo.face
              })
            }
          }
        })

        // Tower varsa location'Ä±nÄ± kaydet (terrain'i DEÄžÄ°ÅžTÄ°RME!)
        if (towersAtThisPoint.length > 0) {
          const totalTowerHeight = towersAtThisPoint.reduce((sum, tower) => sum + tower.heightMeters, 0)
          
          const towerDetail = {
            distance: sample.distance,
            terrainElevation: sample.elevation, // Orijinal terrain elevation
            towerHeight: totalTowerHeight,
            towerHeightFt: totalTowerHeight / 0.3048,
            totalElevation: sample.elevation + totalTowerHeight, // Sadece hesaplama iÃ§in
            towers: towersAtThisPoint,
            sampleIndex: sampleIndex
          }
          towerDetails.push(towerDetail)

          console.log(`ðŸ—¼ Tower at distance ${sample.distance.toFixed(1)}m: ${towersAtThisPoint.length} towers, total height: ${(totalTowerHeight / 0.3048).toFixed(1)}ft`)
        }
      })

      // Global tower data'yÄ± sakla
      this._towerData = towerDetails

      // Detailed console output
      if (towerDetails.length > 0) {
        console.log('\nðŸ—¼ === TOWER PROFILE SUMMARY ===')
        console.log(`Total tower locations: ${towerDetails.length}`)
        console.log(`Unique towers found: ${uniqueTowerMap.size}`)
        console.table(towerDetails.map(t => ({
          'Distance (m)': t.distance.toFixed(1),
          'Terrain (m)': t.terrainElevation.toFixed(1),
          'Tower Height (ft)': t.towerHeightFt.toFixed(1),
          'Total Elevation (m)': t.totalElevation.toFixed(1),
          'USIDs': t.towers.map(tower => tower.usid).join(', ')
        })))
        console.log('=================================\n')
      }

      // SADECE ORÄ°JÄ°NAL PROFILE DATA'YI RETURN ET (terrain deÄŸiÅŸtirilmedi)
      return profileData

    } catch (error) {
      console.error('ðŸ—¼ Error processing tower data:', error)
      this._towerData = []
      return profileData
    }
  }

======


getAdjustedBounds = ({ data, pixelWidth, pixelHeight }) => {
    const statistics = data.statistics
    const minX = 0
    //get min max from ground statistics
    let maxX = statistics.maxDistance
    maxX = convertSingle(maxX, data.effectiveUnits.distance, this.props.selectedLinearUnit)
    let minY = statistics.minElevation
    minY = convertSingle(minY, data.effectiveUnits.elevation, this.props.selectedElevationUnit)
    let maxY = statistics.maxElevation
    maxY = convertSingle(maxY, data.effectiveUnits.elevation, this.props.selectedElevationUnit)
    
    //calculate min max based on all the profiles (TOWER'LAR HARÄ°Ã‡)
    for (const layerId in this._minMaxOfEachProfile) {
      // Tower series'ini scaling'den hariÃ§ tut
      if (!layerId.includes('tower') && !layerId.includes('Tower')) {
        if (this._minMaxOfEachProfile[layerId].max > maxY) {
          maxY = this._minMaxOfEachProfile[layerId].max
        }
        if (this._minMaxOfEachProfile[layerId].min < minY) {
          minY = this._minMaxOfEachProfile[layerId].min
        }
      }
    }

    // Make sure our ranges are not too small.
    const rangeX = Math.max(maxX - minX, 0.001)
    let rangeY = Math.max(maxY - minY, 0.001)

    if (data.dynamicElevationRange) {
      // Convert to elevation units so that all values are compatible.
      const rangeXInElevationUnits = convertSingle(rangeX, this.props.selectedLinearUnit, this.props.selectedElevationUnit)
      // Make sure the Y axis is not too small in relation to the X axis.
      rangeY = Math.max(rangeY, rangeXInElevationUnits / 300)
    }

    // Apply some padding at the top and bottom so the chart lines don't align
    // with the axes.
    minY = minY - 0.02 * rangeY
    maxY = minY + rangeY + 0.02 * rangeY

    // Adjust the Y axis such that we obtain guides and labels at 'nice' locations.
    const yMinMax = niceScale(minY, maxY, 10)
    rangeY = yMinMax[1] - yMinMax[0]

    if (this.props.isUniformChartScalingEnable) { //if uniform scaling is true
      return this.getUniformBounds({
        bounds: { minX, maxX, minY, maxY },
        pixelWidth,
        pixelHeight,
        centered: true
      })
    }

    return {
      minX,
      maxX: minX + rangeX,
      minY,
      maxY: minY + rangeY
    }
  }
