// YENƒ∞ METOD - Improved tower series with distance arrows
  addTowerColumnSeries = (ctx) => {
    if (!this.props.towerData || this.props.towerData.length === 0) {
      return null
    }

    console.log('üóº Processing tower data for unique USIDs')

    // Her USID i√ßin tek tower location bul
    const uniqueTowerMap = new Map()
    
    this.props.towerData.forEach(tower => {
      tower.towers.forEach(towerInfo => {
        const usid = towerInfo.usid
        
        if (!uniqueTowerMap.has(usid)) {
          uniqueTowerMap.set(usid, {
            usid: usid,
            distance: tower.distance,
            terrainElevation: tower.terrainElevation,
            totalElevation: tower.totalElevation,
            heightFt: towerInfo.heightFt,
            heightMeters: towerInfo.heightMeters,
            azimuth: towerInfo.azimuth || 'N/A',
            face: towerInfo.face || 'N/A'
          })
        }
      })
    })

    const uniqueTowerArray = Array.from(uniqueTowerMap.values())
    
    // Distance'a g√∂re sƒ±rala
    uniqueTowerArray.sort((a, b) => a.distance - b.distance)

    // Chart data'ya d√∂n√º≈üt√ºr
    const towerChartData = uniqueTowerArray.map(tower => ({
      x: convertSingle(tower.distance, this.props.profileResult.effectiveUnits.distance, this.props.selectedLinearUnit),
      terrainY: convertSingle(tower.terrainElevation, this.props.profileResult.effectiveUnits.elevation, this.props.selectedElevationUnit),
      towerTopY: convertSingle(tower.totalElevation, this.props.profileResult.effectiveUnits.elevation, this.props.selectedElevationUnit),
      towerHeight: convertSingle(tower.heightMeters, 'meters', this.props.selectedElevationUnit),
      usid: tower.usid,
      heightInfo: `${tower.heightFt.toFixed(1)}ft (${tower.heightMeters.toFixed(1)}m)`,
      azimuth: tower.azimuth,
      face: tower.face
    }))

    // Tower Column Series
    const towerColumnSeries = ColumnSeries.new(ctx.chart.root, {
      name: 'üóº Cell Towers',
      valueXField: 'x',
      openValueYField: 'terrainY',
      valueYField: 'towerTopY',
      xAxis: ctx.xAxis,
      yAxis: ctx.yAxis,
      legendLabelText: '{name}',
      fill: colorAm5('#0066cc'),
      stroke: colorAm5('#0044aa'),
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 3,
      cornerRadiusTR: 3
    })

    // Column styling
    towerColumnSeries.columns.template.setAll({
      width: 12,
      fillOpacity: 0.85,
      strokeWidth: 2,
      strokeOpacity: 1,
      // SADECE COLUMN √úZERƒ∞NDE TOOLTIP AKTIF
      cursorOverStyle: 'pointer'
    })

    // Hover effects
    towerColumnSeries.columns.template.states.create('hover', {
      fillOpacity: 1,
      scale: 1.15,
      fill: colorAm5('#0088ff')
    })

    // TOOLTIP SADECE COLUMN'DA
    towerColumnSeries.columns.template.set('tooltip', TooltipAm5.new(ctx.chart.root, {
      labelText: `üóº Cell Tower
USID: {usid}
Height: {heightInfo}
Azimuth: {azimuth}¬∞
Face: {face}

üìç Location
Distance: {x} ${this.nls(this.props.unitOptions.find(u => u.value === this.props.selectedLinearUnit)?.abbreviation)}
Terrain: {terrainY} ${this.nls(this.props.unitOptions.find(u => u.value === this.props.selectedElevationUnit)?.abbreviation)}
Total: {towerTopY} ${this.nls(this.props.unitOptions.find(u => u.value === this.props.selectedElevationUnit)?.abbreviation)}`,
      pointerOrientation: 'vertical'
    }))

    towerColumnSeries.data.setAll(towerChartData)

    // MESAFE ARROWS - Sadece 2+ tower varsa
    if (uniqueTowerArray.length >= 2) {
      this.addTowerDistanceArrows(ctx, uniqueTowerArray)
    }

    console.log(`üóº ${uniqueTowerArray.length} unique towers added to chart`)

    return towerColumnSeries
  }

  // YENƒ∞ METOD - Tower'lar arasƒ± mesafe oklarƒ±
  addTowerDistanceArrows = (ctx, towerArray) => {
    const arrows = []
    
    // Her tower √ßifti i√ßin mesafe arrow'u olu≈ütur
    for (let i = 0; i < towerArray.length - 1; i++) {
      const tower1 = towerArray[i]
      const tower2 = towerArray[i + 1]
      
      const distance1 = convertSingle(tower1.distance, this.props.profileResult.effectiveUnits.distance, this.props.selectedLinearUnit)
      const distance2 = convertSingle(tower2.distance, this.props.profileResult.effectiveUnits.distance, this.props.selectedLinearUnit)
      const distanceBetween = Math.abs(distance2 - distance1)
      
      // Arrow data point
      const arrowData = {
        x1: distance1,
        x2: distance2,
        xMid: (distance1 + distance2) / 2,
        y: Math.max(
          convertSingle(tower1.totalElevation, this.props.profileResult.effectiveUnits.elevation, this.props.selectedElevationUnit),
          convertSingle(tower2.totalElevation, this.props.profileResult.effectiveUnits.elevation, this.props.selectedElevationUnit)
        ) + 20, // Tower'larƒ±n √ºzerinde
        distance: distanceBetween,
        tower1USID: tower1.usid,
        tower2USID: tower2.usid,
        distanceText: `${distanceBetween.toFixed(1)} ${this.nls(this.props.unitOptions.find(u => u.value === this.props.selectedLinearUnit)?.abbreviation)}`
      }
      
      arrows.push(arrowData)
    }

    // Line Series for arrows
    const arrowSeries = LineSeriesAm5.new(ctx.chart.root, {
      name: '‚ÜîÔ∏è Tower Distances',
      valueXField: 'xMid',
      valueYField: 'y',
      xAxis: ctx.xAxis,
      yAxis: ctx.yAxis,
      stroke: colorAm5('#FF6B35'),
      strokeWidth: 2,
      strokeDasharray: [5, 3]
    })

    // Distance labels i√ßin bullet
    arrowSeries.bullets.push(() => {
      const container = ContainerAm5.new(ctx.chart.root, {
        centerX: p50,
        centerY: p50
      })

      // Background rectangle
      const bg = RectangleAm5.new(ctx.chart.root, {
        fill: colorAm5('#FF6B35'),
        fillOpacity: 0.9,
        cornerRadiusTL: 4,
        cornerRadiusTR: 4,
        cornerRadiusBL: 4,
        cornerRadiusBR: 4,
        width: 80,
        height: 20
      })

      // Distance text
      const label = LabelAm5.new(ctx.chart.root, {
        text: '{distanceText}',
        centerX: p50,
        centerY: p50,
        fontSize: 10,
        fontWeight: '600',
        fill: colorAm5('#FFFFFF')
      })

      container.children.push(bg)
      container.children.push(label)

      return BulletAm5.new(ctx.chart.root, {
        sprite: container
      })
    })

    // Arrow line i√ßin √∂zel data olu≈ütur
    const arrowLineData = []
    arrows.forEach(arrow => {
      // Sol ok ucu
      arrowLineData.push({
        xMid: arrow.x1,
        y: arrow.y,
        distanceText: '‚óÑ'
      })
      // Orta mesafe label
      arrowLineData.push({
        xMid: arrow.xMid,
        y: arrow.y,
        distanceText: arrow.distanceText
      })
      // Saƒü ok ucu  
      arrowLineData.push({
        xMid: arrow.x2,
        y: arrow.y,
        distanceText: '‚ñ∫'
      })
    })

    // Arrow tooltip
    arrowSeries.set('tooltip', TooltipAm5.new(ctx.chart.root, {
      labelText: `‚ÜîÔ∏è Distance Between Towers
{tower1USID} ‚Üî {tower2USID}
Distance: {distanceText}`,
      pointerOrientation: 'horizontal'
    }))

    // LEGEND'DEN Gƒ∞ZLE
    this._seriesToBeHiddenInLegend.push(arrowSeries.uid)

    arrowSeries.data.setAll(arrowLineData)
    ctx.chart.series.push(arrowSeries)

    console.log(`‚ÜîÔ∏è Added ${arrows.length} distance arrows between towers`)
  }
