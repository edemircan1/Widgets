/** @jsx jsx */
import { React, jsx, AllWidgetProps } from ‘jimu-core’;
import { JimuMapViewComponent, JimuMapView } from ‘jimu-arcgis’;
import { Button, TextInput, Select, Option, Label, Alert } from ‘jimu-ui’;
import FeatureLayer from ‘esri/layers/FeatureLayer’;
import Query from ‘esri/rest/support/Query’;
import ‘./style.css’;

interface State {
message: string;
chatHistory: ChatMessage[];
loading: boolean;
jimuMapView: JimuMapView;
layerCache: LayerMetadata[];
clarificationNeeded: boolean;
clarificationOptions: ClarificationOption[];
pendingQuery: any;
}

interface ChatMessage {
type: ‘user’ | ‘bot’ | ‘clarification’;
text: string;
timestamp: Date;
data?: any;
}

interface LayerMetadata {
id: string;
title: string;
url: string;
layer: FeatureLayer;
fields: FieldMetadata[];
}

interface FieldMetadata {
name: string;
alias: string;
type: string;
nameTokens: string[];
}

interface ClarificationOption {
label: string;
value: string;
field?: string;
}

export default class SmartFilterWidget extends React.PureComponent<AllWidgetProps<any>, State> {
constructor(props) {
super(props);
this.state = {
message: ‘’,
chatHistory: [],
loading: false,
jimuMapView: null,
layerCache: [],
clarificationNeeded: false,
clarificationOptions: [],
pendingQuery: null
};
}

// Map view yüklendiğinde çağrılır
onActiveViewChange = async (jimuMapView: JimuMapView) => {
if (!jimuMapView) return;

```
this.setState({ jimuMapView, loading: true });

// Layer'ları keşfet
await this.discoverLayers(jimuMapView);

this.addBotMessage('Merhaba! Map bağlantısı kuruldu. Tüm layer\'lar tarandı. Ne aramak istersiniz?');
this.setState({ loading: false });
```

};

// Map’teki tüm Feature Layer’ları keşfet
discoverLayers = async (jimuMapView: JimuMapView) => {
const view = jimuMapView.view;
const layerCache: LayerMetadata[] = [];

```
// Map'teki tüm layer'ları tara
view.map.allLayers.forEach((layer: any) => {
  if (layer.type === 'feature') {
    const featureLayer = layer as FeatureLayer;
    
    const fields: FieldMetadata[] = featureLayer.fields.map(f => ({
      name: f.name,
      alias: f.alias || f.name,
      type: f.type,
      nameTokens: f.name.toLowerCase().split('_')
    }));

    layerCache.push({
      id: featureLayer.id,
      title: featureLayer.title,
      url: featureLayer.url,
      layer: featureLayer,
      fields: fields
    });
  }
});

this.setState({ layerCache });
console.log('Discovered layers:', layerCache);
```

};

// Kullanıcı mesajı gönder
handleSendMessage = async () => {
const { message, layerCache } = this.state;

```
if (!message.trim()) return;

// Kullanıcı mesajını ekle
this.addUserMessage(message);
this.setState({ message: '', loading: true });

try {
  // Mesajı işle
  const result = await this.processMessage(message, layerCache);
  
  if (result.type === 'clarification') {
    // Açıklama gerekiyor
    this.setState({
      clarificationNeeded: true,
      clarificationOptions: result.options,
      pendingQuery: result.pendingQuery,
      loading: false
    });
    this.addBotMessage('Birden fazla eşleşme buldum. Hangisini kastediyorsunuz?');
  } else if (result.type === 'success') {
    // Sorgu başarılı
    await this.executeQuery(result);
    this.addBotMessage(`✅ ${result.resultCount} sonuç bulundu ve haritada gösterildi.`);
    this.setState({ loading: false });
  } else if (result.type === 'error') {
    this.addBotMessage(`❌ ${result.message}`);
    this.setState({ loading: false });
  }
} catch (error) {
  this.addBotMessage(`❌ Hata oluştu: ${error.message}`);
  this.setState({ loading: false });
}
```

};

// Mesajı parse et ve işle
processMessage = async (message: string, layerCache: LayerMetadata[]) => {
// 1. Mesajı parse et
const parsed = this.parseMessage(message);

```
// 2. En uygun layer'ı bul
const layerMatch = this.findBestLayer(parsed, layerCache);

if (!layerMatch || layerMatch.score < 20) {
  return { type: 'error', message: 'Uygun layer bulunamadı. Lütfen daha spesifik olun.' };
}

// 3. Query oluştur
const queryResult = await this.buildSmartQuery(parsed, layerMatch);

return queryResult;
```

};

// Mesaj parse
parseMessage = (message: string) => {
const lowerMessage = message.toLowerCase();
const tokens = lowerMessage.split(/\s+/).filter(t => t.length > 1);

```
return {
  original: message,
  tokens: tokens,
  potentialFields: this.extractPotentialFields(message),
  dates: this.extractDates(message),
  numbers: this.extractNumbers(message),
  operators: this.extractOperators(message),
  freeText: this.extractFreeText(message)
};
```

};

extractPotentialFields = (message: string) => {
// Underscore veya camelCase kelimeler (field isimleri gibi)
const regex = /\b[a-z_][a-z0-9_]*\b/gi;
return (message.match(regex) || []).map(m => m.toLowerCase());
};

extractDates = (message: string) => {
const dates = [];

```
// Yıl pattern
const yearMatch = message.match(/\b(19|20)\d{2}\b/);
if (yearMatch) {
  dates.push({ type: 'year', value: parseInt(yearMatch[0]) });
}

// Ay-Yıl pattern (Türkçe)
const monthNames = {
  'ocak': '01', 'şubat': '02', 'mart': '03', 'nisan': '04',
  'mayıs': '05', 'mayis': '05', 'haziran': '06', 'temmuz': '07',
  'ağustos': '08', 'agustos': '08', 'eylül': '09', 'eylul': '09',
  'ekim': '10', 'kasım': '11', 'kasim': '11', 'aralık': '12', 'aralik': '12'
};

for (const [month, num] of Object.entries(monthNames)) {
  const regex = new RegExp(`${month}\\s*(\\d{4})`, 'i');
  const match = message.match(regex);
  if (match) {
    dates.push({ type: 'month-year', year: parseInt(match[1]), month: num });
  }
}

return dates;
```

};

extractNumbers = (message: string) => {
const numbers = message.match(/\d+(.\d+)?/g);
return numbers ? numbers.map(n => parseFloat(n)) : [];
};

extractOperators = (message: string) => {
const operators = [];
const lowerMsg = message.toLowerCase();

```
if (/büyük|greater|fazla|üzeri|>/i.test(lowerMsg)) operators.push({ type: '>' });
if (/küçük|less|az|altı|</i.test(lowerMsg)) operators.push({ type: '<' });
if (/eşit|equal|=|olan/i.test(lowerMsg)) operators.push({ type: '=' });
if (/arası|between/i.test(lowerMsg)) operators.push({ type: 'BETWEEN' });

return operators;
```

};

extractFreeText = (message: string) => {
// Teknik olmayan kelimeler (şehir isimleri vs)
const technical = this.extractPotentialFields(message);
const words = message.toLowerCase().split(/\s+/);

```
return words.filter(w => 
  w.length > 2 && 
  !technical.includes(w) &&
  !/^\d+$/.test(w) &&
  !['olan', 'göster', 'çıkar', 'bul', 've', 'ile', 'için'].includes(w)
);
```

};

// En iyi layer’ı bul (scoring)
findBestLayer = (parsed: any, layerCache: LayerMetadata[]) => {
const scores = layerCache.map(layer => {
let score = 0;
const matchedFields = [];

```
  // Potential field'lar ile layer field'larını karşılaştır
  parsed.potentialFields.forEach(token => {
    layer.fields.forEach(field => {
      // Exact match
      if (field.name.toLowerCase() === token) {
        score += 50;
        matchedFields.push({ field, token, type: 'exact' });
      }
      // Partial match
      else if (field.name.toLowerCase().includes(token)) {
        score += 25;
        matchedFields.push({ field, token, type: 'partial' });
      }
      // Token match (rsrp_value → rsrp)
      else if (field.nameTokens.includes(token)) {
        score += 30;
        matchedFields.push({ field, token, type: 'token' });
      }
      // Alias match
      else if (field.alias.toLowerCase().includes(token)) {
        score += 20;
        matchedFields.push({ field, token, type: 'alias' });
      }
    });
  });

  // Bonus: Tarih var ve date field var mı?
  if (parsed.dates.length > 0) {
    const hasDateField = layer.fields.some(f => f.type === 'date');
    if (hasDateField) score += 15;
  }

  // Bonus: Sayı var ve numeric field var mı?
  if (parsed.numbers.length > 0) {
    const hasNumField = layer.fields.some(f => f.type === 'double' || f.type === 'integer');
    if (hasNumField) score += 15;
  }

  return { layer, score, matchedFields };
});

return scores.sort((a, b) => b.score - a.score)[0];
```

};

// Smart query oluştur (value matching ile)
buildSmartQuery = async (parsed: any, layerMatch: any) => {
const { layer, matchedFields } = layerMatch;
const conditions = [];

```
// Matched field'lar için query oluştur
for (const match of matchedFields) {
  const field = match.field;

  // DATE FIELD
  if (field.type === 'date' && parsed.dates.length > 0) {
    const dateCond = this.buildDateCondition(field, parsed.dates[0]);
    if (dateCond) conditions.push(dateCond);
  }

  // NUMERIC FIELD
  else if ((field.type === 'double' || field.type === 'integer') && parsed.numbers.length > 0) {
    const numCond = this.buildNumericCondition(field, parsed);
    if (numCond) conditions.push(numCond);
  }

  // STRING FIELD - Value matching yap
  else if (field.type === 'string' && parsed.freeText.length > 0) {
    const textMatch = await this.matchTextValue(parsed.freeText, field, layer.layer);
    
    if (textMatch.type === 'clarification') {
      return {
        type: 'clarification',
        options: textMatch.options,
        pendingQuery: { parsed, layerMatch, field }
      };
    } else if (textMatch.type === 'success') {
      conditions.push(textMatch.condition);
    }
  }
}

// Diğer string field'lara free text uygula
const unmatchedStringFields = layer.layer.fields.filter(f => 
  f.type === 'string' && 
  !matchedFields.some(m => m.field.name === f.name)
);

if (parsed.freeText.length > 0 && unmatchedStringFields.length > 0 && conditions.length === 0) {
  const orConditions = [];
  parsed.freeText.forEach(text => {
    unmatchedStringFields.forEach(field => {
      orConditions.push(`UPPER(${field.name}) LIKE UPPER('%${text}%')`);
    });
  });
  if (orConditions.length > 0) {
    conditions.push(`(${orConditions.join(' OR ')})`);
  }
}

const whereClause = conditions.length > 0 ? conditions.join(' AND ') : '1=1';

return {
  type: 'success',
  layer: layer.layer,
  whereClause: whereClause,
  layerTitle: layer.layer.title
};
```

};

// Text value matching (distinct values ile)
matchTextValue = async (freeTextArray: string[], field: any, layer: FeatureLayer) => {
try {
// Distinct values çek
const query = new Query();
query.where = ‘1=1’;
query.returnDistinctValues = true;
query.outFields = [field.name];
query.returnGeometry = false;
query.num = 1000; // Max 1000 unique değer

```
  const results = await layer.queryFeatures(query);
  const distinctValues = results.features
    .map(f => f.attributes[field.name])
    .filter(v => v !== null && v !== undefined);

  if (distinctValues.length === 0) {
    return { type: 'fallback' };
  }

  // Her free text için match yap
  const allMatches = [];

  freeTextArray.forEach(userText => {
    const variations = this.generateVariations(userText);
    
    distinctValues.forEach(dbValue => {
      const score = this.calculateSimilarity(variations, String(dbValue).toLowerCase());
      if (score > 0.3) {
        allMatches.push({ value: dbValue, score, userText });
      }
    });
  });

  if (allMatches.length === 0) {
    // Match yok - fallback: LIKE query
    const likeConditions = freeTextArray.map(text => 
      `UPPER(${field.name}) LIKE UPPER('%${text}%')`
    );
    return {
      type: 'success',
      condition: `(${likeConditions.join(' OR ')})`
    };
  }

  // En iyi match'i al
  allMatches.sort((a, b) => b.score - a.score);
  const topMatches = allMatches.slice(0, 5);

  // Eğer ilk match çok yüksek skor → otomatik kullan
  if (topMatches[0].score > 0.8) {
    return {
      type: 'success',
      condition: `${field.name} = '${topMatches[0].value}'`
    };
  }

  // Eğer birden fazla benzer match → clarification iste
  if (topMatches.length > 1) {
    return {
      type: 'clarification',
      options: topMatches.map(m => ({
        label: `${m.value} (${m.userText} için)`,
        value: m.value,
        field: field.name
      }))
    };
  }

  return {
    type: 'success',
    condition: `${field.name} = '${topMatches[0].value}'`
  };

} catch (error) {
  console.error('Text matching error:', error);
  return { type: 'fallback' };
}
```

};

generateVariations = (text: string) => {
const variations = [text.toLowerCase()];
variations.push(text.toLowerCase().replace(/\s+/g, ‘’)); // “newyork”
variations.push(text.toLowerCase().replace(/\s+/g, ‘_’)); // “new_york”

```
// İlk harfler (abbreviation)
const words = text.split(/\s+/);
if (words.length > 1) {
  variations.push(words.map(w => w[0]).join('').toLowerCase());
}

return variations;
```

};

calculateSimilarity = (variations: string[], dbValue: string) => {
let maxScore = 0;

```
variations.forEach(variation => {
  // Exact match
  if (variation === dbValue) {
    maxScore = Math.max(maxScore, 1.0);
  }
  // Contains
  else if (dbValue.includes(variation) || variation.includes(dbValue)) {
    maxScore = Math.max(maxScore, 0.8);
  }
  // Starts with
  else if (dbValue.startsWith(variation) || variation.startsWith(dbValue)) {
    maxScore = Math.max(maxScore, 0.7);
  }
});

return maxScore;
```

};

buildDateCondition = (field: any, dateInfo: any) => {
if (dateInfo.type === ‘year’) {
return `${field.name} >= TIMESTAMP '${dateInfo.value}-01-01 00:00:00' AND ${field.name} < TIMESTAMP '${dateInfo.value + 1}-01-01 00:00:00'`;
}

```
if (dateInfo.type === 'month-year') {
  const nextMonth = parseInt(dateInfo.month) === 12 ? 1 : parseInt(dateInfo.month) + 1;
  const nextYear = parseInt(dateInfo.month) === 12 ? dateInfo.year + 1 : dateInfo.year;
  return `${field.name} >= TIMESTAMP '${dateInfo.year}-${dateInfo.month}-01 00:00:00' AND ${field.name} < TIMESTAMP '${nextYear}-${nextMonth.toString().padStart(2, '0')}-01 00:00:00'`;
}

return null;
```

};

buildNumericCondition = (field: any, parsed: any) => {
const numbers = parsed.numbers;
const operators = parsed.operators;

```
if (operators.length === 0 || numbers.length === 0) return null;

const op = operators[0].type;
const num = numbers[0];

if (op === '>') return `${field.name} > ${num}`;
if (op === '<') return `${field.name} < ${num}`;
if (op === '=') return `${field.name} = ${num}`;
if (op === 'BETWEEN' && numbers.length >= 2) {
  return `${field.name} BETWEEN ${numbers[0]} AND ${numbers[1]}`;
}

return null;
```

};

// Clarification cevabı seçildiğinde
handleClarificationSelect = async (selectedValue: string) => {
const { pendingQuery, clarificationOptions } = this.state;
const selected = clarificationOptions.find(o => o.value === selectedValue);

```
this.setState({ clarificationNeeded: false, loading: true });

// Seçilen değeri query'ye ekle
const field = selected.field;
const condition = `${field} = '${selectedValue}'`;

// Query'yi tamamla
const { parsed, layerMatch } = pendingQuery;
const whereClause = condition; // Basit şimdilik

await this.executeQueryDirect(layerMatch.layer.layer, whereClause, layerMatch.layer.layer.title);

this.setState({ loading: false, pendingQuery: null, clarificationOptions: [] });
```

};

// Query’yi çalıştır ve haritada göster
executeQuery = async (result: any) => {
await this.executeQueryDirect(result.layer, result.whereClause, result.layerTitle);
};

executeQueryDirect = async (layer: FeatureLayer, whereClause: string, layerTitle: string) => {
const { jimuMapView } = this.state;

```
try {
  // Query çalıştır
  const query = new Query();
  query.where = whereClause;
  query.returnGeometry = true;
  query.outFields = ['*'];

  const results = await layer.queryFeatures(query);

  if (results.features.length === 0) {
    this.addBotMessage('⚠️ Hiç sonuç bulunamadı.');
    return;
  }

  // Layer'ı highlight et ve zoom yap
  layer.definitionExpression = whereClause;

  // İlk feature'a zoom yap
  if (results.features.length > 0) {
    const extent = results.features[0].geometry.extent;
    jimuMapView.view.goTo(results.features);
  }

  this.addBotMessage(`✅ ${results.features.length} sonuç "${layerTitle}" layer'ında bulundu ve gösterildi.`);

} catch (error) {
  this.addBotMessage(`❌ Query hatası: ${error.message}`);
}
```

};

// Chat mesajları
addUserMessage = (text: string) => {
this.setState(prev => ({
chatHistory: […prev.chatHistory, { type: ‘user’, text, timestamp: new Date() }]
}));
};

addBotMessage = (text: string) => {
this.setState(prev => ({
chatHistory: […prev.chatHistory, { type: ‘bot’, text, timestamp: new Date() }]
}));
};

render() {
const { message, chatHistory, loading, clarificationNeeded, clarificationOptions } = this.state;

```
return (
  <div className="smart-filter-widget jimu-widget" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
    {/* Map View Selector */}
    <JimuMapViewComponent
      useMapWidgetId={this.props.useMapWidgetIds?.[0]}
      onActiveViewChange={this.onActiveViewChange}
    />

    {/* Chat Container */}
    <div style={{ flex: 1, padding: '15px', overflowY: 'auto', backgroundColor: '#f5f5f5' }}>
      {chatHistory.map((msg, idx) => (
        <div
          key={idx}
          style={{
            marginBottom: '10px',
            textAlign: msg.type === 'user' ? 'right' : 'left'
          }}
        >
          <div
            style={{
              display: 'inline-block',
              padding: '8px 12px',
              borderRadius: '12px',
              backgroundColor: msg.type === 'user' ? '#0079c1' : '#fff',
              color: msg.type === 'user' ? '#fff' : '#333',
              maxWidth: '80%',
              boxShadow: '0 1px 2px rgba(0,0,0,0.1)'
            }}
          >
            {msg.text}
          </div>
        </div>
      ))}

      {loading && (
        <div style={{ textAlign: 'center', padding: '10px' }}>
          <span>⏳ İşleniyor...</span>
        </div>
      )}
    </div>

    {/* Clarification Panel */}
    {clarificationNeeded && (
      <div style={{ padding: '15px', backgroundColor: '#fff3cd', borderTop: '1px solid #ccc' }}>
        <Label style={{ marginBottom: '10px', fontWeight: 'bold' }}>
          Lütfen birini seçin:
        </Label>
        <Select
          placeholder="Seçiniz..."
          onChange={(e) => this.handleClarificationSelect(e.target.value)}
        >
          {clarificationOptions.map((opt, idx) => (
            <Option key={idx} value={opt.value}>
              {opt.label}
            </Option>
          ))}
        </Select>
      </div>
    )}

    {/* Input Area */}
    <div style={{ padding: '15px', borderTop: '1px solid #ccc', backgroundColor: '#fff' }}>
      <div style={{ display: 'flex', gap: '10px' }}>
        <TextInput
          placeholder="Mesajınızı yazın... (örn: 2024 mayıs new york rsrp)"
          value={message}
          onChange={(e) => this.setState({ message: e.target.value })}
          onKeyPress={(e) => {
            if (e.key === 'Enter') this.handleSendMessage();
          }}
          style={{ flex: 1 }}
        />
        <Button
          type="primary"
          onClick={this.handleSendMessage}
          disabled={loading || !message.trim()}
        >
          Gönder
        </Button>
      </div>
    </div>
  </div>
);
```

}
}