/** @jsx jsx */
import { React, jsx, AllWidgetProps } from 'jimu-core';
import { JimuMapViewComponent, JimuMapView } from 'jimu-arcgis';
import { TextInput, Label, Alert, Icon, Button } from 'jimu-ui';
import './style.css';

type FeatureLayerField = { name: string; alias?: string; type: string };

type FeatureLayer = {
	id: string;
	title: string;
	url: string;
	type?: string;
	fields?: FeatureLayerField[];
	createQuery?: () => any;
	queryFeatures?: (query: any) => Promise<{ features: any[] }>;
	definitionExpression?: string;
	visible?: boolean;
};

interface FieldMetadata {
	name: string;
	alias: string;
	type: string;
	nameTokens: string[];
}

interface LayerMetadata {
	id: string;
	title: string;
	url: string;
	queryLayer: FeatureLayer;
	fields: FieldMetadata[];
	titleTokens: string[];
	path: string[];
	applyDefinitionExpression?: (whereClause: string | null) => void;
	setVisible?: (visible: boolean) => void;
}

type SearchResultType = 'layer' | 'field';

interface SearchResult {
	type: SearchResultType;
	label: string;
	sublabel?: string;
	score: number;
	layer: LayerMetadata;
	field?: FieldMetadata;
	matchedText: string;
}

interface ActiveFilter {
	id: string;
	label: string;
	layerId: string;
	layerTitle: string;
	fieldName?: string;
	whereClause?: string;
}

interface State {
	searchText: string;
	searchResults: SearchResult[];
	showResults: boolean;
	loading: boolean;
	jimuMapView: JimuMapView | null;
	layerCache: LayerMetadata[];
	connectionStatus: 'idle' | 'connecting' | 'ready' | 'error';
	statusMessage: string;
	activeFilters: ActiveFilter[];
	selectedResultIndex: number;
	isSearchFocused: boolean;
}

const NUMERIC_FIELD_TYPES = new Set([
	'double', 'single', 'integer', 'small-integer', 'smallinteger',
	'short-integer', 'shortinteger', 'long', 'float', 'oid',
]);

const STRING_FIELD_TYPES = new Set(['string', 'guid', 'global-id', 'globalid']);

const normalizeFieldType = (fieldType: string): string => fieldType?.toLowerCase?.() ?? '';
const isNumericFieldType = (fieldType: string): boolean => NUMERIC_FIELD_TYPES.has(normalizeFieldType(fieldType));
const isDateFieldType = (fieldType: string): boolean => normalizeFieldType(fieldType) === 'date';
const isStringFieldType = (fieldType: string): boolean => STRING_FIELD_TYPES.has(normalizeFieldType(fieldType));

export default class SmartSearchWidget extends React.PureComponent<AllWidgetProps<any>, State> {
	private searchInputRef: React.RefObject<HTMLInputElement>;
	private searchDebounceTimer: NodeJS.Timeout | null = null;

	constructor(props: AllWidgetProps<any>) {
		super(props);
		this.searchInputRef = React.createRef();
		this.state = {
			searchText: '',
			searchResults: [],
			showResults: false,
			loading: false,
			jimuMapView: null,
			layerCache: [],
			connectionStatus: 'idle',
			statusMessage: 'Select a map in the widget settings to connect.',
			activeFilters: [],
			selectedResultIndex: -1,
			isSearchFocused: false,
		};
	}

	onActiveViewChange = async (jimuMapView: JimuMapView) => {
		if (!jimuMapView) {
			this.setState({
				jimuMapView: null,
				layerCache: [],
				connectionStatus: 'idle',
				statusMessage: 'No map selected. Choose a map from the widget settings.',
			});
			return;
		}

		this.setState({
			jimuMapView,
			loading: true,
			connectionStatus: 'connecting',
			statusMessage: 'Loading layer information...'
		});

		try {
			const layerCache = await this.discoverLayers(jimuMapView);

			if (layerCache.length === 0) {
				this.setState({
					loading: false,
					connectionStatus: 'error',
					statusMessage: 'No feature layers found in the selected map.',
				});
				return;
			}

			this.setState({
				loading: false,
				connectionStatus: 'ready',
				statusMessage: `Ready. ${layerCache.length} layer(s) indexed.`,
			});
		} catch (error) {
			const messageText = error instanceof Error ? error.message : 'Unknown error';
			this.setState({
				loading: false,
				connectionStatus: 'error',
				statusMessage: `Failed to load layer metadata: ${messageText}`,
			});
		}
	};

	discoverLayers = async (jimuMapView: JimuMapView): Promise<LayerMetadata[]> => {
		const view = jimuMapView?.view;

		if (!view?.map) {
			this.setState({ layerCache: [] });
			return [];
		}

		const layerCache: LayerMetadata[] = [];

		const toArray = (collection: any): any[] => {
			if (!collection) return [];
			if (typeof collection.toArray === 'function') return collection.toArray();
			return Array.isArray(collection) ? collection : [];
		};

		const tokenizeTitlePath = (path: string[]): string[] =>
			path.flatMap((segment) =>
				String(segment).toLowerCase().split(/[\s_>‚Ä∫/-]+/).filter((token) => token.length > 0)
			);

		const collectFeatureLayer = async (
			featureLayer: FeatureLayer,
			titlePath: string[],
			options: { 
				sourceId?: string; 
				applyDefinitionExpression?: (whereClause: string | null) => void;
				setVisible?: (visible: boolean) => void;
			} = {},
		) => {
			try {
				if (typeof (featureLayer as any).load === 'function') {
					await (featureLayer as any).load();
				} else if (typeof (featureLayer as any).when === 'function') {
					await (featureLayer as any).when();
				}
			} catch (error) {
				console.warn('Failed to load layer metadata.', featureLayer?.title ?? options.sourceId ?? 'feature-layer', error);
			}

			const fieldsSource = Array.isArray(featureLayer.fields) ? featureLayer.fields : [];
			const fields: FieldMetadata[] = fieldsSource
				.filter((field: any) => field && field.name)
				.map((field: any) => {
					const name = String(field.name);
					const alias = field.alias ? String(field.alias) : name;
					const type = normalizeFieldType(field.type);
					return {
						name,
						alias,
						type,
						nameTokens: name.toLowerCase().split(/[_\s]+/),
					};
				});

			if (fields.length === 0) return;

			const titlePathClean = titlePath.filter((segment) => segment && segment.trim().length > 0);
			const title = titlePathClean.length > 0 ? titlePathClean.join(' ‚Ä∫ ') : featureLayer.title ?? options.sourceId ?? 'Layer';
			const idCandidateOrder = [options.sourceId, featureLayer.id, featureLayer.url, title];
			let id = idCandidateOrder.find((value) => typeof value === 'string' && value.trim().length > 0) ?? `layer-${layerCache.length}-${Date.now()}`;
			if (layerCache.some((cachedLayer) => cachedLayer.id === id)) {
				id = `${id}-${layerCache.length}`;
			}

			const applyDefinitionExpression = options.applyDefinitionExpression
				? options.applyDefinitionExpression
				: (whereClause: string | null) => {
					featureLayer.definitionExpression = whereClause ?? '1=1';
				};

			const setVisible = options.setVisible
				? options.setVisible
				: (visible: boolean) => {
					if ('visible' in featureLayer) {
						(featureLayer as any).visible = visible;
					}
				};

			layerCache.push({
				id,
				title,
				url: featureLayer.url,
				queryLayer: featureLayer,
				fields,
				titleTokens: tokenizeTitlePath(titlePathClean),
				path: titlePathClean,
				applyDefinitionExpression,
				setVisible,
			});
		};

		const traverseSublayer = async (sublayer: any, parentTitles: string[], parentLayer: any) => {
			const sublayerTitle = String(
				sublayer?.title && sublayer.title.trim().length > 0
					? sublayer.title
					: sublayer?.name ?? sublayer?.id ?? 'Sublayer',
			);
			const titlePath = [...parentTitles, sublayerTitle];
			let featureLayer: FeatureLayer | null = null;

			if (typeof sublayer.createFeatureLayer === 'function') {
				try {
					const result = sublayer.createFeatureLayer();
					featureLayer = typeof (result as any)?.then === 'function' ? await result : result;
				} catch (error) {
					console.warn('Unable to create feature layer from sublayer.', titlePath.join(' ‚Ä∫ '), error);
				}
			} else if (sublayer?.layer?.type === 'feature') {
				featureLayer = sublayer.layer as FeatureLayer;
			}

			if (featureLayer) {
				await collectFeatureLayer(featureLayer, titlePath, {
					sourceId: `${parentLayer?.id ?? parentLayer?.uid ?? 'layer'}-${sublayer.id ?? sublayer.uid ?? sublayerTitle}`,
					applyDefinitionExpression: (whereClause: string | null) => {
						if ('definitionExpression' in sublayer) {
							sublayer.definitionExpression = whereClause ?? '1=1';
						}
					},
					setVisible: (visible: boolean) => {
						if ('visible' in sublayer) {
							sublayer.visible = visible;
						}
						if ('visible' in parentLayer) {
							parentLayer.visible = visible;
						}
					},
				});
			}

			const childSublayers = toArray(sublayer?.sublayers ?? sublayer?.subLayers);
			for (const childSublayer of childSublayers) {
				await traverseSublayer(childSublayer, titlePath, parentLayer);
			}
		};

		const traverseLayer = async (layer: any, parentTitles: string[] = []) => {
			const layerTitle = String(layer?.title ?? layer?.name ?? layer?.id ?? 'Layer');
			const titlePath = [...parentTitles, layerTitle];

			if (layer?.type === 'feature') {
				await collectFeatureLayer(layer as FeatureLayer, titlePath, {
					sourceId: layer.id ?? layer.uid ?? layerTitle,
					applyDefinitionExpression: (whereClause: string | null) => {
						(layer as FeatureLayer).definitionExpression = whereClause ?? '1=1';
					},
					setVisible: (visible: boolean) => {
						if ('visible' in layer) {
							layer.visible = visible;
						}
					},
				});
			}

			const sublayers = toArray(layer?.sublayers ?? layer?.subLayers);
			for (const sublayer of sublayers) {
				await traverseSublayer(sublayer, titlePath, layer);
			}

			const childLayers = toArray(layer?.layers);
			for (const childLayer of childLayers) {
				await traverseLayer(childLayer, titlePath);
			}
		};

		const allLayers = toArray(view.map.allLayers);
		for (const layer of allLayers) {
			await traverseLayer(layer);
		}

		this.setState({ layerCache });
		return layerCache;
	};

	handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
		const searchText = event.target.value;
		this.setState({ searchText, selectedResultIndex: -1 });

		if (this.searchDebounceTimer) {
			clearTimeout(this.searchDebounceTimer);
		}

		if (!searchText.trim()) {
			this.setState({ searchResults: [], showResults: false });
			return;
		}

		this.searchDebounceTimer = setTimeout(() => {
			this.performSearch(searchText);
		}, 150);
	};

	performSearch = (searchText: string) => {
		const { layerCache, connectionStatus } = this.state;

		if (connectionStatus !== 'ready' || !searchText.trim()) {
			this.setState({ searchResults: [], showResults: false });
			return;
		}

		const query = searchText.toLowerCase().trim();
		const results: SearchResult[] = [];

		// Search through layers
		layerCache.forEach((layer) => {
			const layerScore = this.calculateMatchScore(query, layer.title.toLowerCase(), layer.titleTokens);
			
			if (layerScore > 0) {
				results.push({
					type: 'layer',
					label: layer.title,
					sublabel: 'Layer',
					score: layerScore,
					layer,
					matchedText: layer.title,
				});
			}

			// Search through fields in this layer
			layer.fields.forEach((field) => {
				const fieldNameScore = this.calculateMatchScore(query, field.name.toLowerCase(), field.nameTokens);
				const fieldAliasScore = this.calculateMatchScore(query, field.alias.toLowerCase(), []);
				const fieldScore = Math.max(fieldNameScore, fieldAliasScore);

				if (fieldScore > 0) {
					const fieldTypeLabel = this.getFieldTypeLabel(field.type);
					results.push({
						type: 'field',
						label: field.alias || field.name,
						sublabel: `${fieldTypeLabel} in ${layer.path.join(' ‚Ä∫ ')}`,
						score: fieldScore,
						layer,
						field,
						matchedText: field.name,
					});
				}
			});
		});

		// Sort by score (highest first)
		results.sort((a, b) => b.score - a.score);

		// Limit to top 10 results
		const topResults = results.slice(0, 10);

		this.setState({ 
			searchResults: topResults, 
			showResults: topResults.length > 0 
		});
	};

	calculateMatchScore = (query: string, target: string, tokens: string[]): number => {
		let score = 0;

		// Exact match (highest score)
		if (target === query) {
			return 100;
		}

		// Starts with query
		if (target.startsWith(query)) {
			score += 80;
		}

		// Contains query
		if (target.includes(query)) {
			score += 60;
		}

		// Token-based matching
		const queryTokens = query.split(/[\s_-]+/);
		queryTokens.forEach((queryToken) => {
			if (tokens.some((token) => token === queryToken)) {
				score += 40;
			} else if (tokens.some((token) => token.startsWith(queryToken))) {
				score += 30;
			} else if (tokens.some((token) => token.includes(queryToken))) {
				score += 20;
			}
		});

		// Fuzzy matching (character-by-character)
		const fuzzyScore = this.fuzzyMatch(query, target);
		score += fuzzyScore * 10;

		return score;
	};

	fuzzyMatch = (query: string, target: string): number => {
		let queryIndex = 0;
		let targetIndex = 0;
		let matches = 0;

		while (queryIndex < query.length && targetIndex < target.length) {
			if (query[queryIndex] === target[targetIndex]) {
				matches++;
				queryIndex++;
			}
			targetIndex++;
		}

		return matches / query.length;
	};

	getFieldTypeLabel = (fieldType: string): string => {
		if (isNumericFieldType(fieldType)) return 'Number Field';
		if (isDateFieldType(fieldType)) return 'Date Field';
		if (isStringFieldType(fieldType)) return 'Text Field';
		return 'Field';
	};

	handleResultClick = (result: SearchResult) => {
		const { layer, field, type } = result;

		if (type === 'layer') {
			// Activate the layer
			this.activateLayer(layer);
		} else if (type === 'field' && field) {
			// Activate the layer with field focus
			this.activateLayerWithField(layer, field);
		}

		// Clear search
		this.setState({ 
			searchText: '', 
			searchResults: [], 
			showResults: false 
		});
	};

	activateLayer = (layer: LayerMetadata) => {
		const { activeFilters } = this.state;

		// Check if already active
		const existingFilter = activeFilters.find((f) => f.layerId === layer.id && !f.fieldName);
		if (existingFilter) {
			return;
		}

		// Make layer visible
		layer.setVisible?.(true);

		// Clear any definition expression
		layer.applyDefinitionExpression?.('1=1');

		// Add to active filters
		const newFilter: ActiveFilter = {
			id: `layer-${layer.id}-${Date.now()}`,
			label: layer.title,
			layerId: layer.id,
			layerTitle: layer.title,
		};

		this.setState({
			activeFilters: [...activeFilters, newFilter],
		});

		// Zoom to layer
		this.zoomToLayer(layer);
	};

	activateLayerWithField = (layer: LayerMetadata, field: FieldMetadata) => {
		const { activeFilters } = this.state;

		// Check if already active
		const existingFilter = activeFilters.find(
			(f) => f.layerId === layer.id && f.fieldName === field.name
		);
		if (existingFilter) {
			return;
		}

		// Make layer visible
		layer.setVisible?.(true);

		// Clear any definition expression for now (user can apply filters later)
		layer.applyDefinitionExpression?.('1=1');

		// Add to active filters
		const newFilter: ActiveFilter = {
			id: `field-${layer.id}-${field.name}-${Date.now()}`,
			label: `${field.alias || field.name}`,
			layerId: layer.id,
			layerTitle: layer.title,
			fieldName: field.name,
		};

		this.setState({
			activeFilters: [...activeFilters, newFilter],
		});

		// Zoom to layer
		this.zoomToLayer(layer);
	};

	zoomToLayer = async (layer: LayerMetadata) => {
		const { jimuMapView } = this.state;

		if (!jimuMapView?.view) return;

		try {
			const queryFeatures = layer.queryLayer.queryFeatures?.bind(layer.queryLayer);
			if (!queryFeatures) return;

			const query = typeof layer.queryLayer.createQuery === 'function' 
				? layer.queryLayer.createQuery() 
				: ({} as any);
			
			query.where = '1=1';
			query.returnGeometry = true;
			query.outFields = ['*'];

			const results = await queryFeatures(query);
			
			if (results?.features && results.features.length > 0) {
				await jimuMapView.view.goTo(results.features, {
					duration: 1000,
					easing: 'ease-in-out'
				});
			}
		} catch (error) {
			console.warn('Failed to zoom to layer:', error);
		}
	};

	removeFilter = (filterId: string) => {
		const { activeFilters, layerCache } = this.state;
		const filter = activeFilters.find((f) => f.id === filterId);

		if (filter) {
			// Find the layer and reset it
			const layer = layerCache.find((l) => l.id === filter.layerId);
			if (layer) {
				layer.applyDefinitionExpression?.('1=1');
				// Optionally hide the layer
				// layer.setVisible?.(false);
			}
		}

		this.setState({
			activeFilters: activeFilters.filter((f) => f.id !== filterId),
		});
	};

	clearAllFilters = () => {
		const { layerCache } = this.state;

		// Reset all layers
		layerCache.forEach((layer) => {
			layer.applyDefinitionExpression?.('1=1');
		});

		this.setState({ activeFilters: [] });
	};

	handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
		const { searchResults, selectedResultIndex, showResults } = this.state;

		if (!showResults || searchResults.length === 0) return;

		if (event.key === 'ArrowDown') {
			event.preventDefault();
			const newIndex = selectedResultIndex < searchResults.length - 1 
				? selectedResultIndex + 1 
				: 0;
			this.setState({ selectedResultIndex: newIndex });
		} else if (event.key === 'ArrowUp') {
			event.preventDefault();
			const newIndex = selectedResultIndex > 0 
				? selectedResultIndex - 1 
				: searchResults.length - 1;
			this.setState({ selectedResultIndex: newIndex });
		} else if (event.key === 'Enter') {
			event.preventDefault();
			if (selectedResultIndex >= 0 && selectedResultIndex < searchResults.length) {
				this.handleResultClick(searchResults[selectedResultIndex]);
			}
		} else if (event.key === 'Escape') {
			this.setState({ showResults: false, searchResults: [] });
		}
	};

	render() {
		const {
			searchText,
			searchResults,
			showResults,
			loading,
			connectionStatus,
			statusMessage,
			activeFilters,
			selectedResultIndex,
			isSearchFocused,
		} = this.state;

		return (
			<div className="smart-search-widget jimu-widget" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
				<JimuMapViewComponent
					useMapWidgetId={this.props.useMapWidgetIds?.[0]}
					onActiveViewChange={this.onActiveViewChange}
				/>

				{/* Status Bar */}
				<div style={{ padding: '10px 15px', borderBottom: '1px solid #e0e0e0', backgroundColor: '#fff' }}>
					<Alert
						form="basic"
						type={connectionStatus === 'ready' ? 'success' : connectionStatus === 'error' ? 'danger' : 'info'}
						text={statusMessage}
						withIcon
					/>
				</div>

				{/* Search Box */}
				<div style={{ padding: '15px', backgroundColor: '#fff', position: 'relative' }}>
					<div style={{ position: 'relative' }}>
						<TextInput
							ref={this.searchInputRef}
							placeholder="Search layers or fields..."
							value={searchText}
							onChange={this.handleSearchChange}
							onKeyDown={this.handleKeyDown}
							onFocus={() => this.setState({ isSearchFocused: true })}
							onBlur={() => {
								// Delay to allow click on results
								setTimeout(() => this.setState({ isSearchFocused: false }), 200);
							}}
							disabled={connectionStatus !== 'ready'}
							style={{ 
								width: '100%',
								paddingRight: '40px',
								fontSize: '14px',
								height: '40px'
							}}
						/>
						{searchText && (
							<button
								onClick={() => this.setState({ searchText: '', searchResults: [], showResults: false })}
								style={{
									position: 'absolute',
									right: '10px',
									top: '50%',
									transform: 'translateY(-50%)',
									background: 'none',
									border: 'none',
									cursor: 'pointer',
									padding: '5px',
									color: '#666',
								}}
							>
								‚úï
							</button>
						)}
					</div>

					{/* Search Results Dropdown */}
					{showResults && searchResults.length > 0 && (
						<div style={{
							position: 'absolute',
							top: '100%',
							left: '15px',
							right: '15px',
							backgroundColor: '#fff',
							border: '1px solid #ddd',
							borderRadius: '4px',
							boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
							maxHeight: '400px',
							overflowY: 'auto',
							zIndex: 1000,
							marginTop: '5px',
						}}>
							{searchResults.map((result, index) => (
								<div
									key={index}
									onClick={() => this.handleResultClick(result)}
									onMouseEnter={() => this.setState({ selectedResultIndex: index })}
									style={{
										padding: '12px 15px',
										cursor: 'pointer',
										borderBottom: index < searchResults.length - 1 ? '1px solid #f0f0f0' : 'none',
										backgroundColor: selectedResultIndex === index ? '#f5f5f5' : '#fff',
										transition: 'background-color 0.15s',
									}}
								>
									<div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
										<div style={{
											width: '32px',
											height: '32px',
											borderRadius: '4px',
											backgroundColor: result.type === 'layer' ? '#0079c1' : '#6ca0dc',
											display: 'flex',
											alignItems: 'center',
											justifyContent: 'center',
											color: '#fff',
											fontSize: '12px',
											fontWeight: 'bold',
											flexShrink: 0,
										}}>
											{result.type === 'layer' ? 'üìÅ' : 'üìã'}
										</div>
										<div style={{ flex: 1, minWidth: 0 }}>
											<div style={{ 
												fontWeight: 500, 
												fontSize: '14px',
												color: '#333',
												overflow: 'hidden',
												textOverflow: 'ellipsis',
												whiteSpace: 'nowrap',
											}}>
												{result.label}
											</div>
											{result.sublabel && (
												<div style={{ 
													fontSize: '12px', 
													color: '#666',
													overflow: 'hidden',
													textOverflow: 'ellipsis',
													whiteSpace: 'nowrap',
													marginTop: '2px',
												}}>
													{result.sublabel}
												</div>
											)}
										</div>
									</div>
								</div>
							))}
						</div>
					)}
				</div>

				{/* Active Filters */}
				{activeFilters.length > 0 && (
					<div style={{ 
						padding: '15px', 
						backgroundColor: '#f9f9f9', 
						borderBottom: '1px solid #e0e0e0',
						maxHeight: '200px',
						overflowY: 'auto',
					}}>
						<div style={{ 
							display: 'flex', 
							justifyContent: 'space-between', 
							alignItems: 'center',
							marginBottom: '10px' 
						}}>
							<Label style={{ fontWeight: 'bold', margin: 0 }}>
								Active Filters ({activeFilters.length})
							</Label>
							<Button
								size="sm"
								type="tertiary"
								onClick={this.clearAllFilters}
								style={{ fontSize: '12px' }}
							>
								Clear All
							</Button>
						</div>
						<div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
							{activeFilters.map((filter) => (
								<div
									key={filter.id}
									style={{
										display: 'inline-flex',
										alignItems: 'center',
										gap: '8px',
										padding: '6px 12px',
										backgroundColor: '#fff',
										border: '1px solid #ddd',
										borderRadius: '16px',
										fontSize: '13px',
									}}
								>
									<span style={{ color: '#333' }}>
										{filter.fieldName ? `${filter.label} (${filter.layerTitle})` : filter.label}
									</span>
									<button
										onClick={() => this.removeFilter(filter.id)}
										style={{
											background: 'none',
											border: 'none',
											cursor: 'pointer',
											padding: '0',
											color: '#666',
											fontSize: '16px',
											lineHeight: '1',
										}}
									>
										√ó
									</button>
								</div>
							))}
						</div>
					</div>
				)}

				{/* Main Content Area */}
				<div style={{ 
					flex: 1, 
					padding: '20px', 
					overflowY: 'auto', 
					backgroundColor: '#fff',
					display: 'flex',
					alignItems: 'center',
					justifyContent: 'center',
				}}>
					{connectionStatus !== 'ready' ? (
						<div style={{ textAlign: 'center', color: '#666' }}>
							<div style={{ fontSize: '48px', marginBottom: '15px' }}>üîç</div>
							<div style={{ fontSize: '16px', fontWeight: 500 }}>
								{statusMessage}
							</div>
						</div>
					) : activeFilters.length === 0 ? (
						<div style={{ textAlign: 'center', color: '#666' }}>
							<div style={{ fontSize: '48px', marginBottom: '15px' }}>üó∫Ô∏è</div>
							<div style={{ fontSize: '16px', fontWeight: 500, marginBottom: '8px' }}>
								Search to get started
							</div>
							<div style={{ fontSize: '14px', color: '#999' }}>
								Type to search layers or fields
							</div>
						</div>
					) : (
						<div style={{ textAlign: 'center', color: '#666' }}>
							<div style={{ fontSize: '48px', marginBottom: '15px' }}>‚úÖ</div>
							<div style={{ fontSize: '16px', fontWeight: 500 }}>
								{activeFilters.length} filter{activeFilters.length !== 1 ? 's' : ''} active
							</div>
						</div>
					)}
				</div>

				{/* Help Text */}
				<div style={{ 
					padding: '12px 15px', 
					backgroundColor: '#f9f9f9', 
					borderTop: '1px solid #e0e0e0',
					fontSize: '12px',
					color: '#666',
				}}>
					<div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap' }}>
						<div><strong>Tip:</strong> Use ‚Üë‚Üì to navigate, Enter to select, Esc to close</div>
					</div>
				</div>
			</div>
		);
	}
}
