import { React, AllWidgetProps } from 'jimu-core';
import { BaseWidget } from 'jimu-core';
import FeatureLayer from 'esri/layers/FeatureLayer';

export default class AutoPolygonSizer extends BaseWidget<AllWidgetProps<any>, any> {
  
  private featureLayer: FeatureLayer = null;
  
  // URL'i buradan kontrol et - KENDÄ° URL'Ä°NÄ° YAZMANIZ GEREK
  private readonly FEATURE_LAYER_URL = "https://services.arcgis.com/your-service-url/FeatureServer/0";
  
  // Size ayarlarÄ±
  private readonly SIZE_CONFIG = {
    baseSize: 2,
    zoomFactor: 0.5,
    minSize: 0.5,
    maxSize: 8
  };

  componentDidMount() {
    console.log('=== AutoPolygonSizer Widget Mounted ===');
    console.log('useMapWidgetIds:', this.props.useMapWidgetIds);
    console.log('mapWidgetInstances:', this.props.mapWidgetInstances);
    
    // MapView hazÄ±r olana kadar bekle
    setTimeout(() => {
      if (this.props.useMapWidgetIds?.length > 0) {
        this.loadFeatureLayer();
      } else {
        console.log('âŒ No map widget selected in settings');
      }
    }, 2000);
  }

  componentDidUpdate(prevProps: AllWidgetProps<any>) {
    console.log('Widget updated');
    if (prevProps.useMapWidgetIds !== this.props.useMapWidgetIds) {
      console.log('Map widget selection changed, reloading...');
      this.loadFeatureLayer();
    }
  }

  loadFeatureLayer = async () => {
    try {
      console.log('ğŸ”„ Loading feature layer from:', this.FEATURE_LAYER_URL);
      
      // Feature Layer oluÅŸtur
      this.featureLayer = new FeatureLayer({
        url: this.FEATURE_LAYER_URL,
        title: "Auto-sized Polygons",
        renderer: this.createInitialRenderer()
      });

      console.log('âœ… Feature layer created:', this.featureLayer);

      // MapView'Ä± al
      const mapWidgetId = this.props.useMapWidgetIds[0];
      const jimuMapView = this.props.mapWidgetInstances[mapWidgetId]?.jimuMapView;
      
      console.log('ğŸ—ºï¸ MapWidget ID:', mapWidgetId);
      console.log('ğŸ—ºï¸ JimuMapView:', jimuMapView);
      
      if (jimuMapView?.view) {
        console.log('âœ… MapView found, adding layer...');
        
        // Layer'Ä± map'e ekle
        jimuMapView.view.map.add(this.featureLayer);
        console.log('âœ… Layer added to map');
        
        // Zoom listener'Ä± kur
        this.setupZoomListener(jimuMapView.view);
        
        // Ä°lk boyut ayarÄ±nÄ± yap
        const currentZoom = jimuMapView.view.zoom;
        console.log('ğŸ” Initial zoom level:', currentZoom);
        this.adjustPolygonSize(currentZoom);
        
      } else {
        console.log('âŒ MapView not found or not ready');
      }
      
    } catch (error) {
      console.error('âŒ Feature Layer loading error:', error);
    }
  }

  createInitialRenderer = () => {
    const renderer = {
      type: "simple",
      symbol: {
        type: "simple-fill",
        color: [51, 150, 204, 0.4],
        outline: {
          color: [51, 150, 204, 1],
          width: this.SIZE_CONFIG.baseSize,
          style: "solid"
        }
      }
    };
    
    console.log('ğŸ¨ Created initial renderer:', renderer);
    return renderer;
  }

  setupZoomListener = (mapView: any) => {
    console.log('ğŸ‘‚ Setting up zoom listener...');
    console.log('ğŸ” Current zoom level:', mapView.zoom);
    
    mapView.watch("zoom", (newZoom: number, oldZoom: number) => {
      console.log(`ğŸ” ZOOM CHANGED: ${oldZoom} â†’ ${newZoom}`);
      this.adjustPolygonSize(newZoom);
    });
    
    console.log('âœ… Zoom listener setup complete');
  }

  adjustPolygonSize = (zoomLevel: number) => {
    console.log('ğŸ”§ === ADJUSTING POLYGON SIZE ===');
    console.log('ğŸ” Zoom level:', zoomLevel);
    console.log('ğŸ“ Feature layer:', this.featureLayer);
    
    if (!this.featureLayer) {
      console.log('âŒ No feature layer found!');
      return;
    }

    // Size hesapla
    const { baseSize, zoomFactor, minSize, maxSize } = this.SIZE_CONFIG;
    let calculatedSize = baseSize * Math.max(0.5, (18 - zoomLevel) * zoomFactor);
    
    // Min/max limitleri uygula
    calculatedSize = Math.max(minSize, Math.min(maxSize, calculatedSize));
    
    console.log('ğŸ“ Calculated size:', calculatedSize);
    console.log('ğŸ“ Size config:', this.SIZE_CONFIG);
    
    // Mevcut renderer'Ä± kontrol et
    const currentRenderer = this.featureLayer.renderer;
    console.log('ğŸ¨ Current renderer:', currentRenderer);
    console.log('ğŸ¨ Current renderer type:', currentRenderer?.type);
    
    if (currentRenderer) {
      // Renderer'Ä± klonla
      const newRenderer = currentRenderer.clone();
      console.log('ğŸ¨ Cloned renderer:', newRenderer);
      
      // Symbol'u kontrol et ve gÃ¼ncelle
      if (newRenderer.symbol) {
        console.log('ğŸ¨ Current symbol:', newRenderer.symbol);
        
        if (newRenderer.symbol.outline) {
          const oldWidth = newRenderer.symbol.outline.width;
          newRenderer.symbol.outline.width = calculatedSize;
          
          console.log(`ğŸ“ Outline width: ${oldWidth} â†’ ${calculatedSize}`);
          
          // Renderer'Ä± ata
          this.featureLayer.renderer = newRenderer;
          console.log('âœ… Renderer updated successfully');
          
          // DoÄŸrulama
          setTimeout(() => {
            const verifyRenderer = this.featureLayer.renderer;
            console.log('ğŸ” Verification - New renderer outline width:', 
              verifyRenderer?.symbol?.outline?.width);
          }, 100);
          
        } else {
          console.log('âŒ No outline found in symbol!');
          console.log('ğŸ¨ Symbol structure:', newRenderer.symbol);
        }
      } else {
        console.log('âŒ No symbol found in renderer!');
      }
    } else {
      console.log('âŒ No renderer found on feature layer!');
    }
    
    console.log('ğŸ”§ === SIZE ADJUSTMENT COMPLETE ===');
  }

  render() {
    // Background widget - UI yok
    return null;
  }
}