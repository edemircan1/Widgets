/** @jsx jsx */
import { React, jsx } from "jimu-core";

const MVT_STYLE_URL = "/styles/all/style.json?coverageLayer=rsrp_dbm";
const MANUAL_BEARER = "token";
const ARCGIS_API_VERSION = "4.32";

interface State {
  message: string;
  currentZoom: number;
  currentTest: string;
}

export default class Widget extends React.PureComponent<any, State> {
  private mapDiv: HTMLDivElement;
  private mapView: any;
  private map: any;
  private currentLayers: any[] = [];

  constructor(props) {
    super(props);
    this.state = {
      message: "Widget y√ºkleniyor...",
      currentZoom: 15,
      currentTest: "none"
    };
  }

  componentDidMount() {
    this.loadArcGISAPI();
  }

  componentWillUnmount() {
    if (this.mapView) {
      this.mapView.destroy();
    }
  }

  loadArcGISAPI = () => {
    this.setState({ message: "üì¶ ArcGIS API y√ºkleniyor..." });

    if ((window as any).require) {
      this.setState({ message: "‚úÖ ArcGIS API y√ºklendi" });
      this.createMap();
      return;
    }

    const cssLink = document.createElement("link");
    cssLink.rel = "stylesheet";
    cssLink.href = `https://js.arcgis.com/${ARCGIS_API_VERSION}/esri/themes/dark/main.css`;
    document.head.appendChild(cssLink);

    const script = document.createElement("script");
    script.src = `https://js.arcgis.com/${ARCGIS_API_VERSION}/`;
    script.setAttribute('data-arcgis-api', ARCGIS_API_VERSION);
    script.onload = () => {
      this.setState({ message: "‚úÖ ArcGIS API y√ºklendi" });
      this.createMap();
    };
    script.onerror = () => {
      this.setState({ message: "‚ùå ArcGIS API y√ºklenemedi" });
    };
    document.head.appendChild(script);
  };

  createMap = () => {
    this.setState({ message: "üó∫Ô∏è Map olu≈üturuluyor..." });

    if (!this.mapDiv) {
      setTimeout(() => this.createMap(), 50);
      return;
    }

    if (!(window as any).require) {
      this.setState({ message: "‚ùå ArcGIS API loader bulunamadƒ±" });
      return;
    }

    (window as any).require([
      'esri/Map',
      'esri/views/MapView'
    ], (Map, MapView) => {
      
      this.map = new Map({
        basemap: 'dark-gray-vector'
      });

      this.mapView = new MapView({
        container: this.mapDiv,
        map: this.map,
        center: [32, 39],
        zoom: 15,
        constraints: {
          snapToZoom: false,
          minZoom: 3,
          maxZoom: 22,
          rotationEnabled: false
        }
      });

      this.mapView.watch('zoom', (newZoom) => {
        this.setState({ currentZoom: Math.round(newZoom * 10) / 10 });
      });

      this.setState({ message: "‚úÖ Map hazƒ±r! Test se√ßin..." });

      // Setup fetch override for authorization
      const originalFetch = window.fetch;
      window.fetch = (url, options = {}) => {
        const urlStr = url.toString();
        if (urlStr.includes('oauth21') || urlStr.includes('vector/tile')) {
          return originalFetch(url, {
            ...options,
            headers: {
              ...(options['headers'] || {}),
              'Authorization': `Bearer ${MANUAL_BEARER}`
            }
          });
        }
        return originalFetch(url, options);
      };
      
    }, (err) => {
      this.setState({ message: `‚ùå Loader error: ${err?.message || err}` });
      console.error('AMD require error:', err);
    });
  };

  clearLayers = () => {
    this.currentLayers.forEach(layer => {
      this.map.remove(layer);
    });
    this.currentLayers = [];
  };

  applyTest = (testName: string) => {
    this.setState({ message: `üß™ Test: ${testName}...`, currentTest: testName });
    this.clearLayers();

    (window as any).require([
      'esri/layers/VectorTileLayer',
      'esri/request'
    ], (VectorTileLayer, esriRequest) => {

      console.log(`\nüß™ ========== TEST: ${testName} ==========`);

      switch(testName) {
        case 'baseline':
          this.testBaseline(VectorTileLayer, esriRequest);
          break;
        case 'step_expression':
          this.testStepExpression(VectorTileLayer, esriRequest);
          break;
        case 'step_with_cast':
          this.testStepWithCast(VectorTileLayer, esriRequest);
          break;
        case 'match_expression':
          this.testMatchExpression(VectorTileLayer, esriRequest);
          break;
        case 'case_ranges':
          this.testCaseRanges(VectorTileLayer, esriRequest);
          break;
        case 'interpolate_cubic':
          this.testInterpolateCubic(VectorTileLayer, esriRequest);
          break;
      }
    });
  };

  // BASELINE: Original API (gri g√∂r√ºnen, ama MVT y√ºkleniyor)
  testBaseline = (VectorTileLayer, esriRequest) => {
    console.log("üìã BASELINE: Original API style");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;
      console.log("Original Style:", originalStyle);

      const zoomConfigs = [
        { name: '3z', source: 'coverage_3z', minZoom: 0, maxZoom: 7 },
        { name: '7z', source: 'coverage_7z', minZoom: 7, maxZoom: 11 },
        { name: '11z', source: 'coverage_11z', minZoom: 11, maxZoom: 15 },
        { name: '15z', source: 'coverage_15z', minZoom: 15, maxZoom: 24 }
      ];

      zoomConfigs.forEach(config => {
        const customStyle = {
          version: 8,
          sources: {
            [config.source]: originalStyle.sources[config.source]
          },
          layers: originalStyle.layers.filter(layer => 
            layer.source === config.source
          ).map(layer => ({
            ...layer,
            minzoom: config.minZoom,
            maxzoom: config.maxZoom
          }))
        };

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `Baseline ${config.name}`
        });

        layer.when(() => {
          console.log(`‚úÖ ${config.name} loaded`);
        }).catch(err => {
          console.error(`‚ùå ${config.name} error:`, err);
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "‚úÖ Baseline y√ºklendi (gri MVT)" });
    }).catch(err => {
      this.setState({ message: `‚ùå Baseline failed: ${err.message}` });
    });
  };

  // TEST 1: Step Expression (Mapbox spec)
  testStepExpression = (VectorTileLayer, esriRequest) => {
    console.log("üìã TEST 1: Step expression");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const zoomConfigs = [
        { name: '3z', source: 'coverage_3z', minZoom: 0, maxZoom: 7 },
        { name: '7z', source: 'coverage_7z', minZoom: 7, maxZoom: 11 },
        { name: '11z', source: 'coverage_11z', minZoom: 11, maxZoom: 15 },
        { name: '15z', source: 'coverage_15z', minZoom: 15, maxZoom: 24 }
      ];

      zoomConfigs.forEach(config => {
        const customStyle = {
          version: 8,
          sources: {
            [config.source]: originalStyle.sources[config.source]
          },
          layers: [
            {
              id: `fill_${config.source}`,
              type: 'fill',
              source: config.source,
              'source-layer': 'data',
              minzoom: config.minZoom,
              maxzoom: config.maxZoom,
              paint: {
                'fill-opacity': 0.7,
                'fill-color': [
                  'step',
                  ['get', 'rsrp_dbm'],
                  '#313695',
                  -126, '#4575B4',
                  -118, '#74ADD1',
                  -109, '#ABD9E9',
                  -100, '#E0F3F8',
                  -92, '#FFFFBF',
                  -83, '#FEE090',
                  -75, '#FDAE61',
                  -66, '#F46D43',
                  -57, '#D73027',
                  -49, '#A50026'
                ]
              }
            },
            {
              id: `line_${config.source}`,
              type: 'line',
              source: config.source,
              'source-layer': 'data',
              minzoom: config.minZoom,
              maxzoom: config.maxZoom,
              paint: {
                'line-opacity': 0.8,
                'line-color': [
                  'step',
                  ['get', 'rsrp_dbm'],
                  '#313695',
                  -126, '#4575B4',
                  -118, '#74ADD1',
                  -109, '#ABD9E9',
                  -100, '#E0F3F8',
                  -92, '#FFFFBF',
                  -83, '#FEE090',
                  -75, '#FDAE61',
                  -66, '#F46D43',
                  -57, '#D73027',
                  -49, '#A50026'
                ]
              }
            }
          ]
        };

        console.log(`Step style for ${config.name}:`, customStyle);

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `Step ${config.name}`
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "‚úÖ Step expression uygulandƒ±" });
    }).catch(err => {
      this.setState({ message: `‚ùå Step failed: ${err.message}` });
    });
  };

  // TEST 2: Step with Type Cast
  testStepWithCast = (VectorTileLayer, esriRequest) => {
    console.log("üìã TEST 2: Step with explicit type casting");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const zoomConfigs = [
        { name: '15z', source: 'coverage_15z', minZoom: 15, maxZoom: 24 }
      ];

      zoomConfigs.forEach(config => {
        const customStyle = {
          version: 8,
          sources: {
            [config.source]: originalStyle.sources[config.source]
          },
          layers: [
            {
              id: `fill_${config.source}`,
              type: 'fill',
              source: config.source,
              'source-layer': 'data',
              minzoom: config.minZoom,
              maxzoom: config.maxZoom,
              paint: {
                'fill-opacity': 0.7,
                'fill-color': [
                  'step',
                  ['to-number', ['get', 'rsrp_dbm']],
                  '#313695',
                  -126, '#4575B4',
                  -118, '#74ADD1',
                  -109, '#ABD9E9',
                  -100, '#E0F3F8',
                  -92, '#FFFFBF',
                  -83, '#FEE090',
                  -75, '#FDAE61',
                  -66, '#F46D43',
                  -57, '#D73027',
                  -49, '#A50026'
                ]
              }
            }
          ]
        };

        console.log(`Step with cast:`, customStyle);

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `StepCast ${config.name}`
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "‚úÖ Step + type cast uygulandƒ±" });
    }).catch(err => {
      this.setState({ message: `‚ùå Step+cast failed: ${err.message}` });
    });
  };

  // TEST 3: Match Expression
  testMatchExpression = (VectorTileLayer, esriRequest) => {
    console.log("üìã TEST 3: Match expression with rounded values");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const zoomConfigs = [
        { name: '15z', source: 'coverage_15z', minZoom: 15, maxZoom: 24 }
      ];

      zoomConfigs.forEach(config => {
        const customStyle = {
          version: 8,
          sources: {
            [config.source]: originalStyle.sources[config.source]
          },
          layers: [
            {
              id: `fill_${config.source}`,
              type: 'fill',
              source: config.source,
              'source-layer': 'data',
              minzoom: config.minZoom,
              maxzoom: config.maxZoom,
              paint: {
                'fill-opacity': 0.7,
                'fill-color': [
                  'match',
                  ['round', ['/', ['get', 'rsrp_dbm'], 10]],
                  -13, '#313695',
                  -12, '#4575B4',
                  -11, '#74ADD1',
                  -10, '#ABD9E9',
                  -9, '#E0F3F8',
                  -8, '#FFFFBF',
                  -7, '#FEE090',
                  -6, '#FDAE61',
                  -5, '#F46D43',
                  -4, '#D73027',
                  '#CCCCCC'
                ]
              }
            }
          ]
        };

        console.log(`Match expression:`, customStyle);

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `Match ${config.name}`
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "‚úÖ Match expression uygulandƒ±" });
    }).catch(err => {
      this.setState({ message: `‚ùå Match failed: ${err.message}` });
    });
  };

  // TEST 4: Case with Range Checks
  testCaseRanges = (VectorTileLayer, esriRequest) => {
    console.log("üìã TEST 4: Case expression with detailed ranges");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const zoomConfigs = [
        { name: '15z', source: 'coverage_15z', minZoom: 15, maxZoom: 24 }
      ];

      zoomConfigs.forEach(config => {
        const customStyle = {
          version: 8,
          sources: {
            [config.source]: originalStyle.sources[config.source]
          },
          layers: [
            {
              id: `fill_${config.source}`,
              type: 'fill',
              source: config.source,
              'source-layer': 'data',
              minzoom: config.minZoom,
              maxzoom: config.maxZoom,
              paint: {
                'fill-opacity': 0.7,
                'fill-color': [
                  'case',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -135], ['<', ['get', 'rsrp_dbm'], -126]], '#313695',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -126], ['<', ['get', 'rsrp_dbm'], -118]], '#4575B4',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -118], ['<', ['get', 'rsrp_dbm'], -109]], '#74ADD1',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -109], ['<', ['get', 'rsrp_dbm'], -100]], '#ABD9E9',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -100], ['<', ['get', 'rsrp_dbm'], -92]], '#E0F3F8',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -92], ['<', ['get', 'rsrp_dbm'], -83]], '#FFFFBF',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -83], ['<', ['get', 'rsrp_dbm'], -75]], '#FEE090',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -75], ['<', ['get', 'rsrp_dbm'], -66]], '#FDAE61',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -66], ['<', ['get', 'rsrp_dbm'], -57]], '#F46D43',
                  ['all', ['>=', ['get', 'rsrp_dbm'], -57], ['<', ['get', 'rsrp_dbm'], -49]], '#D73027',
                  ['>=', ['get', 'rsrp_dbm'], -49], '#A50026',
                  '#CCCCCC'
                ]
              }
            }
          ]
        };

        console.log(`Case ranges:`, customStyle);

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `Case ${config.name}`
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "‚úÖ Case ranges uygulandƒ±" });
    }).catch(err => {
      this.setState({ message: `‚ùå Case failed: ${err.message}` });
    });
  };

  // TEST 5: Interpolate with Cubic
  testInterpolateCubic = (VectorTileLayer, esriRequest) => {
    console.log("üìã TEST 5: Interpolate with cubic-bezier");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const zoomConfigs = [
        { name: '15z', source: 'coverage_15z', minZoom: 15, maxZoom: 24 }
      ];

      zoomConfigs.forEach(config => {
        const customStyle = {
          version: 8,
          sources: {
            [config.source]: originalStyle.sources[config.source]
          },
          layers: [
            {
              id: `fill_${config.source}`,
              type: 'fill',
              source: config.source,
              'source-layer': 'data',
              minzoom: config.minZoom,
              maxzoom: config.maxZoom,
              paint: {
                'fill-opacity': 0.7,
                'fill-color': [
                  'interpolate',
                  ['cubic-bezier', 0.42, 0, 0.58, 1],
                  ['get', 'rsrp_dbm'],
                  -135, '#313695',
                  -126, '#4575B4',
                  -118, '#74ADD1',
                  -109, '#ABD9E9',
                  -100, '#E0F3F8',
                  -92, '#FFFFBF',
                  -83, '#FEE090',
                  -75, '#FDAE61',
                  -66, '#F46D43',
                  -57, '#D73027',
                  -49, '#A50026'
                ]
              }
            }
          ]
        };

        console.log(`Interpolate cubic:`, customStyle);

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `InterpCubic ${config.name}`
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "‚úÖ Interpolate cubic uygulandƒ±" });
    }).catch(err => {
      this.setState({ message: `‚ùå Interpolate failed: ${err.message}` });
    });
  };

  render() {
    const { message, currentZoom, currentTest } = this.state;

    return (
      <div style={{ width: "100%", height: "100%", position: "relative" }}>
        <div 
          ref={el => this.mapDiv = el}
          style={{ width: "100%", height: "100%" }}
        />

        {/* Test Control Panel */}
        <div style={{
          position: "absolute",
          top: "10px",
          right: "10px",
          background: "rgba(0,0,0,0.95)",
          color: "white",
          padding: "15px",
          borderRadius: "8px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "12px",
          maxWidth: "280px"
        }}>
          <div style={{ marginBottom: "12px", fontWeight: "bold", color: "#4CAF50" }}>
            üéØ FOCUSED TESTS
          </div>
          
          <div style={{ marginBottom: "10px", padding: "8px", background: "rgba(255,255,255,0.1)", borderRadius: "4px", fontSize: "10px" }}>
            <div>Zoom: {currentZoom}</div>
            <div>Test: {currentTest || "none"}</div>
          </div>

          <button onClick={() => this.applyTest('baseline')} style={{...buttonStyle, background: '#666'}}>
            BASELINE (gri MVT)
          </button>

          <button onClick={() => this.applyTest('step_expression')} style={buttonStyle}>
            1. Step Expression
          </button>

          <button onClick={() => this.applyTest('step_with_cast')} style={buttonStyle}>
            2. Step + Type Cast
          </button>

          <button onClick={() => this.applyTest('match_expression')} style={buttonStyle}>
            3. Match Expression
          </button>

          <button onClick={() => this.applyTest('case_ranges')} style={buttonStyle}>
            4. Case + Ranges
          </button>

          <button onClick={() => this.applyTest('interpolate_cubic')} style={buttonStyle}>
            5. Interpolate Cubic
          </button>

          <button 
            onClick={() => {
              this.clearLayers();
              this.setState({ message: "‚úÖ Temizlendi", currentTest: "none" });
            }} 
            style={{...buttonStyle, background: "#f44336", marginTop: "10px"}}
          >
            üóëÔ∏è Clear
          </button>
        </div>

        {/* Status Panel */}
        <div style={{
          position: "absolute",
          bottom: "10px",
          left: "10px",
          background: "rgba(0,0,0,0.9)",
          color: "white",
          padding: "10px",
          borderRadius: "5px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "11px",
          maxWidth: "300px"
        }}>
          <div style={{ color: "#4CAF50" }}>{message}</div>
        </div>
      </div>
    );
  }
}

const buttonStyle = {
  width: "100%",
  padding: "10px 8px",
  marginBottom: "5px",
  background: "#2196F3",
  color: "white",
  border: "none",
  borderRadius: "4px",
  cursor: "pointer",
  fontSize: "11px",
  textAlign: "left" as const,
  fontFamily: "monospace"
};
