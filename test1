/** @jsx jsx */
import { React, jsx } from "jimu-core";

// API Configuration
const MVT_STYLE_URL = "url/vector/styles/all/style.json?coverageLayer=rsrp_dbm";
const MANUAL_BEARER = "token";
const ARCGIS_API_VERSION = "4.32";

interface State {
  message: string;
}

export default class Widget extends React.PureComponent<any, State> {
  private mapDiv: HTMLDivElement;
  private mapView: any;

  constructor(props) {
    super(props);
    this.state = {
      message: "Widget y√ºkleniyor..."
    };
  }

  componentDidMount() {
    this.loadArcGISAPI();
  }

  componentWillUnmount() {
    if (this.mapView) {
      this.mapView.destroy();
    }
  }

  loadArcGISAPI = () => {
    this.setState({ message: "üì¶ ArcGIS API y√ºkleniyor..." });

    const cssLink = document.createElement("link");
    cssLink.rel = "stylesheet";
    cssLink.href = `https://js.arcgis.com/${ARCGIS_API_VERSION}/esri/themes/dark/main.css`;
    document.head.appendChild(cssLink);

    const script = document.createElement("script");
    script.src = `https://js.arcgis.com/${ARCGIS_API_VERSION}/`;
    script.onload = () => {
      this.setState({ message: "‚úÖ ArcGIS API y√ºklendi" });
      this.createMap();
    };
    document.head.appendChild(script);
  };

  createMap = () => {
    this.setState({ message: "üó∫Ô∏è Map olu≈üturuluyor..." });

    (window as any).require([
      'esri/Map',
      'esri/views/MapView',
      'esri/layers/VectorTileLayer',
      'esri/request'
    ], (Map, MapView, VectorTileLayer, esriRequest) => {
      
      const map = new Map({
        basemap: 'dark-gray-vector'
      });

      this.mapView = new MapView({
        container: this.mapDiv,
        map: map,
        center: [32, 39],
        zoom: 6
      });

      this.setState({ message: "‚úÖ Map olu≈üturuldu! MVT y√ºkleniyor..." });

      esriRequest(MVT_STYLE_URL, {
        headers: {
          'Authorization': `Bearer ${MANUAL_BEARER}`
        },
        responseType: 'json'
      }).then(response => {
        const styleJson = response.data;
        
        console.log("========== FULL STYLE JSON ==========");
        console.log(JSON.stringify(styleJson, null, 2));
        console.log("=====================================");
        console.log("Sources:", styleJson.sources);
        console.log("Layers:", styleJson.layers);
        console.log("Version:", styleJson.version);
        console.log("Glyphs:", styleJson.glyphs);
        console.log("Sprite:", styleJson.sprite);

        // Fix for visual artifacts (black lines / gaps) and missing quality
        try {
            const newLayers: any[] = [];
            (styleJson.layers || []).forEach(layer => {
                newLayers.push(layer);
                // Check for fill layers that might miss a line outline
                // Identify them by 'vis_mvt_' prefix or just being a fill layer with 'coverage_' source
                if (layer.type === 'fill' && layer.source && typeof layer.id === 'string' && layer.id.startsWith('vis_mvt_')) {
                    const lineId = `${layer.id}_line`;
                    // Check if line layer exists in original layers
                    const lineExists = (styleJson.layers as any[]).some(l => l.id === lineId);
                    
                    if (!lineExists) {
                        console.log(`Running auto-patch: Creating missing line layer for ${layer.id}`);
                        const lineLayer = JSON.parse(JSON.stringify(layer));
                        lineLayer.id = lineId;
                        lineLayer.type = 'line';
                        
                        // Transform paint properties
                        const fillColor = lineLayer.paint['fill-color'];
                        const fillOpacity = lineLayer.paint['fill-opacity'];
                        
                        lineLayer.paint = {
                            'line-color': fillColor,
                            'line-width': 1, // Add outline to fix tile gaps/black lines
                            'line-opacity': fillOpacity || 0.5
                        };
                        
                        // Ensure layout property exists
                        if (!lineLayer.layout) lineLayer.layout = {};
                        lineLayer.layout.visibility = 'visible';

                        // Remove fill-specific props
                        delete lineLayer.paint['fill-outline-color'];
                        delete lineLayer.paint['fill-color'];
                        delete lineLayer.paint['fill-opacity'];
                        
                        newLayers.push(lineLayer);
                    }
                }
            });
            styleJson.layers = newLayers;
        } catch(e) {
            console.error("Error patching style:", e);
        }

        this.setState({ message: "üìÑ Style JSON alƒ±ndƒ± (ve patchlendi)" });

        // Tile fetch i√ßin intercept
        const originalFetch = window.fetch;
        window.fetch = (url, options = {}) => {
          const urlStr = url.toString();
          if (urlStr.includes(new URL(MVT_STYLE_URL).hostname)) {
            return originalFetch(url, {
              ...options,
              headers: {
                ...(options['headers'] || {}),
                'Authorization': `Bearer ${MANUAL_BEARER}`
              }
            });
          }
          return originalFetch(url, options);
        };

        const mvtLayer = new VectorTileLayer({
          style: styleJson
        });

        mvtLayer.when(() => {
          this.setState({ message: "‚úÖ MVT Layer loaded" });
          console.log("Layer loaded, current style:", mvtLayer.currentStyleInfo);
        }).catch(err => {
          this.setState({ message: `‚ùå Layer error: ${err.message}` });
          console.error(err);
        });

        map.add(mvtLayer);
        
      }).catch(err => {
        this.setState({ message: `‚ùå ${err.message}` });
        console.error(err);
      });
    });
  };

  render() {
    const { message } = this.state;

    return (
      <div style={{ width: "100%", height: "100%", position: "relative" }}>
        <div 
          ref={el => this.mapDiv = el}
          style={{ width: "100%", height: "100%" }}
        />

        <div style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          background: "rgba(0,0,0,0.8)",
          color: "white",
          padding: "15px",
          borderRadius: "5px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "12px"
        }}>
          <strong>MVT Widget:</strong>
          <div style={{ marginTop: "10px" }}>{message}</div>
        </div>
      </div>
    );
  }
}
