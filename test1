getAdjustedBounds = ({ data, pixelWidth, pixelHeight }) => {
    const statistics = data.statistics
    const minX = 0
    //get min max from ground statistics
    let maxX = statistics.maxDistance
    maxX = convertSingle(maxX, data.effectiveUnits.distance, this.props.selectedLinearUnit)
    let minY = statistics.minElevation
    minY = convertSingle(minY, data.effectiveUnits.elevation, this.props.selectedElevationUnit)
    let maxY = statistics.maxElevation
    maxY = convertSingle(maxY, data.effectiveUnits.elevation, this.props.selectedElevationUnit)
    
    //calculate min max based on all the profiles (TOWER SCALING DAHƒ∞L)
    for (const layerId in this._minMaxOfEachProfile) {
      if (this._minMaxOfEachProfile[layerId].max > maxY) {
        maxY = this._minMaxOfEachProfile[layerId].max
      }
      if (this._minMaxOfEachProfile[layerId].min < minY) {
        minY = this._minMaxOfEachProfile[layerId].min
      }
    }

    // YENƒ∞ EKLENEN: TOWER DATA SCALING
    if (this.props.towerData && this.props.towerData.length > 0) {
      console.log('üóº Including tower data in chart scaling...')
      
      this.props.towerData.forEach(tower => {
        // Tower top elevation'larƒ± scaling'e dahil et
        const towerTopElevation = convertSingle(tower.totalElevation, this.props.profileResult.effectiveUnits.elevation, this.props.selectedElevationUnit)
        const terrainElevation = convertSingle(tower.terrainElevation, this.props.profileResult.effectiveUnits.elevation, this.props.selectedElevationUnit)
        
        if (towerTopElevation > maxY) {
          maxY = towerTopElevation
          console.log(`üóº Updated maxY to ${maxY.toFixed(1)} from tower at ${tower.distance.toFixed(1)}m`)
        }
        
        if (terrainElevation < minY) {
          minY = terrainElevation
        }
      })

      // Arrow layer i√ßin ekstra padding (tower'larƒ±n √ºzerinde olacak)
      if (this.props.towerData.length >= 2) {
        const arrowPadding = convertSingle(50, 'meters', this.props.selectedElevationUnit) // 50m extra padding
        maxY += arrowPadding
        console.log(`‚ÜîÔ∏è Added arrow padding: ${arrowPadding.toFixed(1)} units. New maxY: ${maxY.toFixed(1)}`)
      }
    }

    // Make sure our ranges are not too small.
    const rangeX = Math.max(maxX - minX, 0.001)
    let rangeY = Math.max(maxY - minY, 0.001)

    if (data.dynamicElevationRange) {
      // Convert to elevation units so that all values are compatible.
      const rangeXInElevationUnits = convertSingle(rangeX, this.props.selectedLinearUnit, this.props.selectedElevationUnit)
      // Make sure the Y axis is not too small in relation to the X axis.
      rangeY = Math.max(rangeY, rangeXInElevationUnits / 300)
    }

    // Apply some padding at the top and bottom so the chart lines don't align with the axes.
    minY = minY - 0.05 * rangeY // Biraz daha padding
    maxY = minY + rangeY + 0.1 * rangeY // √ústte daha fazla padding (arrow'lar i√ßin)

    // Adjust the Y axis such that we obtain guides and labels at 'nice' locations.
    const yMinMax = niceScale(minY, maxY, 10)
    rangeY = yMinMax[1] - yMinMax[0]

    console.log(`üìä Final chart bounds: X[${minX.toFixed(1)} - ${(minX + rangeX).toFixed(1)}], Y[${minY.toFixed(1)} - ${(minY + rangeY).toFixed(1)}]`)

    if (this.props.isUniformChartScalingEnable) {
      return this.getUniformBounds({
        bounds: { minX, maxX, minY, maxY },
        pixelWidth,
        pixelHeight,
        centered: true
      })
    }

    return {
      minX,
      maxX: minX + rangeX,
      minY,
      maxY: minY + rangeY
    }
  }
