import { React, AllWidgetProps } from 'jimu-core'
import { JimuMapViewComponent, JimuMapView } from 'jimu-arcgis'
import { Button, Icon } from 'jimu-ui'
import Graphic from 'esri/Graphic'
import GraphicsLayer from 'esri/layers/GraphicsLayer'
import Point from 'esri/geometry/Point'
import Polyline from 'esri/geometry/Polyline'
import SimpleLineSymbol from 'esri/symbols/SimpleLineSymbol'
import SimpleMarkerSymbol from 'esri/symbols/SimpleMarkerSymbol'
import TextSymbol from 'esri/symbols/TextSymbol'
import * as geometryEngine from 'esri/geometry/geometryEngine'

interface WidgetState {
  isActive: boolean
  centerPoint: Point | null
  isDragging: boolean
  currentAngle: number
  measurements: Array<{
    angle: number
    bearing: string
    distance?: number
  }>
}

export default class ProtractorWidget extends React.PureComponent<AllWidgetProps<any>, WidgetState> {
  private mapView: __esri.MapView | __esri.SceneView = null
  private graphicsLayer: GraphicsLayer = null
  private clickHandler: __esri.Handle = null
  private pointerMoveHandler: __esri.Handle = null
  private pointerUpHandler: __esri.Handle = null

  constructor(props) {
    super(props)
    this.state = {
      isActive: false,
      centerPoint: null,
      isDragging: false,
      currentAngle: 0,
      measurements: []
    }
  }

  componentDidMount() {
    this.initializeGraphicsLayer()
  }

  componentWillUnmount() {
    this.deactivateProtractor()
  }

  private initializeGraphicsLayer = () => {
    this.graphicsLayer = new GraphicsLayer({
      id: 'protractor-layer',
      title: 'Telecom Protractor'
    })
  }

  private onActiveViewChange = (jmv: JimuMapView) => {
    if (jmv) {
      this.mapView = jmv.view
      if (this.graphicsLayer && !this.mapView.map.findLayerById('protractor-layer')) {
        this.mapView.map.add(this.graphicsLayer)
      }
    }
  }

  private activateProtractor = () => {
    if (!this.mapView) return

    this.setState({ isActive: true })
    this.mapView.container.style.cursor = 'crosshair'
    
    // Add click handler for placing protractor center
    this.clickHandler = this.mapView.on('click', this.handleMapClick)
  }

  private deactivateProtractor = () => {
    this.setState({ 
      isActive: false, 
      centerPoint: null, 
      isDragging: false,
      currentAngle: 0,
      measurements: []
    })
    
    if (this.mapView) {
      this.mapView.container.style.cursor = 'default'
    }

    // Remove event handlers
    if (this.clickHandler) {
      this.clickHandler.remove()
      this.clickHandler = null
    }
    if (this.pointerMoveHandler) {
      this.pointerMoveHandler.remove()
      this.pointerMoveHandler = null
    }
    if (this.pointerUpHandler) {
      this.pointerUpHandler.remove()
      this.pointerUpHandler = null
    }

    // Clear graphics
    if (this.graphicsLayer) {
      this.graphicsLayer.removeAll()
    }
  }

  private handleMapClick = (event) => {
    const point = new Point({
      longitude: event.mapPoint.longitude,
      latitude: event.mapPoint.latitude,
      spatialReference: this.mapView.spatialReference
    })

    this.setState({ centerPoint: point })
    this.createProtractorBase(point)
    
    // Remove click handler and add drag handlers
    this.clickHandler.remove()
    this.clickHandler = null
    
    this.pointerMoveHandler = this.mapView.on('pointer-move', this.handlePointerMove)
    this.pointerUpHandler = this.mapView.on('click', this.handleAngleMeasurement)
  }

  private createProtractorBase = (centerPoint: Point) => {
    // Clear existing graphics
    this.graphicsLayer.removeAll()

    // Create center point marker
    const centerMarker = new Graphic({
      geometry: centerPoint,
      symbol: new SimpleMarkerSymbol({
        style: 'circle',
        color: [255, 0, 0, 0.8],
        size: '8px',
        outline: {
          color: [255, 255, 255],
          width: 2
        }
      })
    })
    this.graphicsLayer.add(centerMarker)

    // Create north reference line (0 degrees)
    this.createReferenceLine(centerPoint, 0, 'North (0°)', [0, 255, 0, 1])

    // Create base circle for protractor
    this.createProtractorCircle(centerPoint)
  }

  private createReferenceLine = (center: Point, angle: number, label: string, color: number[]) => {
    const distance = 1000 // meters
    const radians = (angle - 90) * Math.PI / 180 // Adjust for north being 0°
    
    const endPoint = new Point({
      longitude: center.longitude + (distance * Math.cos(radians)) / 111320,
      latitude: center.latitude + (distance * Math.sin(radians)) / 110540,
      spatialReference: center.spatialReference
    })

    // Create arrow line
    const line = new Polyline({
      paths: [[
        [center.longitude, center.latitude],
        [endPoint.longitude, endPoint.latitude]
      ]],
      spatialReference: center.spatialReference
    })

    const lineGraphic = new Graphic({
      geometry: line,
      symbol: new SimpleLineSymbol({
        color: color,
        width: 3,
        style: 'solid'
      })
    })
    this.graphicsLayer.add(lineGraphic)

    // Create arrowhead
    this.createArrowhead(endPoint, angle, color)

    // Add label
    const labelPoint = new Point({
      longitude: center.longitude + (distance * 0.7 * Math.cos(radians)) / 111320,
      latitude: center.latitude + (distance * 0.7 * Math.sin(radians)) / 110540,
      spatialReference: center.spatialReference
    })

    const textGraphic = new Graphic({
      geometry: labelPoint,
      symbol: new TextSymbol({
        text: label,
        color: color,
        font: {
          size: 12,
          family: 'Arial'
        },
        haloColor: 'white',
        haloSize: 1
      })
    })
    this.graphicsLayer.add(textGraphic)
  }

  private createArrowhead = (point: Point, angle: number, color: number[]) => {
    const arrowSize = 50 // meters
    const arrowAngle = 30 // degrees
    const radians = (angle - 90) * Math.PI / 180

    // Calculate arrowhead points
    const leftAngle = radians + (arrowAngle * Math.PI / 180)
    const rightAngle = radians - (arrowAngle * Math.PI / 180)

    const leftPoint = new Point({
      longitude: point.longitude - (arrowSize * Math.cos(leftAngle)) / 111320,
      latitude: point.latitude - (arrowSize * Math.sin(leftAngle)) / 110540,
      spatialReference: point.spatialReference
    })

    const rightPoint = new Point({
      longitude: point.longitude - (arrowSize * Math.cos(rightAngle)) / 111320,
      latitude: point.latitude - (arrowSize * Math.sin(rightAngle)) / 110540,
      spatialReference: point.spatialReference
    })

    // Create arrowhead lines
    const leftArrow = new Polyline({
      paths: [[
        [point.longitude, point.latitude],
        [leftPoint.longitude, leftPoint.latitude]
      ]],
      spatialReference: point.spatialReference
    })

    const rightArrow = new Polyline({
      paths: [[
        [point.longitude, point.latitude],
        [rightPoint.longitude, rightPoint.latitude]
      ]],
      spatialReference: point.spatialReference
    })

    this.graphicsLayer.add(new Graphic({
      geometry: leftArrow,
      symbol: new SimpleLineSymbol({
        color: color,
        width: 3,
        style: 'solid'
      })
    }))

    this.graphicsLayer.add(new Graphic({
      geometry: rightArrow,
      symbol: new SimpleLineSymbol({
        color: color,
        width: 3,
        style: 'solid'
      })
    }))
  }

  private createProtractorCircle = (center: Point) => {
    const radius = 1000 // meters
    const segments = 72 // 5-degree increments
    const points = []

    for (let i = 0; i <= segments; i++) {
      const angle = (i * 360 / segments) * Math.PI / 180
      const x = center.longitude + (radius * Math.cos(angle)) / 111320
      const y = center.latitude + (radius * Math.sin(angle)) / 110540
      points.push([x, y])
    }

    const circle = new Polyline({
      paths: [points],
      spatialReference: center.spatialReference
    })

    const circleGraphic = new Graphic({
      geometry: circle,
      symbol: new SimpleLineSymbol({
        color: [128, 128, 128, 0.5],
        width: 1,
        style: 'dash'
      })
    })
    this.graphicsLayer.add(circleGraphic)

    // Add degree markings
    this.addDegreeMarkings(center, radius)
  }

  private addDegreeMarkings = (center: Point, radius: number) => {
    for (let angle = 0; angle < 360; angle += 30) {
      const radians = (angle - 90) * Math.PI / 180
      const x = center.longitude + (radius * 1.1 * Math.cos(radians)) / 111320
      const y = center.latitude + (radius * 1.1 * Math.sin(radians)) / 110540

      const labelPoint = new Point({
        longitude: x,
        latitude: y,
        spatialReference: center.spatialReference
      })

      const bearing = this.getBearingText(angle)
      const textGraphic = new Graphic({
        geometry: labelPoint,
        symbol: new TextSymbol({
          text: `${angle}°\n${bearing}`,
          color: [64, 64, 64],
          font: {
            size: 10,
            family: 'Arial'
          },
          haloColor: 'white',
          haloSize: 1
        })
      })
      this.graphicsLayer.add(textGraphic)
    }
  }

  private handlePointerMove = (event) => {
    if (!this.state.centerPoint) return

    const angle = this.calculateAngle(this.state.centerPoint, event.mapPoint)
    this.setState({ currentAngle: angle })
    
    // Update dynamic line
    this.updateDynamicLine(this.state.centerPoint, event.mapPoint, angle)
  }

  private handleAngleMeasurement = (event) => {
    if (!this.state.centerPoint) return

    const angle = this.calculateAngle(this.state.centerPoint, event.mapPoint)
    const bearing = this.getBearingText(angle)
    const distance = geometryEngine.distance(this.state.centerPoint, event.mapPoint, 'meters')

    // Add measurement to state
    const newMeasurement = {
      angle: angle,
      bearing: bearing,
      distance: Math.round(distance)
    }

    this.setState(prevState => ({
      measurements: [...prevState.measurements, newMeasurement]
    }))

    // Create permanent measurement line
    this.createReferenceLine(
      this.state.centerPoint, 
      angle, 
      `${angle.toFixed(1)}° (${bearing})`, 
      [255, 165, 0, 1]
    )
  }

  private updateDynamicLine = (center: Point, mousePoint: Point, angle: number) => {
    // Remove existing dynamic line
    const existingDynamic = this.graphicsLayer.graphics.find(g => 
      g.attributes && g.attributes.type === 'dynamic'
    )
    if (existingDynamic) {
      this.graphicsLayer.remove(existingDynamic)
    }

    // Create new dynamic line
    const line = new Polyline({
      paths: [[
        [center.longitude, center.latitude],
        [mousePoint.longitude, mousePoint.latitude]
      ]],
      spatialReference: center.spatialReference
    })

    const lineGraphic = new Graphic({
      geometry: line,
      symbol: new SimpleLineSymbol({
        color: [255, 0, 255, 0.8],
        width: 2,
        style: 'solid'
      }),
      attributes: { type: 'dynamic' }
    })
    this.graphicsLayer.add(lineGraphic)
  }

  private calculateAngle = (center: Point, target: Point): number => {
    const deltaX = target.longitude - center.longitude
    const deltaY = target.latitude - center.latitude
    let angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI
    
    // Convert to compass bearing (0° = North)
    angle = (90 - angle) % 360
    if (angle < 0) angle += 360
    
    return angle
  }

  private getBearingText = (angle: number): string => {
    const bearings = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
                     'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']
    const index = Math.round(angle / 22.5) % 16
    return bearings[index]
  }

  private clearMeasurements = () => {
    this.graphicsLayer.removeAll()
    this.setState({ 
      measurements: [],
      centerPoint: null,
      currentAngle: 0
    })
  }

  render() {
    const { isActive, measurements, currentAngle } = this.state

    return (
      <div className="widget-protractor">
        <div style={{ padding: '10px' }}>
          <h4>Telecom Protractor Tool</h4>
          
          <div style={{ marginBottom: '10px' }}>
            <Button 
              type={isActive ? 'danger' : 'primary'}
              onClick={isActive ? this.deactivateProtractor : this.activateProtractor}
              style={{ marginRight: '5px' }}
            >
              {isActive ? 'Deactivate' : 'Activate'} Protractor
            </Button>
            
            <Button 
              type="secondary"
              onClick={this.clearMeasurements}
              disabled={!isActive}
            >
              Clear All
            </Button>
          </div>

          {isActive && (
            <div>
              <p><strong>Instructions:</strong></p>
              <ol style={{ fontSize: '12px', paddingLeft: '20px' }}>
                <li>Click on the map to place protractor center</li>
                <li>Move mouse to see dynamic angle measurement</li>
                <li>Click to record angle measurements</li>
              </ol>

              {currentAngle > 0 && (
                <div style={{ 
                  background: '#f0f0f0', 
                  padding: '8px', 
                  borderRadius: '4px',
                  fontSize: '12px'
                }}>
                  <strong>Current Angle:</strong> {currentAngle.toFixed(1)}° ({this.getBearingText(currentAngle)})
                </div>
              )}
            </div>
          )}

          {measurements.length > 0 && (
            <div style={{ marginTop: '15px' }}>
              <h5>Measurements:</h5>
              <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
                {measurements.map((measurement, index) => (
                  <div key={index} style={{ 
                    fontSize: '11px', 
                    padding: '4px',
                    borderBottom: '1px solid #eee'
                  }}>
                    <strong>#{index + 1}:</strong> {measurement.angle.toFixed(1)}° ({measurement.bearing})
                    {measurement.distance && ` - ${measurement.distance}m`}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <JimuMapViewComponent 
          useMapWidgetId={this.props.useMapWidgetIds?.[0]} 
          onActiveViewChange={this.onActiveViewChange}
        />
      </div>
    )
  }
}
