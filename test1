/** @jsx jsx */
import { React, jsx } from "jimu-core";

const MVT_STYLE_URL = "/styles/all/style.json?coverageLayer=rsrp_dbm";
const MANUAL_BEARER = "token";
const ARCGIS_API_VERSION = "4.32";

interface State {
  message: string;
  currentZoom: number;
  currentTest: string;
}

export default class Widget extends React.PureComponent<any, State> {
  private mapDiv: HTMLDivElement;
  private mapView: any;
  private map: any;
  private currentLayers: any[] = [];
  private animationFrame: number = null;

  constructor(props) {
    super(props);
    this.state = {
      message: "Widget yÃ¼kleniyor...",
      currentZoom: 15,
      currentTest: "none"
    };
  }

  componentDidMount() {
    this.loadArcGISAPI();
  }

  componentWillUnmount() {
    if (this.mapView) {
      this.mapView.destroy();
    }
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
  }

  loadArcGISAPI = () => {
    this.setState({ message: "ğŸ“¦ ArcGIS API yÃ¼kleniyor..." });

    if ((window as any).require) {
      this.setState({ message: "âœ… ArcGIS API yÃ¼klendi" });
      this.createMap();
      return;
    }

    const cssLink = document.createElement("link");
    cssLink.rel = "stylesheet";
    cssLink.href = `https://js.arcgis.com/${ARCGIS_API_VERSION}/esri/themes/dark/main.css`;
    document.head.appendChild(cssLink);

    const script = document.createElement("script");
    script.src = `https://js.arcgis.com/${ARCGIS_API_VERSION}/`;
    script.setAttribute('data-arcgis-api', ARCGIS_API_VERSION);
    script.onload = () => {
      this.setState({ message: "âœ… ArcGIS API yÃ¼klendi" });
      this.createMap();
    };
    script.onerror = () => {
      this.setState({ message: "âŒ ArcGIS API yÃ¼klenemedi" });
    };
    document.head.appendChild(script);
  };

  createMap = () => {
    this.setState({ message: "ğŸ—ºï¸ Map oluÅŸturuluyor..." });

    if (!this.mapDiv) {
      setTimeout(() => this.createMap(), 50);
      return;
    }

    if (!(window as any).require) {
      this.setState({ message: "âŒ ArcGIS API loader bulunamadÄ±" });
      return;
    }

    (window as any).require([
      'esri/Map',
      'esri/views/MapView'
    ], (Map, MapView) => {
      
      this.map = new Map({
        basemap: 'dark-gray-vector'
      });

      this.mapView = new MapView({
        container: this.mapDiv,
        map: this.map,
        center: [32, 39],
        zoom: 15,
        constraints: {
          snapToZoom: false,
          minZoom: 3,
          maxZoom: 22,
          rotationEnabled: false
        }
      });

      this.mapView.watch('zoom', (newZoom) => {
        this.setState({ currentZoom: Math.round(newZoom * 10) / 10 });
      });

      this.setState({ message: "âœ… Map hazÄ±r! Test seÃ§in..." });

      // Setup fetch override for authorization
      const originalFetch = window.fetch;
      window.fetch = (url, options = {}) => {
        const urlStr = url.toString();
        if (urlStr.includes('oauth21') || urlStr.includes('vector/tile')) {
          return originalFetch(url, {
            ...options,
            headers: {
              ...(options['headers'] || {}),
              'Authorization': `Bearer ${MANUAL_BEARER}`
            }
          });
        }
        return originalFetch(url, options);
      };
      
    }, (err) => {
      this.setState({ message: `âŒ Loader error: ${err?.message || err}` });
    });
  };

  clearLayers = () => {
    this.currentLayers.forEach(layer => {
      this.map.remove(layer);
    });
    this.currentLayers = [];
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
  };

  runTest = (testName: string) => {
    this.setState({ currentTest: testName, message: `ğŸ§ª ${testName}` });
    this.clearLayers();

    (window as any).require([
      'esri/layers/VectorTileLayer',
      'esri/request'
    ], (VectorTileLayer, esriRequest) => {

      switch(testName) {
        case 'baseline':
          this.testBaseline(VectorTileLayer, esriRequest);
          break;
        case 'css_filter':
          this.testCSSFilter(VectorTileLayer, esriRequest);
          break;
        case 'blend_modes':
          this.testBlendModes(VectorTileLayer, esriRequest);
          break;
        case 'canvas_manipulation':
          this.testCanvasManipulation(VectorTileLayer, esriRequest);
          break;
        case 'multiple_overlays':
          this.testMultipleOverlays(VectorTileLayer, esriRequest);
          break;
      }
    });
  };

  // BASELINE: Original working (gri MVT)
  testBaseline = (VectorTileLayer, esriRequest) => {
    console.log("ğŸ“‹ BASELINE: Original single-color MVT");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const customStyle = {
        version: 8,
        sources: {
          'coverage_15z': originalStyle.sources['coverage_15z']
        },
        layers: originalStyle.layers.filter(layer => 
          layer.source === 'coverage_15z'
        ).map(layer => ({
          ...layer,
          minzoom: 15,
          maxzoom: 24
        }))
      };

      const layer = new VectorTileLayer({
        style: customStyle,
        minScale: 0,
        maxScale: 0,
        title: 'Baseline'
      });

      this.map.add(layer);
      this.currentLayers.push(layer);
      this.setState({ message: "âœ… Baseline: Gri/beyaz MVT yÃ¼klendi" });

    }).catch(err => {
      this.setState({ message: `âŒ Baseline failed: ${err.message}` });
    });
  };

  // TEST 1: CSS Filter ile renk manipÃ¼lasyonu
  testCSSFilter = (VectorTileLayer, esriRequest) => {
    console.log("ğŸ¨ TEST 1: CSS Filter manipulation");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const customStyle = {
        version: 8,
        sources: {
          'coverage_15z': originalStyle.sources['coverage_15z']
        },
        layers: [{
          id: 'fill_test',
          type: 'fill',
          source: 'coverage_15z',
          'source-layer': 'data',
          minzoom: 15,
          maxzoom: 24,
          paint: {
            'fill-color': '#FFFFFF',
            'fill-opacity': 0.7
          }
        }]
      };

      const layer = new VectorTileLayer({
        style: customStyle,
        minScale: 0,
        maxScale: 0,
        title: 'CSS_Filter'
      });

      layer.when(() => {
        console.log("âœ… Layer loaded, applying CSS filters...");
        
        // MapView container'a CSS filter uygula
        setTimeout(() => {
          const container = this.mapView.container as HTMLElement;
          const canvas = container.querySelector('canvas');
          
          if (canvas) {
            console.log("Canvas found, applying filters...");
            // FarklÄ± CSS filter kombinasyonlarÄ± dene
            canvas.style.filter = 'hue-rotate(180deg) saturate(2) brightness(1.2)';
            this.setState({ message: "âœ… CSS Filter uygulandÄ± (hue-rotate + saturate)" });
          } else {
            console.log("Canvas not found");
            this.setState({ message: "âš ï¸ Canvas bulunamadÄ±" });
          }
        }, 1000);
        
      }).catch(err => {
        console.error("Layer error:", err);
      });

      this.map.add(layer);
      this.currentLayers.push(layer);

    }).catch(err => {
      this.setState({ message: `âŒ CSS Filter failed: ${err.message}` });
    });
  };

  // TEST 2: Blend Modes ile overlap
  testBlendModes = (VectorTileLayer, esriRequest) => {
    console.log("ğŸ¨ TEST 2: Multiple layers with blend modes");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      // FarklÄ± renklerde 3 layer oluÅŸtur, blend mode ile karÄ±ÅŸtÄ±r
      const colors = [
        { color: '#FF0000', opacity: 0.3 },
        { color: '#00FF00', opacity: 0.3 },
        { color: '#0000FF', opacity: 0.3 }
      ];

      colors.forEach((config, idx) => {
        const customStyle = {
          version: 8,
          sources: {
            'coverage_15z': originalStyle.sources['coverage_15z']
          },
          layers: [{
            id: `fill_blend_${idx}`,
            type: 'fill',
            source: 'coverage_15z',
            'source-layer': 'data',
            minzoom: 15,
            maxzoom: 24,
            paint: {
              'fill-color': config.color,
              'fill-opacity': config.opacity
            }
          }]
        };

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `Blend_${idx}`,
          blendMode: 'screen' // multiply, screen, overlay
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: "âœ… Blend modes: 3 renkli layer overlap" });

    }).catch(err => {
      this.setState({ message: `âŒ Blend modes failed: ${err.message}` });
    });
  };

  // TEST 3: Canvas pixel manipulation
  testCanvasManipulation = (VectorTileLayer, esriRequest) => {
    console.log("ğŸ¨ TEST 3: Canvas pixel manipulation");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      const customStyle = {
        version: 8,
        sources: {
          'coverage_15z': originalStyle.sources['coverage_15z']
        },
        layers: [{
          id: 'fill_test',
          type: 'fill',
          source: 'coverage_15z',
          'source-layer': 'data',
          minzoom: 15,
          maxzoom: 24,
          paint: {
            'fill-color': '#FFFFFF',
            'fill-opacity': 1.0
          }
        }]
      };

      const layer = new VectorTileLayer({
        style: customStyle,
        minScale: 0,
        maxScale: 0,
        title: 'Canvas_Manipulation'
      });

      layer.when(() => {
        console.log("âœ… Layer loaded, starting canvas manipulation...");
        
        setTimeout(() => {
          this.manipulateCanvas();
        }, 1500);
        
      });

      this.map.add(layer);
      this.currentLayers.push(layer);
      this.setState({ message: "âœ… Canvas manipulation baÅŸlatÄ±ldÄ±..." });

    }).catch(err => {
      this.setState({ message: `âŒ Canvas manipulation failed: ${err.message}` });
    });
  };

  // Canvas manipulation logic
  manipulateCanvas = () => {
    const container = this.mapView.container as HTMLElement;
    const canvas = container.querySelector('canvas') as HTMLCanvasElement;
    
    if (!canvas) {
      console.log("Canvas not found");
      this.setState({ message: "âš ï¸ Canvas bulunamadÄ±" });
      return;
    }

    console.log("Canvas found, reading pixels...");
    
    try {
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      if (!ctx) {
        console.log("Cannot get 2D context");
        return;
      }

      const width = canvas.width;
      const height = canvas.height;
      
      console.log(`Canvas size: ${width}x${height}`);
      
      // Pixel data'yÄ± oku
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      // Gri tonlarÄ± renkli gradiente Ã§evir
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        
        // EÄŸer beyaz/gri bir pixel ise (MVT)
        if (r > 200 && g > 200 && b > 200 && a > 0) {
          // Gri deÄŸerine gÃ¶re renk ata
          const intensity = (r + g + b) / 3;
          
          if (intensity > 240) {
            data[i] = 255; data[i + 1] = 0; data[i + 2] = 0; // KÄ±rmÄ±zÄ±
          } else if (intensity > 220) {
            data[i] = 255; data[i + 1] = 165; data[i + 2] = 0; // Turuncu
          } else if (intensity > 200) {
            data[i] = 0; data[i + 1] = 255; data[i + 2] = 0; // YeÅŸil
          }
        }
      }
      
      // DeÄŸiÅŸtirilmiÅŸ pixel data'yÄ± geri yaz
      ctx.putImageData(imageData, 0, 0);
      
      console.log("âœ… Pixels manipulated");
      this.setState({ message: "âœ… Canvas pixel'leri deÄŸiÅŸtirildi!" });
      
    } catch (err) {
      console.error("Canvas manipulation error:", err);
      this.setState({ message: `âš ï¸ Canvas manipulation error: ${err.message}` });
    }
  };

  // TEST 4: Multiple color overlays with different opacities
  testMultipleOverlays = (VectorTileLayer, esriRequest) => {
    console.log("ğŸ¨ TEST 4: Multiple overlays with gradient");
    
    esriRequest(MVT_STYLE_URL, {
      headers: { 'Authorization': `Bearer ${MANUAL_BEARER}` },
      responseType: 'json'
    }).then(response => {
      const originalStyle = response.data;

      // Gradient colors
      const gradientColors = [
        '#313695', '#4575B4', '#74ADD1', '#ABD9E9', '#E0F3F8',
        '#FFFFBF', '#FEE090', '#FDAE61', '#F46D43', '#D73027', '#A50026'
      ];

      gradientColors.forEach((color, idx) => {
        const customStyle = {
          version: 8,
          sources: {
            'coverage_15z': originalStyle.sources['coverage_15z']
          },
          layers: [{
            id: `fill_overlay_${idx}`,
            type: 'fill',
            source: 'coverage_15z',
            'source-layer': 'data',
            minzoom: 15,
            maxzoom: 24,
            paint: {
              'fill-color': color,
              'fill-opacity': 0.1
            }
          }]
        };

        const layer = new VectorTileLayer({
          style: customStyle,
          minScale: 0,
          maxScale: 0,
          title: `Overlay_${idx}`,
          opacity: 0.9
        });

        this.map.add(layer);
        this.currentLayers.push(layer);
      });

      this.setState({ message: `âœ… ${gradientColors.length} renkli overlay oluÅŸturuldu` });

    }).catch(err => {
      this.setState({ message: `âŒ Overlays failed: ${err.message}` });
    });
  };

  render() {
    const { message, currentZoom, currentTest } = this.state;

    return (
      <div style={{ width: "100%", height: "100%", position: "relative" }}>
        <div 
          ref={el => this.mapDiv = el}
          style={{ width: "100%", height: "100%" }}
        />

        {/* Test Panel */}
        <div style={{
          position: "absolute",
          top: "10px",
          right: "10px",
          background: "rgba(0,0,0,0.95)",
          color: "white",
          padding: "15px",
          borderRadius: "8px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "11px",
          maxWidth: "280px"
        }}>
          <div style={{ marginBottom: "12px", fontWeight: "bold", color: "#4CAF50" }}>
            ğŸ¨ POST-PROCESS TESTS
          </div>
          
          <div style={{ marginBottom: "10px", padding: "8px", background: "rgba(255,255,255,0.1)", borderRadius: "4px", fontSize: "10px" }}>
            <div>Zoom: {currentZoom}</div>
            <div>Test: {currentTest || "none"}</div>
          </div>

          <button onClick={() => this.runTest('baseline')} style={{...buttonStyle, background: '#666'}}>
            BASELINE (gri MVT)
          </button>

          <button onClick={() => this.runTest('css_filter')} style={buttonStyle}>
            1. CSS Filters
          </button>

          <button onClick={() => this.runTest('blend_modes')} style={buttonStyle}>
            2. Blend Modes
          </button>

          <button onClick={() => this.runTest('canvas_manipulation')} style={buttonStyle}>
            3. Canvas Pixels
          </button>

          <button onClick={() => this.runTest('multiple_overlays')} style={buttonStyle}>
            4. Multiple Overlays
          </button>

          <button 
            onClick={() => {
              this.clearLayers();
              this.setState({ message: "âœ… Temizlendi", currentTest: "none" });
            }} 
            style={{...buttonStyle, background: "#f44336", marginTop: "10px"}}
          >
            ğŸ—‘ï¸ Clear
          </button>

          <div style={{ fontSize: "9px", color: "#aaa", marginTop: "10px", lineHeight: "1.3" }}>
            ğŸ’¡ 1: CSS filter (hue-rotate)<br/>
            ğŸ’¡ 2: RGB overlay blend<br/>
            ğŸ’¡ 3: Direct pixel edit<br/>
            ğŸ’¡ 4: Gradient overlays
          </div>
        </div>

        {/* Status */}
        <div style={{
          position: "absolute",
          bottom: "10px",
          left: "10px",
          background: "rgba(0,0,0,0.9)",
          color: "white",
          padding: "12px",
          borderRadius: "5px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "10px",
          maxWidth: "350px"
        }}>
          <div style={{ color: "#4CAF50" }}>{message}</div>
        </div>
      </div>
    );
  }
}

const buttonStyle = {
  width: "100%",
  padding: "10px 8px",
  marginBottom: "5px",
  background: "#2196F3",
  color: "white",
  border: "none",
  borderRadius: "4px",
  cursor: "pointer",
  fontSize: "11px",
  textAlign: "left" as const,
  fontFamily: "monospace"
};
