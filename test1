-----nlp 

/** @jsx jsx */
import { React, jsx, AllWidgetProps } from 'jimu-core';
import { JimuMapViewComponent, JimuMapView } from 'jimu-arcgis';
import { Button, TextInput, Select, Option, Label, Alert } from 'jimu-ui';
import './style.css';

type MessageAuthor = 'user' | 'bot' | 'clarification';

type FeatureLayerField = { name: string; alias?: string; type: string };

type FeatureLayer = {
	id: string;
	title: string;
	url: string;
	type?: string;
	fields?: FeatureLayerField[];
	createQuery?: () => any;
	queryFeatures?: (query: any) => Promise<{ features: any[] }>;
	definitionExpression?: string;
	visible?: boolean;
};

interface ChatMessage {
	type: MessageAuthor;
	text: string;
	timestamp: Date;
	data?: unknown;
}

interface FieldMetadata {
	name: string;
	alias: string;
	type: string;
	nameTokens: string[];
	synonyms?: string[];
}

interface LayerMetadata {
	id: string;
	title: string;
	url: string;
	queryLayer: FeatureLayer;
	fields: FieldMetadata[];
	titleTokens: string[];
	path: string[];
	applyDefinitionExpression?: (whereClause: string | null) => void;
	setVisible?: (visible: boolean) => void;
}

type ClarificationContext = 'layer' | 'value' | 'field';

interface ClarificationOption {
	label: string;
	value: string;
	field?: string;
	context?: ClarificationContext;
	metadata?: any;
}

interface MatchedField {
	field: FieldMetadata;
	token: string;
	type: 'exact' | 'partial' | 'token' | 'alias' | 'synonym';
	confidence: number;
}

type OperatorInfo = { 
	type: '>' | '<' | '=' | '>=' | '<=' | '!=' | 'BETWEEN' | 'IN' | 'LIKE' | 'IS NULL' | 'IS NOT NULL';
	confidence: number;
};

type LogicalOperator = 'AND' | 'OR' | 'NOT';

type DateInfo =
	| { type: 'year'; value: number }
	| { type: 'month-year'; year: number; month: string }
	| { type: 'full-date'; year: number; month: string; day: string }
	| { type: 'relative'; unit: 'day' | 'week' | 'month' | 'year'; offset: number };

interface QueryIntent {
	action: 'filter' | 'find' | 'show' | 'search' | 'display' | 'list' | 'count' | 'clear';
	confidence: number;
}

interface ParsedCondition {
	field?: string;
	operator?: string;
	value?: string | number | null;
	raw: string;
	confidence: number;
	negated?: boolean;
}

interface SemanticContext {
	hasLocation: boolean;
	hasTimeReference: boolean;
	hasComparison: boolean;
	hasAggregation: boolean;
	isQuestion: boolean;
	suggestedFieldTypes: Set<string>;
}

interface ParsedMessage {
	original: string;
	normalized: string;
	tokens: string[];
	potentialFields: string[];
	dates: DateInfo[];
	numbers: number[];
	operators: OperatorInfo[];
	logicalOperators: LogicalOperator[];
	conditions: ParsedCondition[];
	freeText: string[];
	intent: QueryIntent;
	context: SemanticContext;
	entities: Map<string, any>;
}

interface LayerMatch {
	layer: LayerMetadata;
	score: number;
	matchedFields: MatchedField[];
	confidence: number;
}

interface PendingQuery {
	parsed: ParsedMessage;
	layerMatch: LayerMatch | null;
	field?: FieldMetadata;
	candidateLayers?: LayerMatch[];
	candidateFields?: Array<{ field: FieldMetadata; layer: LayerMetadata }>;
}

interface QueryDebugInfo {
	layerId: string;
	layerTitle: string;
	whereClause: string;
	matchedFields: string[];
	textTokens: string[];
	numbers: number[];
	operators: string[];
	dates: string[];
	rawMessage: string;
	selectedField?: string;
	selectedValue?: string;
}

type MatchSuccess = { type: 'success'; condition: string };
type MatchClarification = { type: 'clarification'; options: ClarificationOption[] };
type MatchFallback = { type: 'fallback' };
type MatchResult = MatchSuccess | MatchClarification | MatchFallback;

type ProcessResult =
	| { type: 'success'; metadata: LayerMetadata; layerTitle: string; whereClause: string; debugInfo: QueryDebugInfo }
	| { type: 'clarification'; options: ClarificationOption[]; pendingQuery: PendingQuery }
	| { type: 'error'; message: string };

const NUMERIC_FIELD_TYPES = new Set([
	'double', 'single', 'integer', 'small-integer', 'smallinteger',
	'short-integer', 'shortinteger', 'long', 'float', 'oid',
]);

const STRING_FIELD_TYPES = new Set(['string', 'guid', 'global-id', 'globalid']);

// Enhanced field name synonyms for common patterns
const FIELD_SYNONYMS: Record<string, string[]> = {
	'rsrp': ['signal', 'power', 'strength', 'reception'],
	'rsrq': ['quality', 'signal_quality'],
	'snr': ['noise', 'ratio', 'signal_noise'],
	'latitude': ['lat', 'y', 'northing'],
	'longitude': ['lon', 'lng', 'x', 'easting'],
	'status': ['state', 'condition', 'situation'],
	'type': ['category', 'class', 'kind'],
	'date': ['time', 'timestamp', 'when', 'datetime'],
	'name': ['title', 'label', 'identifier'],
	'id': ['identifier', 'key', 'code'],
	'count': ['number', 'total', 'quantity', 'amount'],
	'area': ['region', 'zone', 'location', 'place'],
};

// Operator synonyms for natural language
const OPERATOR_PATTERNS: Array<{ pattern: RegExp; operator: string; confidence: number }> = [
	{ pattern: /\b(greater|more|above|over|higher|larger|bigger)\s+(than|to)?\b/i, operator: '>', confidence: 0.9 },
	{ pattern: /\b(less|fewer|below|under|lower|smaller)\s+(than|to)?\b/i, operator: '<', confidence: 0.9 },
	{ pattern: /\b(equal|equals|exactly|precisely|is)\s+(to)?\b/i, operator: '=', confidence: 0.85 },
	{ pattern: /\b(not\s+equal|not\s+equals|different|!=|<>)\s+(to)?\b/i, operator: '!=', confidence: 0.9 },
	{ pattern: /\b(at\s+least|minimum|min|>=|‚â•)\b/i, operator: '>=', confidence: 0.85 },
	{ pattern: /\b(at\s+most|maximum|max|<=|‚â§)\b/i, operator: '<=', confidence: 0.85 },
	{ pattern: /\b(between)\b/i, operator: 'BETWEEN', confidence: 0.95 },
	{ pattern: /\b(contains|includes|has|like)\b/i, operator: 'LIKE', confidence: 0.8 },
	{ pattern: /\b(is\s+null|null|empty|missing|blank)\b/i, operator: 'IS NULL', confidence: 0.9 },
	{ pattern: /\b(is\s+not\s+null|not\s+null|exists|present|has\s+value)\b/i, operator: 'IS NOT NULL', confidence: 0.9 },
	{ pattern: />=/i, operator: '>=', confidence: 1.0 },
	{ pattern: /<=/i, operator: '<=', confidence: 1.0 },
	{ pattern: /!=/i, operator: '!=', confidence: 1.0 },
	{ pattern: /<>/i, operator: '!=', confidence: 1.0 },
	{ pattern: />/i, operator: '>', confidence: 1.0 },
	{ pattern: /</i, operator: '<', confidence: 1.0 },
	{ pattern: /=/i, operator: '=', confidence: 1.0 },
];

// Intent patterns
const INTENT_PATTERNS: Array<{ pattern: RegExp; action: string; confidence: number }> = [
	{ pattern: /\b(filter|where|with|having)\b/i, action: 'filter', confidence: 0.9 },
	{ pattern: /\b(find|search|look\s+for|locate)\b/i, action: 'find', confidence: 0.9 },
	{ pattern: /\b(show|display|view|see|list)\b/i, action: 'show', confidence: 0.85 },
	{ pattern: /\b(count|how\s+many|number\s+of)\b/i, action: 'count', confidence: 0.9 },
	{ pattern: /\b(clear|reset|remove\s+filter)\b/i, action: 'clear', confidence: 0.95 },
];

const normalizeFieldType = (fieldType: string): string => fieldType?.toLowerCase?.() ?? '';
const isNumericFieldType = (fieldType: string): boolean => NUMERIC_FIELD_TYPES.has(normalizeFieldType(fieldType));
const isDateFieldType = (fieldType: string): boolean => normalizeFieldType(fieldType) === 'date';
const isStringFieldType = (fieldType: string): boolean => STRING_FIELD_TYPES.has(normalizeFieldType(fieldType));

interface State {
	message: string;
	chatHistory: ChatMessage[];
	loading: boolean;
	jimuMapView: JimuMapView | null;
	layerCache: LayerMetadata[];
	clarificationNeeded: boolean;
	clarificationOptions: ClarificationOption[];
	pendingQuery: PendingQuery | null;
	connectionStatus: 'idle' | 'connecting' | 'ready' | 'error';
	statusMessage: string;
	lastFilters: Map<string, string>;
}

export default class SmartFilterWidget extends React.PureComponent<AllWidgetProps<any>, State> {
	private levenshteinCache: Map<string, Map<string, number>> = new Map();

	constructor(props: AllWidgetProps<any>) {
		super(props);
		this.state = {
			message: '',
			chatHistory: [],
			loading: false,
			jimuMapView: null,
			layerCache: [],
			clarificationNeeded: false,
			clarificationOptions: [],
			pendingQuery: null,
			connectionStatus: 'idle',
			statusMessage: 'Select a map in the widget settings to connect.',
			lastFilters: new Map(),
		};
	}

	// Levenshtein distance for fuzzy string matching
	levenshteinDistance = (str1: string, str2: string): number => {
		const key = `${str1}:${str2}`;
		
		if (!this.levenshteinCache.has(str1)) {
			this.levenshteinCache.set(str1, new Map());
		}
		
		const cache = this.levenshteinCache.get(str1)!;
		if (cache.has(str2)) {
			return cache.get(str2)!;
		}

		const m = str1.length;
		const n = str2.length;
		const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

		for (let i = 0; i <= m; i++) dp[i][0] = i;
		for (let j = 0; j <= n; j++) dp[0][j] = j;

		for (let i = 1; i <= m; i++) {
			for (let j = 1; j <= n; j++) {
				if (str1[i - 1] === str2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(
						dp[i - 1][j] + 1,
						dp[i][j - 1] + 1,
						dp[i - 1][j - 1] + 1
					);
				}
			}
		}

		const distance = dp[m][n];
		cache.set(str2, distance);
		return distance;
	};

	// Compute similarity score (0 to 1)
	computeSimilarity = (str1: string, str2: string): number => {
		const maxLen = Math.max(str1.length, str2.length);
		if (maxLen === 0) return 1.0;
		const distance = this.levenshteinDistance(str1, str2);
		return 1 - (distance / maxLen);
	};

	// Enhanced tokenization with stemming
	tokenizeWithStemming = (text: string): string[] => {
		const tokens = text.toLowerCase()
			.replace(/[^\w\s-]/g, ' ')
			.split(/\s+/)
			.filter(t => t.length > 1);

		// Simple stemming rules
		return tokens.map(token => {
			// Remove common suffixes
			if (token.endsWith('ing')) return token.slice(0, -3);
			if (token.endsWith('ed')) return token.slice(0, -2);
			if (token.endsWith('s') && token.length > 3) return token.slice(0, -1);
			return token;
		});
	};

	onActiveViewChange = async (jimuMapView: JimuMapView) => {
		if (!jimuMapView) {
			this.setState({
				jimuMapView: null,
				layerCache: [],
				connectionStatus: 'idle',
				statusMessage: 'No map selected. Choose a map from the widget settings.',
			});
			return;
		}

		this.setState({
			jimuMapView,
			loading: true,
			connectionStatus: 'connecting',
			statusMessage: 'Loading layer information...'
		});

		try {
			const layerCache = await this.discoverLayers(jimuMapView);

			if (layerCache.length === 0) {
				this.setState({
					loading: false,
					connectionStatus: 'error',
					statusMessage: 'No feature layers found in the selected map.',
				});
				this.addBotMessage('‚ö†Ô∏è No feature layers were found in the selected map.');
				return;
			}

			this.setState({
				loading: false,
				connectionStatus: 'ready',
				statusMessage: `Ready. ${layerCache.length} layer(s) indexed.`,
			});
			this.addBotMessage(`‚úÖ Connected! I found ${layerCache.length} layer(s). Try queries like:\n‚Ä¢ "rsrp < -110"\n‚Ä¢ "show New York data from 2024"\n‚Ä¢ "filter active status"`);
		} catch (error) {
			const messageText = error instanceof Error ? error.message : 'Unknown error';
			this.setState({
				loading: false,
				connectionStatus: 'error',
				statusMessage: `Failed to load layer metadata: ${messageText}`,
			});
			this.addBotMessage(`‚ùå Unable to load layer metadata: ${messageText}`);
		}
	};

	discoverLayers = async (jimuMapView: JimuMapView): Promise<LayerMetadata[]> => {
		const view = jimuMapView?.view;

		if (!view?.map) {
			this.setState({ layerCache: [] });
			return [];
		}

		const layerCache: LayerMetadata[] = [];

		const toArray = (collection: any): any[] => {
			if (!collection) return [];
			if (typeof collection.toArray === 'function') return collection.toArray();
			return Array.isArray(collection) ? collection : [];
		};

		const tokenizeTitlePath = (path: string[]): string[] =>
			path.flatMap((segment) =>
				String(segment)
					.toLowerCase()
					.split(/[\s_>‚Ä∫/-]+/)
					.filter((token) => token.length > 0)
			);

		const inferSynonyms = (fieldName: string): string[] => {
			const normalized = fieldName.toLowerCase();
			const synonyms: string[] = [];

			// Check predefined synonyms
			for (const [key, values] of Object.entries(FIELD_SYNONYMS)) {
				if (normalized.includes(key) || values.some(v => normalized.includes(v))) {
					synonyms.push(key, ...values);
				}
			}

			// Add common abbreviations
			if (normalized.length > 4) {
				synonyms.push(normalized.slice(0, 3)); // First 3 chars
			}

			return [...new Set(synonyms)];
		};

		const collectFeatureLayer = async (
			featureLayer: FeatureLayer,
			titlePath: string[],
			options: { 
				sourceId?: string; 
				applyDefinitionExpression?: (whereClause: string | null) => void;
				setVisible?: (visible: boolean) => void;
			} = {},
		) => {
			try {
				if (typeof (featureLayer as any).load === 'function') {
					await (featureLayer as any).load();
				} else if (typeof (featureLayer as any).when === 'function') {
					await (featureLayer as any).when();
				}
			} catch (error) {
				console.warn('Failed to load layer metadata.', featureLayer?.title ?? options.sourceId, error);
			}

			const fieldsSource = Array.isArray(featureLayer.fields) ? featureLayer.fields : [];
			const fields: FieldMetadata[] = fieldsSource
				.filter((field: any) => field && field.name)
				.map((field: any) => {
					const name = String(field.name);
					const alias = field.alias ? String(field.alias) : name;
					const type = normalizeFieldType(field.type);
					return {
						name,
						alias,
						type,
						nameTokens: name.toLowerCase().split(/[_\s]+/),
						synonyms: inferSynonyms(name),
					};
				});

			if (fields.length === 0) return;

			const titlePathClean = titlePath.filter((segment) => segment && segment.trim().length > 0);
			const title = titlePathClean.length > 0 ? titlePathClean.join(' ‚Ä∫ ') : featureLayer.title ?? options.sourceId ?? 'Layer';
			const idCandidateOrder = [options.sourceId, featureLayer.id, featureLayer.url, title];
			let id = idCandidateOrder.find((value) => typeof value === 'string' && value.trim().length > 0) ?? `layer-${layerCache.length}-${Date.now()}`;
			if (layerCache.some((cachedLayer) => cachedLayer.id === id)) {
				id = `${id}-${layerCache.length}`;
			}

			const applyDefinitionExpression = options.applyDefinitionExpression ?? 
				((whereClause: string | null) => {
					featureLayer.definitionExpression = whereClause ?? '1=1';
				});

			const setVisible = options.setVisible ?? 
				((visible: boolean) => {
					if ('visible' in featureLayer) {
						(featureLayer as any).visible = visible;
					}
				});

			layerCache.push({
				id,
				title,
				url: featureLayer.url,
				queryLayer: featureLayer,
				fields,
				titleTokens: tokenizeTitlePath(titlePathClean),
				path: titlePathClean,
				applyDefinitionExpression,
				setVisible,
			});
		};

		const traverseSublayer = async (sublayer: any, parentTitles: string[], parentLayer: any) => {
			const sublayerTitle = String(
				sublayer?.title && sublayer.title.trim().length > 0
					? sublayer.title
					: sublayer?.name ?? sublayer?.id ?? 'Sublayer',
			);
			const titlePath = [...parentTitles, sublayerTitle];
			let featureLayer: FeatureLayer | null = null;

			if (typeof sublayer.createFeatureLayer === 'function') {
				try {
					const result = sublayer.createFeatureLayer();
					featureLayer = typeof (result as any)?.then === 'function' ? await result : result;
				} catch (error) {
					console.warn('Unable to create feature layer from sublayer.', titlePath.join(' ‚Ä∫ '), error);
				}
			} else if (sublayer?.layer?.type === 'feature') {
				featureLayer = sublayer.layer as FeatureLayer;
			}

			if (featureLayer) {
				await collectFeatureLayer(featureLayer, titlePath, {
					sourceId: `${parentLayer?.id ?? parentLayer?.uid ?? 'layer'}-${sublayer.id ?? sublayer.uid ?? sublayerTitle}`,
					applyDefinitionExpression: (whereClause: string | null) => {
						if ('definitionExpression' in sublayer) {
							sublayer.definitionExpression = whereClause ?? '1=1';
						}
					},
					setVisible: (visible: boolean) => {
						if ('visible' in sublayer) sublayer.visible = visible;
						if ('visible' in parentLayer) parentLayer.visible = visible;
					},
				});
			}

			const childSublayers = toArray(sublayer?.sublayers ?? sublayer?.subLayers);
			for (const childSublayer of childSublayers) {
				await traverseSublayer(childSublayer, titlePath, parentLayer);
			}
		};

		const traverseLayer = async (layer: any, parentTitles: string[] = []) => {
			const layerTitle = String(layer?.title ?? layer?.name ?? layer?.id ?? 'Layer');
			const titlePath = [...parentTitles, layerTitle];

			if (layer?.type === 'feature') {
				await collectFeatureLayer(layer as FeatureLayer, titlePath, {
					sourceId: layer.id ?? layer.uid ?? layerTitle,
					applyDefinitionExpression: (whereClause: string | null) => {
						(layer as FeatureLayer).definitionExpression = whereClause ?? '1=1';
					},
					setVisible: (visible: boolean) => {
						if ('visible' in layer) layer.visible = visible;
					},
				});
			}

			const sublayers = toArray(layer?.sublayers ?? layer?.subLayers);
			for (const sublayer of sublayers) {
				await traverseSublayer(sublayer, titlePath, layer);
			}

			const childLayers = toArray(layer?.layers);
			for (const childLayer of childLayers) {
				await traverseLayer(childLayer, titlePath);
			}
		};

		const allLayers = toArray(view.map.allLayers);
		for (const layer of allLayers) {
			await traverseLayer(layer);
		}

		this.setState({ layerCache });
		return layerCache;
	};

	handleSendMessage = async () => {
		const { message, layerCache, connectionStatus } = this.state;

		if (!message.trim()) return;

		if (connectionStatus !== 'ready') {
			this.addBotMessage('‚ö†Ô∏è The map connection is not ready yet. Select a map and wait for the layers to load.');
			return;
		}

		if (layerCache.length === 0) {
			this.addBotMessage('‚ö†Ô∏è No available layers were found.');
			return;
		}

		this.addUserMessage(message);
		this.setState({ message: '', loading: true });

		try {
			const result = await this.processMessage(message, layerCache);

			if (result.type === 'clarification') {
				this.setState({
					clarificationNeeded: true,
					clarificationOptions: result.options,
					pendingQuery: result.pendingQuery,
					loading: false,
				});
				if (result.pendingQuery?.candidateLayers?.length) {
					this.addBotMessage('ü§î I found multiple layers that might match. Please select one:');
				} else if (result.pendingQuery?.candidateFields?.length) {
					this.addBotMessage('ü§î Multiple fields match your query. Which one do you mean?');
				} else {
					this.addBotMessage('ü§î I found several possible matches. Please clarify:');
				}
			} else if (result.type === 'success') {
				const featureCount = await this.executeQuery(result);
				if (featureCount !== null) {
					this.state.lastFilters.set(result.metadata.id, result.whereClause);
					this.addBotMessage(`‚úÖ Filter applied to "${result.layerTitle}"\nüìç Found ${featureCount} feature(s)`);
				}
				this.setState({ loading: false });
			} else {
				this.addBotMessage(`‚ùå ${result.message}`);
				this.setState({ loading: false });
			}
		} catch (error) {
			const messageText = error instanceof Error ? error.message : 'Unknown error';
			this.addBotMessage(`‚ùå Something went wrong: ${messageText}`);
			this.setState({ loading: false });
		}
	};

	processMessage = async (message: string, layerCache: LayerMetadata[]): Promise<ProcessResult> => {
		const parsed = this.parseMessage(message);

		// Handle clear filter intent
		if (parsed.intent.action === 'clear' && parsed.intent.confidence > 0.8) {
			return this.handleClearFilters(layerCache);
		}

		// Check for exact field name matches with advanced scoring
		const exactFieldMatches = this.findExactFieldMatches(parsed, layerCache);
		
		if (exactFieldMatches.length > 1) {
			// Sort by confidence and layer relevance
			exactFieldMatches.sort((a, b) => {
				const aScore = this.scoreLayerRelevance(parsed, a.layer);
				const bScore = this.scoreLayerRelevance(parsed, b.layer);
				return bScore - aScore;
			});

			// If top match is significantly better, use it
			if (exactFieldMatches[0] && exactFieldMatches[1]) {
				const topScore = this.scoreLayerRelevance(parsed, exactFieldMatches[0].layer);
				const secondScore = this.scoreLayerRelevance(parsed, exactFieldMatches[1].layer);
				
				if (topScore > secondScore * 1.5) {
					return this.buildDirectQuery(parsed, exactFieldMatches[0].layer, exactFieldMatches[0].field);
				}
			}

			return {
				type: 'clarification',
				options: exactFieldMatches.slice(0, 5).map((match) => ({
					label: `${match.field.name} in ${match.layer.path.join(' ‚Ä∫ ')}`,
					value: match.layer.id,
					field: match.field.name,
					context: 'field' as ClarificationContext,
					metadata: match,
				})),
				pendingQuery: {
					parsed,
					layerMatch: null,
					candidateFields: exactFieldMatches.slice(0, 5),
				},
			};
		}

		if (exactFieldMatches.length === 1) {
			return this.buildDirectQuery(parsed, exactFieldMatches[0].layer, exactFieldMatches[0].field);
		}

		// Enhanced smart ranking with confidence scores
		const layerMatches = this.rankLayersAdvanced(parsed, layerCache);
		const minScore = layerCache.length > 1 ? 10 : 0;
		const viableMatches = layerMatches.filter((match) => match.score >= minScore && match.confidence > 0.5);

		if (viableMatches.length === 0) {
			return { 
				type: 'error', 
				message: 'No suitable layer found. Try:\n‚Ä¢ Mentioning a specific field name\n‚Ä¢ Including layer name\n‚Ä¢ Using simpler terms' 
			};
		}

		const topScore = viableMatches[0].score;
		const closeMatches = viableMatches.filter((match) => 
			match.score >= Math.max(5, topScore * 0.7) && match.confidence > 0.6
		);

		if (closeMatches.length > 1) {
			return {
				type: 'clarification',
				options: closeMatches.slice(0, 5).map((match) => ({
					label: `${match.layer.path.join(' ‚Ä∫ ')} (${match.matchedFields.length} field matches)`,
					value: match.layer.id,
					context: 'layer' as ClarificationContext,
				})),
				pendingQuery: {
					parsed,
					layerMatch: null,
					candidateLayers: closeMatches.slice(0, 5),
				},
			};
		}

		return this.buildSmartQuery(parsed, viableMatches[0]);
	};

	handleClearFilters = async (layerCache: LayerMetadata[]): Promise<ProcessResult> => {
		let cleared = 0;
		for (const layer of layerCache) {
			if (this.state.lastFilters.has(layer.id)) {
				layer.applyDefinitionExpression?.('1=1');
				this.state.lastFilters.delete(layer.id);
				cleared++;
			}
		}

		if (cleared > 0) {
			this.addBotMessage(`‚úÖ Cleared filters from ${cleared} layer(s)`);
		} else {
			this.addBotMessage('‚ÑπÔ∏è No active filters to clear');
		}

		return { type: 'error', message: '' }; // Dummy return
	};

	scoreLayerRelevance = (parsed: ParsedMessage, layer: LayerMetadata): number => {
		let score = 0;

		// Title token matches
		parsed.tokens.forEach(token => {
			if (layer.titleTokens.some(tt => this.computeSimilarity(token, tt) > 0.8)) {
				score += 10;
			}
		});

		// Field type relevance
		if (parsed.context.hasTimeReference && layer.fields.some(f => isDateFieldType(f.type))) {
			score += 15;
		}
		if (parsed.context.hasComparison && layer.fields.some(f => isNumericFieldType(f.type))) {
			score += 10;
		}

		return score;
	};

	findExactFieldMatches = (parsed: ParsedMessage, layerCache: LayerMetadata[]): Array<{ field: FieldMetadata; layer: LayerMetadata }> => {
		const matches: Array<{ field: FieldMetadata; layer: LayerMetadata }> = [];
		const searchTokens = [...parsed.potentialFields, ...parsed.tokens].map(t => t.toLowerCase());

		layerCache.forEach((layer) => {
			layer.fields.forEach((field) => {
				const fieldNameLower = field.name.toLowerCase();
				
				// Exact match
				if (searchTokens.includes(fieldNameLower)) {
					matches.push({ field, layer });
					return;
				}

				// Synonym match
				if (field.synonyms) {
					for (const synonym of field.synonyms) {
						if (searchTokens.includes(synonym.toLowerCase())) {
							matches.push({ field, layer });
							return;
						}
					}
				}

				// Fuzzy match with high threshold
				for (const token of searchTokens) {
					if (this.computeSimilarity(token, fieldNameLower) > 0.9) {
						matches.push({ field, layer });
						return;
					}
				}
			});
		});

		return matches;
	};

	buildDirectQuery = async (parsed: ParsedMessage, layer: LayerMetadata, field: FieldMetadata): Promise<ProcessResult> => {
		const conditions: string[] = [];
		const fieldType = normalizeFieldType(field.type);

		// Check for parsed conditions first
		const fieldCondition = parsed.conditions.find(c => 
			c.field?.toLowerCase() === field.name.toLowerCase()
		);

		if (fieldCondition && fieldCondition.operator && fieldCondition.value !== undefined) {
			if (isNumericFieldType(fieldType)) {
				const numValue = parseFloat(String(fieldCondition.value));
				if (!isNaN(numValue)) {
					const op = fieldCondition.operator;
					if (op === 'IS NULL') {
						conditions.push(`${field.name} IS NULL`);
					} else if (op === 'IS NOT NULL') {
						conditions.push(`${field.name} IS NOT NULL`);
					} else {
						conditions.push(`${field.name} ${op} ${numValue}`);
					}
				}
			} else if (isStringFieldType(fieldType)) {
				const sanitized = String(fieldCondition.value).replace(/'/g, "''");
				if (fieldCondition.operator === 'LIKE') {
					conditions.push(`UPPER(${field.name}) LIKE UPPER('%${sanitized}%')`);
				} else {
					conditions.push(`${field.name} ${fieldCondition.operator} '${sanitized}'`);
				}
			}
		} else {
			// Build condition based on field type and parsed data
			if (isNumericFieldType(fieldType) && parsed.numbers.length > 0) {
				const numCond = this.buildNumericCondition(field, parsed);
				if (numCond) conditions.push(numCond);
			} else if (isDateFieldType(fieldType) && parsed.dates.length > 0) {
				const dateCond = this.buildDateCondition(field, parsed.dates[0]);
				if (dateCond) conditions.push(dateCond);
			} else if (isStringFieldType(fieldType)) {
				const textTokens = parsed.freeText.length > 0 ? parsed.freeText : parsed.tokens;
				if (textTokens.length > 0) {
					const textMatch = await this.matchTextValue(textTokens, field, layer.queryLayer);
					if (textMatch.type === 'success') {
						conditions.push(textMatch.condition);
					} else {
						const likeConditions = textTokens.map((text) => {
							const sanitized = text.replace(/'/g, "''");
							return `UPPER(${field.name}) LIKE UPPER('%${sanitized}%')`;
						});
						conditions.push(`(${likeConditions.join(' OR ')})`);
					}
				}
			}
		}

		const whereClause = conditions.length > 0 ? conditions.join(' AND ') : '1=1';

		return {
			type: 'success',
			metadata: layer,
			whereClause,
			layerTitle: layer.title,
			debugInfo: {
				layerId: layer.id,
				layerTitle: layer.title,
				whereClause,
				matchedFields: [field.name],
				textTokens: parsed.freeText,
				numbers: parsed.numbers,
				operators: parsed.operators.map((op) => op.type),
				dates: parsed.dates.map((d) => d.type === 'year' ? `${d.value}` : `${d.month}-${d.year}`),
				rawMessage: parsed.original,
			},
		};
	};

	parseMessage = (message: string): ParsedMessage => {
		const original = message;
		const normalized = this.normalizeMessage(message);
		const lowerMessage = normalized.toLowerCase();
		const tokens = this.tokenizeWithStemming(normalized);

		// Detect intent
		let intent: QueryIntent = { action: 'filter', confidence: 0.7 };
		for (const pattern of INTENT_PATTERNS) {
			if (pattern.pattern.test(lowerMessage)) {
				intent = { action: pattern.action as any, confidence: pattern.confidence };
				break;
			}
		}

		// Build semantic context
		const context: SemanticContext = {
			hasLocation: /\b(in|at|near|around|from)\s+[A-Z][a-z]+/i.test(message),
			hasTimeReference: this.extractDates(message).length > 0 || /\b(today|yesterday|tomorrow|last|recent|current)\b/i.test(lowerMessage),
			hasComparison: this.extractOperators(message).length > 0,
			hasAggregation: /\b(count|sum|average|total|max|min)\b/i.test(lowerMessage),
			isQuestion: message.trim().endsWith('?'),
			suggestedFieldTypes: new Set(),
		};

		// Infer likely field types from context
		if (context.hasTimeReference) context.suggestedFieldTypes.add('date');
		if (context.hasComparison) context.suggestedFieldTypes.add('numeric');
		if (context.hasLocation) context.suggestedFieldTypes.add('string');

		// Parse conditions with context awareness
		const conditions = this.parseConditionsAdvanced(message, context);

		return {
			original,
			normalized,
			tokens,
			potentialFields: this.extractPotentialFields(message),
			dates: this.extractDates(message),
			numbers: this.extractNumbers(message),
			operators: this.extractOperators(message),
			logicalOperators: this.extractLogicalOperators(message),
			conditions,
			freeText: this.extractFreeText(message),
			intent,
			context,
			entities: this.extractEntities(message),
		};
	};

	normalizeMessage = (message: string): string => {
		// Expand contractions
		let normalized = message
			.replace(/\bcan't\b/gi, 'cannot')
			.replace(/\bwon't\b/gi, 'will not')
			.replace(/\bisn't\b/gi, 'is not')
			.replace(/\baren't\b/gi, 'are not')
			.replace(/\bwasn't\b/gi, 'was not')
			.replace(/\bweren't\b/gi, 'were not')
			.replace(/\bhasn't\b/gi, 'has not')
			.replace(/\bhaven't\b/gi, 'have not')
			.replace(/\bhadn't\b/gi, 'had not')
			.replace(/\bdoesn't\b/gi, 'does not')
			.replace(/\bdon't\b/gi, 'do not')
			.replace(/\bdidn't\b/gi, 'did not');

		// Normalize spacing around operators
		normalized = normalized
			.replace(/\s*>=\s*/g, ' >= ')
			.replace(/\s*<=\s*/g, ' <= ')
			.replace(/\s*!=\s*/g, ' != ')
			.replace(/\s*<>\s*/g, ' <> ')
			.replace(/\s*>\s*/g, ' > ')
			.replace(/\s*<\s*/g, ' < ')
			.replace(/\s*=\s*/g, ' = ');

		return normalized;
	};

	extractLogicalOperators = (message: string): LogicalOperator[] => {
		const operators: LogicalOperator[] = [];
		const lower = message.toLowerCase();
		
		if (/\b(and|&&)\b/i.test(lower)) operators.push('AND');
		if (/\b(or|\|\|)\b/i.test(lower)) operators.push('OR');
		if (/\b(not|!)\b/i.test(lower)) operators.push('NOT');
		
		return operators;
	};

	extractEntities = (message: string): Map<string, any> => {
		const entities = new Map<string, any>();

		// Extract quoted strings
		const quotedStrings = message.match(/'([^']*)'/g) || message.match(/"([^"]*)"/g);
		if (quotedStrings) {
			entities.set('quoted_values', quotedStrings.map(s => s.replace(/['"]/g, '')));
		}

		// Extract location names (capitalized words)
		const locationPattern = /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g;
		const locations = [...message.matchAll(locationPattern)].map(m => m[1]);
		if (locations.length > 0) {
			entities.set('locations', locations);
		}

		// Extract ranges (e.g., "between 10 and 20")
		const rangePattern = /between\s+(-?\d+(?:\.\d+)?)\s+and\s+(-?\d+(?:\.\d+)?)/i;
		const rangeMatch = message.match(rangePattern);
		if (rangeMatch) {
			entities.set('range', { min: parseFloat(rangeMatch[1]), max: parseFloat(rangeMatch[2]) });
		}

		return entities;
	};

	parseConditionsAdvanced = (message: string, context: SemanticContext): ParsedCondition[] => {
		const conditions: ParsedCondition[] = [];
		
		// Pattern 1: field operator value (e.g., "rsrp<-110")
		const directPattern = /([a-z_][a-z0-9_]*)\s*(>=|<=|!=|<>|>|<|=)\s*(-?\d+(?:\.\d+)?|'[^']*')/gi;
		let match;
		
		while ((match = directPattern.exec(message)) !== null) {
			conditions.push({
				field: match[1],
				operator: match[2],
				value: match[3].replace(/'/g, ''),
				raw: match[0],
				confidence: 1.0,
			});
		}

		// Pattern 2: Natural language comparisons
		const nlPattern = /([a-z_][a-z0-9_]*)\s+(greater|less|more|fewer|above|below|equal)\s+(?:than|to)?\s*(-?\d+(?:\.\d+)?)/gi;
		while ((match = nlPattern.exec(message)) !== null) {
			const operator = match[2].toLowerCase();
			const op = operator.includes('greater') || operator.includes('more') || operator.includes('above') ? '>' :
						operator.includes('less') || operator.includes('fewer') || operator.includes('below') ? '<' : '=';
			
			conditions.push({
				field: match[1],
				operator: op,
				value: parseFloat(match[3]),
				raw: match[0],
				confidence: 0.85,
			});
		}

		// Pattern 3: IS NULL / IS NOT NULL
		const nullPattern = /([a-z_][a-z0-9_]*)\s+is\s+(not\s+)?(?:null|empty|missing)/gi;
		while ((match = nullPattern.exec(message)) !== null) {
			conditions.push({
				field: match[1],
				operator: match[2] ? 'IS NOT NULL' : 'IS NULL',
				value: null,
				raw: match[0],
				confidence: 0.9,
			});
		}

		// Pattern 4: BETWEEN ranges
		const betweenPattern = /([a-z_][a-z0-9_]*)\s+between\s+(-?\d+(?:\.\d+)?)\s+and\s+(-?\d+(?:\.\d+)?)/gi;
		while ((match = betweenPattern.exec(message)) !== null) {
			conditions.push({
				field: match[1],
				operator: 'BETWEEN',
				value: `${match[2]} AND ${match[3]}`,
				raw: match[0],
				confidence: 0.95,
			});
		}

		return conditions;
	};

	extractPotentialFields = (message: string): string[] => {
		const regex = /\b[a-z_][a-z0-9_]*\b/gi;
		return (message.match(regex) ?? []).map((match) => match.toLowerCase());
	};

	extractDates = (message: string): DateInfo[] => {
		const dates: DateInfo[] = [];

		// Relative dates
		const relativePattern = /(\d+)\s+(day|week|month|year)s?\s+ago/i;
		const relMatch = message.match(relativePattern);
		if (relMatch) {
			dates.push({ 
				type: 'relative', 
				unit: relMatch[2].toLowerCase() as any, 
				offset: -parseInt(relMatch[1]) 
			});
		}

		// Year pattern
		const yearMatch = message.match(/\b(19|20)\d{2}\b/);
		if (yearMatch) {
			dates.push({ type: 'year', value: parseInt(yearMatch[0], 10) });
		}

		// Month-year pattern
		const monthNames: Record<string, string> = {
			january: '01', jan: '01', february: '02', feb: '02',
			march: '03', mar: '03', april: '04', apr: '04',
			may: '05', june: '06', jun: '06', july: '07', jul: '07',
			august: '08', aug: '08', september: '09', sept: '09', sep: '09',
			october: '10', oct: '10', november: '11', nov: '11',
			december: '12', dec: '12',
		};

		Object.entries(monthNames).forEach(([month, num]) => {
			const regex = new RegExp(`${month}\\s*(\\d{4})`, 'i');
			const match = message.match(regex);
			if (match) {
				dates.push({ type: 'month-year', year: parseInt(match[1], 10), month: num });
			}
		});

		// Full date pattern (MM/DD/YYYY or DD-MM-YYYY)
		const fullDatePattern = /\b(\d{1,2})[/-](\d{1,2})[/-](\d{4})\b/;
		const fullMatch = message.match(fullDatePattern);
		if (fullMatch) {
			dates.push({
				type: 'full-date',
				year: parseInt(fullMatch[3], 10),
				month: fullMatch[1].padStart(2, '0'),
				day: fullMatch[2].padStart(2, '0'),
			});
		}

		return dates;
	};

	extractNumbers = (message: string): number[] => {
		const numbers = message.match(/-?\d+(\.\d+)?/g);
		return numbers ? numbers.map((value) => parseFloat(value)) : [];
	};

	extractOperators = (message: string): OperatorInfo[] => {
		const operators: OperatorInfo[] = [];

		for (const pattern of OPERATOR_PATTERNS) {
			if (pattern.pattern.test(message)) {
				operators.push({ 
					type: pattern.operator as any, 
					confidence: pattern.confidence 
				});
			}
		}

		// Remove duplicates, keep highest confidence
		const uniqueOps = new Map<string, number>();
		operators.forEach(op => {
			const existing = uniqueOps.get(op.type);
			if (!existing || op.confidence > existing) {
				uniqueOps.set(op.type, op.confidence);
			}
		});

		return Array.from(uniqueOps.entries()).map(([type, confidence]) => ({ 
			type: type as any, 
			confidence 
		}));
	};

	extractFreeText = (message: string): string[] => {
		const technical = this.extractPotentialFields(message);
		const words = message.toLowerCase().split(/\s+/);
		const stopWords = new Set([
			'and', 'or', 'not', 'with', 'for', 'the', 'that', 'this', 'these', 'those',
			'where', 'records', 'results', 'show', 'find', 'display', 'please', 'filter',
			'list', 'from', 'in', 'on', 'of', 'greater', 'less', 'than', 'equal', 'to',
			'is', 'are', 'was', 'were', 'been', 'being', 'have', 'has', 'had',
			'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might',
			'can', 'must', 'a', 'an', 'as', 'at', 'by', 'it', 'its', 'me', 'my',
		]);

		return words.filter(
			(word) =>
				word.length > 2 &&
				!technical.includes(word) &&
				!/^-?[\d.]+$/.test(word) &&
				!stopWords.has(word),
		);
	};

	rankLayersAdvanced = (parsed: ParsedMessage, layerCache: LayerMetadata[]): LayerMatch[] => {
		if (layerCache.length === 0) return [];

		return layerCache
			.map((layer) => {
				let score = 0;
				let confidence = 0.5;
				const matchedFields: MatchedField[] = [];
				const titleTokens = layer.titleTokens ?? [];
				const messageTokens = Array.from(
					new Set([
						...parsed.tokens,
						...parsed.freeText,
						...parsed.potentialFields,
					]),
				);

				// Title matching with fuzzy logic
				messageTokens.forEach((token) => {
					const loweredToken = token.toLowerCase();
					
					titleTokens.forEach(titleToken => {
						const similarity = this.computeSimilarity(loweredToken, titleToken);
						if (similarity > 0.9) {
							score += 40 * similarity;
							confidence = Math.max(confidence, 0.9);
						} else if (similarity > 0.7) {
							score += 20 * similarity;
							confidence = Math.max(confidence, 0.7);
						}
					});
				});

				// Field matching with synonym support
				parsed.potentialFields.forEach((token) => {
					layer.fields.forEach((field) => {
						const loweredName = field.name.toLowerCase();
						const loweredAlias = field.alias.toLowerCase();
						const similarity = this.computeSimilarity(token, loweredName);

						if (similarity === 1.0) {
							score += 50;
							matchedFields.push({ field, token, type: 'exact', confidence: 1.0 });
							confidence = Math.max(confidence, 0.95);
						} else if (similarity > 0.85) {
							score += 30 * similarity;
							matchedFields.push({ field, token, type: 'partial', confidence: similarity });
							confidence = Math.max(confidence, 0.8);
						} else if (field.nameTokens.includes(token)) {
							score += 30;
							matchedFields.push({ field, token, type: 'token', confidence: 0.85 });
							confidence = Math.max(confidence, 0.75);
						} else if (loweredAlias.includes(token) || token.includes(loweredAlias)) {
							score += 20;
							matchedFields.push({ field, token, type: 'alias', confidence: 0.7 });
							confidence = Math.max(confidence, 0.65);
						}

						// Synonym matching
						if (field.synonyms) {
							for (const synonym of field.synonyms) {
								if (this.computeSimilarity(token, synonym) > 0.8) {
									score += 25;
									matchedFields.push({ field, token, type: 'synonym', confidence: 0.75 });
									confidence = Math.max(confidence, 0.7);
								}
							}
						}
					});
				});

				// Context-based scoring
				if (parsed.context.hasTimeReference && layer.fields.some((field) => isDateFieldType(field.type))) {
					score += 15;
					confidence = Math.max(confidence, 0.6);
				}

				if (parsed.context.hasComparison && layer.fields.some((field) => isNumericFieldType(field.type))) {
					score += 15;
					confidence = Math.max(confidence, 0.6);
				}

				if (parsed.context.hasLocation && layer.fields.some((field) => isStringFieldType(field.type))) {
					score += 10;
				}

				// Entity matching (e.g., location names in layer title)
				if (parsed.entities.has('locations')) {
					const locations = parsed.entities.get('locations') as string[];
					locations.forEach(loc => {
						if (layer.title.includes(loc)) {
							score += 20;
							confidence = Math.max(confidence, 0.75);
						}
					});
				}

				return { layer, score, matchedFields, confidence };
			})
			.sort((a, b) => {
				// Sort by score first, then confidence
				if (Math.abs(a.score - b.score) < 5) {
					return b.confidence - a.confidence;
				}
				return b.score - a.score;
			})
			.filter((match) => match.score > 0);
	};

	buildSmartQuery = async (parsed: ParsedMessage, layerMatch: LayerMatch): Promise<ProcessResult> => {
		const { layer: layerMetadata, matchedFields } = layerMatch;
		const conditions: string[] = [];
		const textTokens = (
			parsed.freeText.length > 0 ? parsed.freeText : parsed.numbers.map((value) => `${value}`)
		).filter((token) => token.trim().length > 0);

		// Handle BETWEEN ranges from entities
		if (parsed.entities.has('range')) {
			const range = parsed.entities.get('range');
			const numericFields = matchedFields.filter(mf => isNumericFieldType(mf.field.type));
			if (numericFields.length > 0) {
				const field = numericFields[0].field;
				conditions.push(`${field.name} BETWEEN ${range.min} AND ${range.max}`);
			}
		}

		// Process parsed conditions with exact field matches
		if (parsed.conditions.length > 0 && conditions.length === 0) {
			for (const condition of parsed.conditions) {
				if (condition.confidence < 0.7) continue;

				const field = layerMetadata.fields.find(
					f => f.name.toLowerCase() === condition.field?.toLowerCase()
				);
				
				if (field && condition.operator && condition.value !== undefined) {
					const fieldType = normalizeFieldType(field.type);
					
					if (condition.operator === 'IS NULL') {
						conditions.push(`${field.name} IS NULL`);
					} else if (condition.operator === 'IS NOT NULL') {
						conditions.push(`${field.name} IS NOT NULL`);
					} else if (condition.operator === 'BETWEEN') {
						conditions.push(`${field.name} BETWEEN ${condition.value}`);
					} else if (isNumericFieldType(fieldType)) {
						const numValue = parseFloat(String(condition.value));
						if (!isNaN(numValue)) {
							conditions.push(`${field.name} ${condition.operator} ${numValue}`);
						}
					} else if (isStringFieldType(fieldType)) {
						const sanitized = String(condition.value).replace(/'/g, "''");
						if (condition.operator === 'LIKE') {
							conditions.push(`UPPER(${field.name}) LIKE UPPER('%${sanitized}%')`);
						} else {
							conditions.push(`${field.name} ${condition.operator} '${sanitized}'`);
						}
					}
				}
			}
		}

		// Process matched fields if no direct conditions
		if (conditions.length === 0) {
			for (const match of matchedFields) {
				if (match.confidence < 0.6) continue;

				const field = match.field;
				const fieldType = normalizeFieldType(field.type);

				if (isDateFieldType(fieldType) && parsed.dates.length > 0) {
					const dateCond = this.buildDateCondition(field, parsed.dates[0]);
					if (dateCond) conditions.push(dateCond);
				} else if (isNumericFieldType(fieldType) && parsed.numbers.length > 0) {
					const numCond = this.buildNumericCondition(field, parsed);
					if (numCond) conditions.push(numCond);
				} else if (isStringFieldType(fieldType) && textTokens.length > 0) {
					const textMatch = await this.matchTextValue(textTokens, field, layerMetadata.queryLayer);

					if (textMatch.type === 'clarification') {
						return {
							type: 'clarification',
							options: textMatch.options,
							pendingQuery: { parsed, layerMatch, field },
						};
					}

					if (textMatch.type === 'success') {
						conditions.push(textMatch.condition);
					} else {
						const likeConditions = textTokens.map((text) => {
							const sanitized = text.replace(/'/g, "''");
							return `UPPER(${field.name}) LIKE UPPER('%${sanitized}%')`;
						});
						if (likeConditions.length > 0) {
							conditions.push(`(${likeConditions.join(' OR ')})`);
						}
					}
				}
			}
		}

		// Fallback: search all string fields
		const unmatchedStringFields = layerMetadata.fields.filter(
			(field: FieldMetadata) =>
				isStringFieldType(field.type) && !matchedFields.some((matched) => matched.field.name === field.name),
		);

		if (textTokens.length > 0 && unmatchedStringFields.length > 0 && conditions.length === 0) {
			const orConditions: string[] = [];
			textTokens.forEach((text) => {
				const sanitized = text.replace(/'/g, "''");
				unmatchedStringFields.forEach((field: FieldMetadata) => {
					orConditions.push(`UPPER(${field.name}) LIKE UPPER('%${sanitized}%')`);
				});
			});

			if (orConditions.length > 0) {
				conditions.push(`(${orConditions.join(' OR ')})`);
			}
		}

		// Join conditions with logical operators
		const logicalOp = parsed.logicalOperators.length > 0 ? parsed.logicalOperators[0] : 'AND';
		const whereClause = conditions.length > 0 ? conditions.join(` ${logicalOp} `) : '1=1';
		
		const matchedFieldNames = Array.from(new Set(matchedFields.map((match) => match.field.name)));
		const operatorStrings = parsed.operators.map((operator) => operator.type);
		const dateStrings = parsed.dates.map((dateInfo) => {
			if (dateInfo.type === 'year') return `year:${dateInfo.value}`;
			if (dateInfo.type === 'month-year') return `month:${dateInfo.month}-${dateInfo.year}`;
			if (dateInfo.type === 'relative') return `${dateInfo.offset} ${dateInfo.unit}(s) ago`;
			return `${dateInfo.month}/${dateInfo.day}/${dateInfo.year}`;
		});

		return {
			type: 'success',
			metadata: layerMetadata,
			whereClause,
			layerTitle: layerMetadata.title,
			debugInfo: {
				layerId: layerMetadata.id,
				layerTitle: layerMetadata.title,
				whereClause,
				matchedFields: matchedFieldNames,
				textTokens,
				numbers: parsed.numbers,
				operators: operatorStrings,
				dates: dateStrings,
				rawMessage: parsed.original,
			},
		};
	};

	matchTextValue = async (
		freeTextArray: string[],
		field: FieldMetadata,
		queryLayer: FeatureLayer,
	): Promise<MatchResult> => {
		try {
			if (typeof queryLayer.queryFeatures !== 'function') {
				return { type: 'fallback' };
			}

			const queryFeatures = queryLayer.queryFeatures.bind(queryLayer);
			const query = typeof queryLayer.createQuery === 'function' ? queryLayer.createQuery() : ({} as any);
			query.where = '1=1';
			query.returnDistinctValues = true;
			query.outFields = [field.name];
			query.returnGeometry = false;
			query.num = 1000;

			const results = await queryFeatures(query);
			if (!results || !Array.isArray(results.features)) {
				return { type: 'fallback' };
			}

			const distinctValues = results.features
				.map((feature: any) => feature.attributes[field.name])
				.filter((value: unknown) => value !== null && value !== undefined);

			if (distinctValues.length === 0) {
				return { type: 'fallback' };
			}

			const allMatches: Array<{ value: unknown; score: number; userText: string }> = [];

			freeTextArray.forEach((userText: string) => {
				distinctValues.forEach((dbValue: unknown) => {
					const normalizedDbValue = String(dbValue).toLowerCase();
					const normalizedUserText = userText.toLowerCase();
					
					// Use advanced similarity scoring
					const similarity = this.computeSimilarity(normalizedUserText, normalizedDbValue);
					if (similarity > 0.4) {
						allMatches.push({ value: dbValue, score: similarity, userText });
					}
				});
			});

			if (allMatches.length === 0) {
				const likeConditions = freeTextArray.map((text) => {
					const sanitized = text.replace(/'/g, "''");
					return `UPPER(${field.name}) LIKE UPPER('%${sanitized}%')`;
				});

				if (likeConditions.length > 0) {
					return {
						type: 'success',
						condition: `(${likeConditions.join(' OR ')})`,
					};
				}

				return { type: 'fallback' };
			}

			allMatches.sort((a, b) => b.score - a.score);
			const topMatches = allMatches.slice(0, 5);

			// If top match has very high confidence, use it
			if (topMatches.length > 0 && topMatches[0].score > 0.85) {
				const sanitizedValue = String(topMatches[0].value).replace(/'/g, "''");
				return {
					type: 'success',
					condition: `${field.name} = '${sanitizedValue}'`,
				};
			}

			// If multiple good matches, ask for clarification
			if (topMatches.length > 1 && topMatches[1].score > 0.6) {
				return {
					type: 'clarification',
					options: topMatches.map((match) => ({
						label: `${match.value} (for "${match.userText}") - ${Math.round(match.score * 100)}% match`,
						value: String(match.value),
						field: field.name,
						context: 'value' as ClarificationContext,
					})),
				};
			}

			// Single decent match
			if (topMatches.length > 0) {
				const sanitizedValue = String(topMatches[0].value).replace(/'/g, "''");
				return {
					type: 'success',
					condition: `${field.name} = '${sanitizedValue}'`,
				};
			}

			return { type: 'fallback' };
		} catch (error) {
			console.error('Text matching error:', error);
			return { type: 'fallback' };
		}
	};

	buildDateCondition = (field: FieldMetadata, dateInfo: DateInfo): string | null => {
		if (dateInfo.type === 'year') {
			const startYear = dateInfo.value;
			const endYear = dateInfo.value + 1;
			return `${field.name} >= TIMESTAMP '${startYear}-01-01 00:00:00' AND ${field.name} < TIMESTAMP '${endYear}-01-01 00:00:00'`;
		}

		if (dateInfo.type === 'month-year') {
			const currentMonth = parseInt(dateInfo.month, 10);
			const nextMonth = currentMonth === 12 ? 1 : currentMonth + 1;
			const nextYear = currentMonth === 12 ? dateInfo.year + 1 : dateInfo.year;
			const nextMonthString = nextMonth.toString().padStart(2, '0');

			return `${field.name} >= TIMESTAMP '${dateInfo.year}-${dateInfo.month}-01 00:00:00' AND ${field.name} < TIMESTAMP '${nextYear}-${nextMonthString}-01 00:00:00'`;
		}

		if (dateInfo.type === 'full-date') {
			return `${field.name} = TIMESTAMP '${dateInfo.year}-${dateInfo.month}-${dateInfo.day} 00:00:00'`;
		}

		if (dateInfo.type === 'relative') {
			const now = new Date();
			let targetDate = new Date(now);
			
			switch (dateInfo.unit) {
				case 'day':
					targetDate.setDate(now.getDate() + dateInfo.offset);
					break;
				case 'week':
					targetDate.setDate(now.getDate() + (dateInfo.offset * 7));
					break;
				case 'month':
					targetDate.setMonth(now.getMonth() + dateInfo.offset);
					break;
				case 'year':
					targetDate.setFullYear(now.getFullYear() + dateInfo.offset);
					break;
			}

			const year = targetDate.getFullYear();
			const month = String(targetDate.getMonth() + 1).padStart(2, '0');
			const day = String(targetDate.getDate()).padStart(2, '0');
			
			return `${field.name} >= TIMESTAMP '${year}-${month}-${day} 00:00:00'`;
		}

		return null;
	};

	buildNumericCondition = (field: FieldMetadata, parsed: ParsedMessage): string | null => {
		if (parsed.numbers.length === 0) return null;

		// Check if we have a BETWEEN range
		if (parsed.entities.has('range')) {
			const range = parsed.entities.get('range');
			return `${field.name} BETWEEN ${range.min} AND ${range.max}`;
		}

		const op = parsed.operators.length > 0 ? parsed.operators[0].type : '=';

		switch (op) {
			case '>':
				return `${field.name} > ${parsed.numbers[0]}`;
			case '>=':
				return `${field.name} >= ${parsed.numbers[0]}`;
			case '<':
				return `${field.name} < ${parsed.numbers[0]}`;
			case '<=':
				return `${field.name} <= ${parsed.numbers[0]}`;
			case '!=':
				return `${field.name} <> ${parsed.numbers[0]}`;
			case '=':
				return `${field.name} = ${parsed.numbers[0]}`;
			case 'BETWEEN':
				if (parsed.numbers.length >= 2) {
					return `${field.name} BETWEEN ${parsed.numbers[0]} AND ${parsed.numbers[1]}`;
				}
				return `${field.name} = ${parsed.numbers[0]}`;
			default:
				return `${field.name} = ${parsed.numbers[0]}`;
		}
	};

	handleClarificationSelect = async (selectedValue: string) => {
		const { pendingQuery, clarificationOptions, connectionStatus } = this.state;

		if (connectionStatus !== 'ready') {
			this.addBotMessage('‚ö†Ô∏è The map connection is not ready.');
			return;
		}

		if (!pendingQuery) {
			this.setState({ clarificationNeeded: false, clarificationOptions: [], pendingQuery: null });
			return;
		}

		const selectedOption = clarificationOptions.find((option: ClarificationOption) => option.value === selectedValue);
		if (!selectedOption) {
			this.setState({ clarificationNeeded: false, clarificationOptions: [], pendingQuery: null });
			return;
		}

		// Handle field clarification
		if (selectedOption.context === 'field' && selectedOption.metadata) {
			const match = selectedOption.metadata as { field: FieldMetadata; layer: LayerMetadata };
			this.setState({ clarificationNeeded: false, clarificationOptions: [], loading: true, pendingQuery: null });

			try {
				const refinedResult = await this.buildDirectQuery(pendingQuery.parsed, match.layer, match.field);
				
				if (refinedResult.type === 'success') {
					const featureCount = await this.executeQuery(refinedResult);
					if (featureCount !== null) {
						this.addBotMessage(`‚úÖ Filter applied to "${refinedResult.layerTitle}"\nüìç Found ${featureCount} feature(s)`);
					}
					this.setState({ loading: false, pendingQuery: null });
					return;
				}

				this.addBotMessage(`‚ùå ${refinedResult.message}`);
				this.setState({ loading: false, pendingQuery: null });
			} catch (error) {
				const messageText = error instanceof Error ? error.message : 'Unknown error';
				this.addBotMessage(`‚ùå Unable to apply the filter: ${messageText}`);
				this.setState({ loading: false, pendingQuery: null });
			}
			return;
		}

		// Handle layer clarification
		if (selectedOption.context === 'layer') {
			if (!pendingQuery.candidateLayers?.length) {
				this.setState({ clarificationNeeded: false, clarificationOptions: [], pendingQuery: null });
				return;
			}

			const chosenLayer = pendingQuery.candidateLayers.find((match: LayerMatch) => match.layer.id === selectedOption.value);
			if (!chosenLayer) {
				this.setState({ clarificationNeeded: false, clarificationOptions: [], pendingQuery: null });
				return;
			}

			this.setState({ clarificationNeeded: false, clarificationOptions: [], loading: true, pendingQuery: null });

			try {
				const refinedResult = await this.buildSmartQuery(pendingQuery.parsed, chosenLayer);
				if (refinedResult.type === 'clarification') {
					this.setState({
						clarificationNeeded: true,
						clarificationOptions: refinedResult.options,
						pendingQuery: refinedResult.pendingQuery,
						loading: false,
					});
					this.addBotMessage('ü§î Multiple values match. Please choose:');
					return;
				}

				if (refinedResult.type === 'success') {
					const featureCount = await this.executeQuery(refinedResult);
					if (featureCount !== null) {
						this.addBotMessage(`‚úÖ Filter applied to "${refinedResult.layerTitle}"\nüìç Found ${featureCount} feature(s)`);
					}
					this.setState({ loading: false, pendingQuery: null });
					return;
				}

				this.addBotMessage(`‚ùå ${refinedResult.message}`);
				this.setState({ loading: false, pendingQuery: null });
			} catch (error) {
				const messageText = error instanceof Error ? error.message : 'Unknown error';
				this.addBotMessage(`‚ùå Unable to apply the filter: ${messageText}`);
				this.setState({ loading: false, pendingQuery: null });
			}

			return;
		}

		// Handle value clarification
		if (!selectedOption.field || !pendingQuery.layerMatch) {
			this.setState({ clarificationNeeded: false, clarificationOptions: [], pendingQuery: null });
			return;
		}

		this.setState({ clarificationNeeded: false, loading: true });

		const sanitizedValue = selectedValue.replace(/'/g, "''");
		const condition = `${selectedOption.field} = '${sanitizedValue}'`;

		const targetMetadata = pendingQuery.layerMatch.layer;
		const featureCount = await this.executeQueryDirect(
			targetMetadata,
			condition,
			targetMetadata.title,
			{
				layerId: targetMetadata.id,
				layerTitle: targetMetadata.title,
				whereClause: condition,
				matchedFields: [selectedOption.field],
				textTokens: pendingQuery.parsed.tokens,
				numbers: pendingQuery.parsed.numbers,
				operators: pendingQuery.parsed.operators.map((operator: OperatorInfo) => operator.type),
				dates: pendingQuery.parsed.dates.map((dateInfo: DateInfo) => {
					if (dateInfo.type === 'year') return `year:${dateInfo.value}`;
					if (dateInfo.type === 'month-year') return `month:${dateInfo.month}-${dateInfo.year}`;
					if (dateInfo.type === 'relative') return `${dateInfo.offset} ${dateInfo.unit}s ago`;
					return `${dateInfo.month}/${dateInfo.day}/${dateInfo.year}`;
				}),
				rawMessage: pendingQuery.parsed.original,
				selectedField: selectedOption.field,
				selectedValue: selectedValue,
			},
		);

		if (featureCount !== null) {
			this.addBotMessage(`‚úÖ Filter applied\nüìç Found ${featureCount} feature(s)`);
		}

		this.setState({ loading: false, pendingQuery: null, clarificationOptions: [] });
	};

	executeQuery = async (result: Extract<ProcessResult, { type: 'success' }>): Promise<number | null> => {
		return this.executeQueryDirect(result.metadata, result.whereClause, result.layerTitle, result.debugInfo);
	};

	executeQueryDirect = async (
		metadata: LayerMetadata,
		whereClause: string,
		layerTitle: string,
		debugInfo?: QueryDebugInfo,
	): Promise<number | null> => {
		const { jimuMapView } = this.state;
		const layer = metadata.queryLayer;

		try {
			// Make layer visible
			if (metadata.setVisible) {
				metadata.setVisible(true);
			}

			if (typeof layer.queryFeatures !== 'function') {
				this.addBotMessage('‚ùå The selected layer cannot be queried.');
				return null;
			}

			const queryFeatures = layer.queryFeatures.bind(layer);
			const query = typeof layer.createQuery === 'function' ? layer.createQuery() : ({} as any);
			query.where = whereClause;
			query.returnGeometry = true;
			query.outFields = ['*'];

			const results = await queryFeatures(query);
			if (!results || !Array.isArray(results.features)) {
				this.addBotMessage('‚ùå The query did not return any results.');
				return null;
			}
			const featureCount = results.features.length;

			if (featureCount === 0) {
				const detailLines: string[] = [
					`üìÇ Layer: ${layerTitle}`,
					`üîç Query: ${whereClause}`,
				];

				if (debugInfo) {
					if (debugInfo.matchedFields.length > 0) {
						detailLines.push(`üìã Fields: ${debugInfo.matchedFields.join(', ')}`);
					}
					if (debugInfo.operators.length > 0) {
						detailLines.push(`‚öôÔ∏è Operators: ${debugInfo.operators.join(', ')}`);
					}
				}

				console.debug('SmartFilterWidget query returned zero features.', {
					layerTitle,
					whereClause,
					debugInfo,
				});

				this.addBotMessage(
					`‚ö†Ô∏è No features matched the filter.\n\n${detailLines.join('\n')}\n\nüí° Try:\n‚Ä¢ Adjusting your criteria\n‚Ä¢ Using different field names\n‚Ä¢ Checking data availability`
				);
				return null;
			}

			// Apply definition expression to filter the layer
			if ('definitionExpression' in layer) {
				(layer as any).definitionExpression = whereClause;
			}
			metadata.applyDefinitionExpression?.(whereClause);

			// Zoom to filtered features with smooth animation
			if (jimuMapView?.view && results.features.length > 0) {
				try {
					await jimuMapView.view.goTo(results.features, {
						duration: 1000,
						easing: 'ease-in-out'
					});
				} catch (goToError) {
					console.warn('Map navigation failed:', goToError);
				}
			}

			return featureCount;
		} catch (error) {
			const messageText = error instanceof Error ? error.message : 'Unknown error';
			this.addBotMessage(`‚ùå Query failed: ${messageText}`);
			return null;
		}
	};

	addUserMessage = (text: string) => {
		this.setState((prevState: State) => ({
			chatHistory: [...prevState.chatHistory, { type: 'user', text, timestamp: new Date() }],
		}));
	};

	addBotMessage = (text: string) => {
		this.setState((prevState: State) => ({
			chatHistory: [...prevState.chatHistory, { type: 'bot', text, timestamp: new Date() }],
		}));
	};

	render() {
		const {
			message,
			chatHistory,
			loading,
			clarificationNeeded,
			clarificationOptions,
			connectionStatus,
			statusMessage,
		} = this.state;

		const inputDisabled = loading || connectionStatus !== 'ready';

		return (
			<div className="smart-filter-widget jimu-widget" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
				<JimuMapViewComponent
					useMapWidgetId={this.props.useMapWidgetIds?.[0]}
					onActiveViewChange={this.onActiveViewChange}
				/>

				<div style={{ padding: '10px 15px', borderBottom: '1px solid #ccc', backgroundColor: '#fff' }}>
					<Alert
						form="basic"
						type={connectionStatus === 'ready' ? 'success' : connectionStatus === 'error' ? 'danger' : 'info'}
						text={statusMessage}
					/>
				</div>

				<div style={{ flex: 1, padding: '15px', overflowY: 'auto', backgroundColor: '#f5f5f5' }}>
					{chatHistory.map((msg: ChatMessage, idx: number) => (
						<div
							key={idx}
							style={{
								marginBottom: '10px',
								textAlign: msg.type === 'user' ? 'right' : 'left',
							}}
						>
							<div
								style={{
									display: 'inline-block',
									padding: '8px 12px',
									borderRadius: '12px',
									backgroundColor: msg.type === 'user' ? '#0079c1' : '#fff',
									color: msg.type === 'user' ? '#fff' : '#333',
									maxWidth: '80%',
									boxShadow: '0 1px 2px rgba(0,0,0,0.1)',
									whiteSpace: 'pre-wrap',
								}}
							>
								{msg.text}
							</div>
						</div>
					))}

					{loading && (
						<div style={{ textAlign: 'center', padding: '10px' }}>
							<span>‚è≥ Processing your query...</span>
						</div>
					)}
				</div>

				{clarificationNeeded && (
					<div style={{ padding: '15px', backgroundColor: '#fff3cd', borderTop: '1px solid #ccc' }}>
						<Label style={{ marginBottom: '10px', fontWeight: 'bold' }}>Please select:</Label>
						<Select
							placeholder="Choose an option..."
							onChange={(event: React.ChangeEvent<HTMLSelectElement>) =>
								this.handleClarificationSelect(event.target.value)
							}
						>
							{clarificationOptions.map((option: ClarificationOption, idx: number) => (
								<Option key={idx} value={option.value}>
									{option.label}
								</Option>
							))}
						</Select>
					</div>
				)}

				<div style={{ padding: '15px', borderTop: '1px solid #ccc', backgroundColor: '#fff' }}>
					<div style={{ display: 'flex', gap: '10px' }}>
						<TextInput
							placeholder="Try: rsrp<-110, show 2024 data, filter New York, clear filters"
							value={message}
							onChange={(event: React.ChangeEvent<HTMLInputElement>) =>
								this.setState({ message: event.target.value })
							}
							onKeyPress={(event: React.KeyboardEvent<HTMLInputElement>) => {
								if (event.key === 'Enter') {
									this.handleSendMessage();
								}
							}}
							style={{ flex: 1 }}
							disabled={inputDisabled}
						/>
						<Button type="primary" onClick={this.handleSendMessage} disabled={inputDisabled || !message.trim()}>
							Send
						</Button>
					</div>
				</div>
			</div>
		);
	}
}
