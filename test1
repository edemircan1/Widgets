/** @jsx jsx */
import { React, AllWidgetProps, jsx } from 'jimu-core';
import { loadArcGISJSAPIModules, JimuMapViewComponent, JimuMapView } from 'jimu-arcgis';
import { IMConfig } from '../config';

interface FeatureLayerQuery {
  where: string;
  outFields: string[];
  returnGeometry: boolean;
  start?: number;
  num?: number;
  orderByFields?: string[];
  objectIds?: number[];
  returnExceededLimitFeatures?: boolean;
}

interface QueryFeature {
  attributes: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
  geometry?: any; // polygon geometry (keep any to avoid pulling in full ArcGIS types) // eslint-disable-line @typescript-eslint/no-explicit-any
}

interface FeatureLayerQueryResult {
  features: QueryFeature[];
  exceededTransferLimit?: boolean;
}

interface FeatureLayerInstance {
  createQuery: () => FeatureLayerQuery;
  queryFeatures: (query: FeatureLayerQuery) => Promise<FeatureLayerQueryResult>;
  renderer?: any; // eslint-disable-line @typescript-eslint/no-explicit-any
  when?: () => Promise<any>; // eslint-disable-line @typescript-eslint/no-explicit-any
  load?: () => Promise<void>;
  queryObjectIds?: (query: FeatureLayerQuery) => Promise<number[]>;
  capabilities?: { query?: { supportsPagination?: boolean; maxRecordCount?: number } };
  objectIdField?: string;
}

type FeatureLayerConstructor = new (params: any) => FeatureLayerInstance; // eslint-disable-line @typescript-eslint/no-explicit-any

interface SelectedCell {
  raw: string;
  key: string;
}

interface LegendBreak {
  minValue: number;
  maxValue: number;
  color: string;
  label: string;
}

interface KpiSeriesEntry {
  key: string;
  label: string;
  value: number;
}

interface KpiTimeSeriesPoint {
  timestamp: number;
  value: number;
  displayLabel: string;
  tooltipLabel: string;
}

interface KpiTimeSeriesEntry {
  key: string;
  label: string;
  points: KpiTimeSeriesPoint[];
}

interface ChartSeriesCoordinates {
  point: KpiTimeSeriesPoint;
  x: number;
  y: number;
}

interface PreparedChartSeries {
  key: string;
  label: string;
  color: string;
  path: string;
  coordinates: ChartSeriesCoordinates[];
}

// Field name constants
const POLYGON_CELL_FIELD = 'cell'; // polygon layer attribute containing cell name
const KPI_JOIN_FIELD = 'eutrancellfdd'; // KPI table join attribute matching polygon cell names

const DAY_IN_MS = 24 * 60 * 60 * 1000;

const formatLegendLabel = (minValue: number, maxValue: number): string => {
  if (!Number.isFinite(minValue) || !Number.isFinite(maxValue)) {
    return '';
  }
  return `${minValue.toFixed(2)} - ${maxValue.toFixed(2)}`;
};

const DEFAULT_LEGEND_COLORS = ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#b10026'];

const KPI_COLOR_PALETTE = [
  '#4361ee',
  '#f15bb5',
  '#ff8500',
  '#43aa8b',
  '#7209b7',
  '#f94144',
  '#277da1',
  '#577590',
  '#f8961e',
  '#90be6d',
  '#4d908e',
  '#ffb5a7'
];

const getColorForIndex = (index: number): string => {
  const paletteSize = KPI_COLOR_PALETTE.length;
  if (paletteSize === 0) {
    return '#2b2d42';
  }
  const safeIndex = ((index % paletteSize) + paletteSize) % paletteSize;
  return KPI_COLOR_PALETTE[safeIndex];
};

const formatKpiValue = (value: number): string => {
  if (!Number.isFinite(value)) {
    return '-';
  }
  return value.toLocaleString(undefined, { maximumFractionDigits: 3 });
};

const parseDateTimeValue = (value: unknown): number | undefined => {
  if (value === null || value === undefined) {
    return undefined;
  }
  if (value instanceof Date) {
    const time = value.getTime();
    return Number.isFinite(time) ? time : undefined;
  }
  if (typeof value === 'number') {
    if (!Number.isFinite(value)) {
      return undefined;
    }
    if (value > 1e12) {
      return value;
    }
    if (value > 1e10) {
      return value * 1000;
    }
    const numericAsString = value.toString();
    const parsedNumericString = Date.parse(numericAsString);
    if (!Number.isNaN(parsedNumericString)) {
      return parsedNumericString;
    }
    return undefined;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) {
      return undefined;
    }
    const parsed = Date.parse(trimmed);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
    const digitsOnly = trimmed.replace(/[^0-9]/g, '');
    if (digitsOnly.length === 8) {
      const year = Number(digitsOnly.slice(0, 4));
      const month = Number(digitsOnly.slice(4, 6)) - 1;
      const day = Number(digitsOnly.slice(6, 8));
      const constructed = Date.UTC(year, month, day);
      return Number.isFinite(constructed) ? constructed : undefined;
    }
    if (digitsOnly.length === 12 || digitsOnly.length === 14) {
      const year = Number(digitsOnly.slice(0, 4));
      const month = Number(digitsOnly.slice(4, 6)) - 1;
      const day = Number(digitsOnly.slice(6, 8));
      const hour = Number(digitsOnly.slice(8, 10));
      const minute = Number(digitsOnly.slice(10, 12));
      const second = digitsOnly.length === 14 ? Number(digitsOnly.slice(12, 14)) : 0;
      const constructed = Date.UTC(year, month, day, hour, minute, second);
      return Number.isFinite(constructed) ? constructed : undefined;
    }
  }
  return undefined;
};

const formatDateInputValue = (timestamp?: number): string => {
  if (!Number.isFinite(timestamp)) {
    return '';
  }
  const date = new Date(timestamp as number);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

const startOfDateInput = (value: string): number | undefined => {
  if (!value) {
    return undefined;
  }
  const date = new Date(`${value}T00:00:00`);
  const time = date.getTime();
  return Number.isFinite(time) ? time : undefined;
};

const endOfDateInput = (value: string): number | undefined => {
  const start = startOfDateInput(value);
  if (start === undefined) {
    return undefined;
  }
  return start + DAY_IN_MS - 1;
};

const clampValue = (value: number, min: number, max: number): number => {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
};

const cloneEsriValue = (value: any): any => { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (value && typeof value === 'object') {
    const cloneFn = (value as any).clone; // eslint-disable-line @typescript-eslint/no-explicit-any
    if (typeof cloneFn === 'function') {
      try {
        return cloneFn.call(value);
      } catch (err) {
        console.warn('Clone via clone() failed, falling back to JSON:', err); // eslint-disable-line no-console
      }
    }
  }
  if (value === undefined || value === null) {
    return value;
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (err) {
    console.warn('Clone via JSON failed, returning original value:', err); // eslint-disable-line no-console
    return value;
  }
};

const formatDateLabel = (timestamp: number): string => {
  return new Date(timestamp).toLocaleDateString(undefined, {
    year: 'numeric',
    month: 'short',
    day: '2-digit'
  });
};

const formatDateTooltip = (timestamp: number): string => new Date(timestamp).toLocaleString();

interface WidgetState {
  kpiFeatures: Record<string, unknown>[];
  loading: boolean;
  error?: string;
  mapKpiField?: string;
  chartKpiFields: string[];
  applying: boolean;
  candidateKpiFields: string[];
  selectedCells: SelectedCell[];
  selecting: boolean;
  legendBreaks: LegendBreak[];
  legendExpression?: string;
  legendTitle?: string;
  dateRange?: { min: number; max: number };
  selectedDateRange?: { start: number; end: number };
}

const ensureFeatureLayer = async (
  ref: React.MutableRefObject<FeatureLayerConstructor | undefined>
): Promise<FeatureLayerConstructor> => {
  if (ref.current) {
    return ref.current;
  }
  const [FeatureLayer] = (await loadArcGISJSAPIModules([
    'esri/layers/FeatureLayer'
  ])) as [FeatureLayerConstructor];
  ref.current = FeatureLayer;
  return FeatureLayer;
};

const queryLayer = async (
  FeatureLayer: FeatureLayerConstructor,
  url: string,
  withGeometry = false
): Promise<QueryFeature[]> => {
  const layer = new FeatureLayer({ url });
  if (typeof layer.load === 'function') {
    await layer.load();
  }

  const features: QueryFeature[] = [];
  const capabilities = (layer as any)?.capabilities?.query ?? {}; // eslint-disable-line @typescript-eslint/no-explicit-any
  const supportsPagination = capabilities.supportsPagination !== false;
  const maxRecordCount = Number(capabilities.maxRecordCount) || 2000;
  const chunkSize = Math.max(1, Math.min(5000, maxRecordCount));
  const objectIdField = (layer as any).objectIdField as string | undefined; // eslint-disable-line @typescript-eslint/no-explicit-any

  if (supportsPagination) {
    let start = 0;
    let more = true;
    while (more) {
      const query = layer.createQuery();
      query.where = '1=1';
      query.outFields = ['*'];
      query.returnGeometry = withGeometry;
      query.start = start;
      query.num = chunkSize;
      if (objectIdField) {
        query.orderByFields = [`${objectIdField} ASC`];
      }

      const result = await layer.queryFeatures(query);
      features.push(...result.features);
      const fetched = result.features.length;
      const reachedEnd = !result.exceededTransferLimit || fetched === 0;
      if (reachedEnd) {
        more = false;
      } else {
        start += fetched;
      }
    }
  } else {
    const idQuery = layer.createQuery();
    idQuery.where = '1=1';
    if (objectIdField) {
      idQuery.outFields = [objectIdField];
      idQuery.returnGeometry = false;
    }
    if (typeof layer.queryObjectIds !== 'function') {
      // Fallback: single query with best effort
      const query = layer.createQuery();
      query.where = '1=1';
      query.outFields = ['*'];
      query.returnGeometry = withGeometry;
      query.returnExceededLimitFeatures = true;
      const result = await layer.queryFeatures(query);
      features.push(...result.features);
      return features;
    }

    const objectIds: number[] = await layer.queryObjectIds(idQuery);
    if (!objectIds || objectIds.length === 0) {
      return features;
    }
    for (let i = 0; i < objectIds.length; i += chunkSize) {
      const query = layer.createQuery();
      query.objectIds = objectIds.slice(i, i + chunkSize);
      query.outFields = ['*'];
      query.returnGeometry = withGeometry;
      const result = await layer.queryFeatures(query);
      features.push(...result.features);
    }
  }

  return features;
};

const Widget = (props: AllWidgetProps<IMConfig>): jsx.JSX.Element => {
  const { config } = props;
  const [state, setState] = React.useState<WidgetState>({
    kpiFeatures: [],
    loading: false,
    error: undefined,
    mapKpiField: undefined,
    chartKpiFields: [],
    applying: false,
    candidateKpiFields: [],
    selectedCells: [],
    selecting: false,
    legendBreaks: [],
    legendExpression: undefined,
    legendTitle: undefined,
    dateRange: undefined,
    selectedDateRange: undefined
  });
  const [kpiSeries, setKpiSeries] = React.useState<KpiSeriesEntry[]>([]);
  const [kpiTimeSeries, setKpiTimeSeries] = React.useState<KpiTimeSeriesEntry[]>([]);
  const [isChartOpen, setChartOpen] = React.useState(false);
  const chartContainerRef = React.useRef<HTMLDivElement | null>(null);
  const [chartWidth, setChartWidth] = React.useState<number>(0);
  const [legendExpanded, setLegendExpanded] = React.useState(false);
  const featureLayerCtorRef = React.useRef<FeatureLayerConstructor>();
  const cellsLayerRef = React.useRef<any>(); // auto-detected polygon layer containing eutrancellfdd // eslint-disable-line @typescript-eslint/no-explicit-any
  const selectionLayerRef = React.useRef<any>(); // temporary sketch graphics layer // eslint-disable-line @typescript-eslint/no-explicit-any
  const sketchViewModelRef = React.useRef<any>(); // eslint-disable-line @typescript-eslint/no-explicit-any
  const initialRendererRef = React.useRef<any>(); // eslint-disable-line @typescript-eslint/no-explicit-any
  const initialFeatureEffectRef = React.useRef<any>(); // eslint-disable-line @typescript-eslint/no-explicit-any
  const initialDefinitionExpressionRef = React.useRef<string | undefined>();
  const initialViewpointRef = React.useRef<any>(); // eslint-disable-line @typescript-eslint/no-explicit-any
  const [activeJimuMapView, setActiveJimuMapView] = React.useState<JimuMapView>();
  const mapWidgetId = props.useMapWidgetIds?.[0];


  const normalizeKey = React.useCallback((value: unknown): string | undefined => {
    if (value === null || value === undefined) {
      return undefined;
    }
    const text = String(value).trim();
    if (!text) {
      return undefined;
    }
    return text.toUpperCase();
  }, []);

  React.useEffect(() => {
    if (!config?.kpisUrl?.trim()) {
      setKpiSeries([]);
      setKpiTimeSeries([]);
      setChartOpen(false);
      setLegendExpanded(false);
      setState((prev: WidgetState) => {
        const alreadyCleared =
          prev.mapKpiField === undefined &&
          (!prev.chartKpiFields || prev.chartKpiFields.length === 0) &&
          (!prev.legendBreaks || prev.legendBreaks.length === 0) &&
          prev.legendExpression === undefined &&
          prev.legendTitle === undefined;
        if (alreadyCleared) {
          return prev;
        }
        return {
          ...prev,
          mapKpiField: undefined,
          chartKpiFields: [],
          legendBreaks: [],
          legendExpression: undefined,
          legendTitle: undefined
        };
      });
    }
  }, [config?.kpisUrl]);

  // Remove initial KPI data loading. Only load KPI data after polygon selection.

  // New function: fetch KPI data for selected EUTRANCELLFDDs
  const fetchKpiDataForCells = React.useCallback(async (cellKeys: string[]) => {
    const kpisUrl = config?.kpisUrl?.trim();
    if (!kpisUrl || cellKeys.length === 0) {
      setState((prev: WidgetState) => ({ ...prev, kpiFeatures: [], loading: false, error: undefined }));
      return;
    }
    setState((prev: WidgetState) => ({ ...prev, loading: true, error: undefined }));
    try {
      const FeatureLayer = await ensureFeatureLayer(featureLayerCtorRef);
      // Build where clause for selected cells
      const safeValues = cellKeys.map((key) => `'${String(key).replace(/'/g, "''")}'`);
      const where = safeValues.length === 1 ? `${KPI_JOIN_FIELD} = ${safeValues[0]}` : `${KPI_JOIN_FIELD} IN (${safeValues.join(', ')})`;
      const layer = new FeatureLayer({ url: kpisUrl });
      if (typeof layer.load === 'function') {
        await layer.load();
      }
      const query = layer.createQuery();
      query.where = where;
      query.outFields = ['*'];
      query.returnGeometry = false;
      const result = await layer.queryFeatures(query);
      const kpiFeatures = result.features.map((f: QueryFeature) => f.attributes);
      // derive candidate KPI fields
      const candidateKpiFields: string[] = (() => {
        if (kpiFeatures.length === 0) return [];
        const sample = kpiFeatures[0];
        const joinField = KPI_JOIN_FIELD;
        return Object.keys(sample)
          .filter(k => k !== joinField && !/^objectid/i.test(k))
          .filter(k => typeof (sample as any)[k] === 'number');
      })();
      const dateValues = kpiFeatures
        .map((item: Record<string, unknown>) => parseDateTimeValue((item as any).date_time_id))
        .filter((value: number | undefined): value is number => typeof value === 'number' && Number.isFinite(value));
      const derivedDateRange = dateValues.length > 0
        ? { min: Math.min(...dateValues), max: Math.max(...dateValues) }
        : undefined;
      setState((prev: WidgetState) => {
        let chartKpiFields = Array.isArray(prev.chartKpiFields)
          ? prev.chartKpiFields.filter((field: string) => candidateKpiFields.includes(field))
          : [];
        if (chartKpiFields.length === 0 && candidateKpiFields.length > 0) {
          chartKpiFields = [candidateKpiFields[0]];
        }

        let mapKpiField = prev.mapKpiField && candidateKpiFields.includes(prev.mapKpiField)
          ? prev.mapKpiField
          : undefined;

        if (!mapKpiField && chartKpiFields.length > 0) {
          mapKpiField = chartKpiFields[0];
        }

        if (mapKpiField && !chartKpiFields.includes(mapKpiField)) {
          chartKpiFields = [mapKpiField, ...chartKpiFields];
        }

        chartKpiFields = Array.from(new Set(chartKpiFields));

        return {
          ...prev,
          kpiFeatures,
          candidateKpiFields,
          mapKpiField,
          chartKpiFields,
          loading: false,
          error: undefined,
          dateRange: derivedDateRange,
          selectedDateRange: (() => {
            if (!derivedDateRange) {
              return undefined;
            }
            const previous = prev.selectedDateRange;
            const fallbackStart = clampValue(previous?.start ?? derivedDateRange.min, derivedDateRange.min, derivedDateRange.max);
            const fallbackEndRaw = clampValue(previous?.end ?? derivedDateRange.max, derivedDateRange.min, derivedDateRange.max);
            const fallbackEnd = Math.max(fallbackStart, fallbackEndRaw);
            return { start: fallbackStart, end: fallbackEnd };
          })()
        };
      });
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setState((prev: WidgetState) => ({ ...prev, loading: false, error: `Error loading data: ${message}` }));
      console.error('KPI query error:', err);
    }
  }, [config?.kpisUrl]);

  React.useEffect(() => () => {
    if (sketchViewModelRef.current) {
      try {
        sketchViewModelRef.current.destroy?.();
      } catch (err) {
        console.warn('Sketch destroy warning:', err); // eslint-disable-line no-console
      }
      sketchViewModelRef.current = undefined;
    }
  }, []);

  const restoreCellsLayerDefaults = React.useCallback((targetLayer?: any, options?: { preserveEffect?: boolean; preserveDefinitionExpression?: boolean }) => { // eslint-disable-line @typescript-eslint/no-explicit-any
    const layer = targetLayer ?? cellsLayerRef.current;
    if (!layer) {
      return;
    }

    const preserveEffect = Boolean(options?.preserveEffect);
    const preserveDefinitionExpression = Boolean(options?.preserveDefinitionExpression);

    const initialRenderer = initialRendererRef.current;
    const initialFeatureEffect = initialFeatureEffectRef.current;
    const initialDefinitionExpression = initialDefinitionExpressionRef.current;

    if (!preserveDefinitionExpression) {
      if (initialDefinitionExpression !== undefined || layer.definitionExpression !== initialDefinitionExpression) {
        layer.definitionExpression = initialDefinitionExpression;
      }
    }

    if (!preserveEffect) {
      if (initialFeatureEffect !== undefined) {
        layer.featureEffect = cloneEsriValue(initialFeatureEffect);
      } else if (layer.featureEffect) {
        layer.featureEffect = undefined;
      }
    }

    if (initialRenderer !== undefined) {
      layer.renderer = cloneEsriValue(initialRenderer);
    } else if (layer.renderer) {
      layer.renderer = undefined;
    }

    if (typeof layer.refresh === 'function') {
      layer.refresh();
    }
  }, []);

  const handleReload = React.useCallback(() => {
    if (selectionLayerRef.current?.removeAll) {
      selectionLayerRef.current.removeAll();
    }
    restoreCellsLayerDefaults();
    setKpiSeries([]);
    setKpiTimeSeries([]);
    setChartOpen(false);
    setLegendExpanded(false);
  }, [restoreCellsLayerDefaults]);

  const handleActiveViewChange = React.useCallback((jmv: JimuMapView) => {
    if (sketchViewModelRef.current) {
      try {
        sketchViewModelRef.current.destroy?.();
      } catch (err) {
        console.warn('Sketch destroy warning:', err); // eslint-disable-line no-console
      }
    }

    const previousSelectionLayer = selectionLayerRef.current;
    if (previousSelectionLayer?.removeAll) {
      previousSelectionLayer.removeAll();
    }
    const previousView = activeJimuMapView?.view as any; // eslint-disable-line @typescript-eslint/no-explicit-any
    if (previousSelectionLayer && previousView?.map?.remove) {
      try {
        previousView.map.remove(previousSelectionLayer);
      } catch (err) {
        console.warn('Selection layer remove warning:', err); // eslint-disable-line no-console
      }
    }

    restoreCellsLayerDefaults();

    selectionLayerRef.current = undefined;
    sketchViewModelRef.current = undefined;
    cellsLayerRef.current = undefined;
    initialRendererRef.current = undefined;
    initialFeatureEffectRef.current = undefined;
    initialDefinitionExpressionRef.current = undefined;

    const view = jmv?.view as any; // eslint-disable-line @typescript-eslint/no-explicit-any
    if (view) {
      const mapInitial = view?.map?.initialViewProperties?.viewpoint;
      if (mapInitial) {
        initialViewpointRef.current = cloneEsriValue(mapInitial);
      } else if (view.viewpoint) {
        initialViewpointRef.current = cloneEsriValue(view.viewpoint);
      } else {
        initialViewpointRef.current = undefined;
      }
      if (typeof view.when === 'function' && !initialViewpointRef.current) {
        view.when(() => {
          if (!initialViewpointRef.current) {
            const readyInitial = view?.map?.initialViewProperties?.viewpoint ?? view?.viewpoint;
            if (readyInitial) {
              initialViewpointRef.current = cloneEsriValue(readyInitial);
            }
          }
        }).catch((err: Error) => {
          console.warn('View when() failed while capturing initial viewpoint:', err); // eslint-disable-line no-console
        });
      }
    } else {
      initialViewpointRef.current = undefined;
    }

    setState((prev: WidgetState) => ({
      ...prev,
      selectedCells: [],
      selecting: false,
      legendBreaks: [],
      legendExpression: undefined,
      legendTitle: undefined
    }));
    setKpiSeries([]);
    setKpiTimeSeries([]);
    setChartOpen(false);
    setLegendExpanded(false);
    setActiveJimuMapView(jmv);
  }, [activeJimuMapView, restoreCellsLayerDefaults]);

  // No local map preview; renderer updates target the detected polygon cells layer in the main map widget

  // Auto-detect polygon layer that contains the join field for spatial selection
  const getCellsLayer = React.useCallback(async () => {
    if (!activeJimuMapView || !activeJimuMapView.view) {
      throw new Error('Map widget not ready. Ensure the selected map widget is active.');
    }
    const joinFieldName = POLYGON_CELL_FIELD;
    const mapView = activeJimuMapView.view as any; // eslint-disable-line @typescript-eslint/no-explicit-any
    const map = mapView?.map;
    if (!map) {
      throw new Error('Map instance not available.');
    }
    // Reuse if already resolved
    if (cellsLayerRef.current) {
      return cellsLayerRef.current;
    }
    const kpiUrl = config?.kpisUrl?.trim()?.toLowerCase();
    const all: any[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any
    if (map.allLayers?.toArray) {
      all.push(...map.allLayers.toArray());
    } else if (map.layers?.toArray) {
      all.push(...map.layers.toArray());
    } else if (map.layers?.items) {
      all.push(...map.layers.items);
    }
    const featureCandidates = all.filter((layer: any) => {
      const typeOk = (layer.type === 'feature' || layer.declaredClass?.includes('FeatureLayer'));
      const geomType = (layer.geometryType || '').toLowerCase();
      const isPolygon = geomType === 'polygon' || geomType === 'esriGeometryPolygon';
      const layerUrl = layer.url?.toLowerCase?.();
      const notKpi = !kpiUrl || layerUrl !== kpiUrl; // avoid picking KPI table
      return typeOk && isPolygon && notKpi;
    });
    // Load & inspect for join field
    for (const layer of featureCandidates) {
      try {
        if (layer.when) { await layer.when(); }
        const fields: any[] = layer.fields || []; // eslint-disable-line @typescript-eslint/no-explicit-any
        const hasJoin = fields.some(f => (f?.name?.toLowerCase?.() ?? '') === joinFieldName.toLowerCase());
        if (hasJoin) {
          cellsLayerRef.current = layer;
          initialRendererRef.current = cloneEsriValue(layer.renderer);
          initialFeatureEffectRef.current = cloneEsriValue(layer.featureEffect);
          initialDefinitionExpressionRef.current = layer.definitionExpression;
          return layer;
        }
      } catch (err) {
        console.warn('Cells layer candidate load failed, skipping:', err); // eslint-disable-line no-console
      }
    }
  throw new Error(`No polygon layer with '${POLYGON_CELL_FIELD}' field found in the map. Add such a layer to the map.`);
  }, [activeJimuMapView, config?.kpisUrl]);

  const handleSelectionGeometry = React.useCallback(async (geometry: any) => { // eslint-disable-line @typescript-eslint/no-explicit-any
    try {
      const cellsLayer = await getCellsLayer();
      if (!cellsLayer?.createQuery) {
        throw new Error('Cells polygon layer does not support querying.');
      }
      const joinField = POLYGON_CELL_FIELD;
      const query = cellsLayer.createQuery();
      query.geometry = geometry;
      query.spatialRelationship = 'intersects';
      query.outFields = [joinField];
      query.returnGeometry = false;
      const result = await cellsLayer.queryFeatures(query);
      const valueMap = new Map<string, string>();
      result.features.forEach((feature: QueryFeature) => {
        const raw = feature.attributes?.[joinField];
        const key = normalizeKey(raw);
        if (raw && key && !valueMap.has(key)) {
          valueMap.set(key, raw);
        }
      });

      const selectedCells: SelectedCell[] = Array.from(valueMap.entries()).map(([key, raw]) => ({ key, raw }));
      if (selectedCells.length === 0) {
        restoreCellsLayerDefaults();
        setState((prev: WidgetState) => ({
          ...prev,
          selectedCells: [],
          legendBreaks: [],
          legendExpression: undefined,
          legendTitle: undefined,
          error: 'No features found inside the drawn area.'
        }));
        setKpiSeries([]);
        setKpiTimeSeries([]);
        setChartOpen(false);
        setLegendExpanded(false);
        return;
      }
      const safeValues = selectedCells.map((cell: SelectedCell) => `'${String(cell.raw).replace(/'/g, "''")}'`);
      const where = safeValues.length === 1 ? `${joinField} = ${safeValues[0]}` : `${joinField} IN (${safeValues.join(', ')})`;
      if (cellsLayerRef.current) {
        restoreCellsLayerDefaults(cellsLayerRef.current, { preserveEffect: true });
        cellsLayerRef.current.featureEffect = {
          filter: { where },
          includedEffect: 'opacity(100%)',
          excludedEffect: 'opacity(90%)'
        };
        if (typeof cellsLayerRef.current.refresh === 'function') {
          cellsLayerRef.current.refresh();
        }
      }
      setState((prev: WidgetState) => ({
        ...prev,
        selectedCells,
        legendBreaks: [],
        legendExpression: undefined,
        legendTitle: undefined,
        error: undefined
      }));
      setKpiSeries([]);
      setKpiTimeSeries([]);
      setChartOpen(false);
      setLegendExpanded(false);
      // Fetch KPI data for selected cells
      const cellKeys = selectedCells.map(cell => cell.key);
      fetchKpiDataForCells(cellKeys);
    } catch (err) {
      console.error('Selection processing error', err);
      setState((prev: WidgetState) => ({
        ...prev,
        selectedCells: [],
        error: err instanceof Error ? err.message : String(err)
      }));
      setKpiSeries([]);
      setKpiTimeSeries([]);
      setChartOpen(false);
      setLegendExpanded(false);
    }
  }, [getCellsLayer, normalizeKey, restoreCellsLayerDefaults]);

  const startSelection = React.useCallback(async () => {
    if (!activeJimuMapView || !activeJimuMapView.view) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Map widget not ready. Ensure the selected map widget is active.' }));
      return;
    }
    try {
      setState((prev: WidgetState) => ({ ...prev, selecting: true, error: undefined }));
      const cellsLayer = await getCellsLayer();
      restoreCellsLayerDefaults(cellsLayer, { preserveDefinitionExpression: true });

      const [SketchViewModel, GraphicsLayer] = (await loadArcGISJSAPIModules([
        'esri/widgets/Sketch/SketchViewModel',
        'esri/layers/GraphicsLayer'
      ])) as [any, any]; // eslint-disable-line @typescript-eslint/no-explicit-any

      const view = activeJimuMapView.view as any; // eslint-disable-line @typescript-eslint/no-explicit-any
      if (!selectionLayerRef.current) {
        selectionLayerRef.current = new GraphicsLayer({ listMode: 'hide' });
        if (view?.map?.add) {
          view.map.add(selectionLayerRef.current);
        }
      } else if (selectionLayerRef.current?.removeAll) {
        selectionLayerRef.current.removeAll();
      }

      if (sketchViewModelRef.current) {
        try {
          sketchViewModelRef.current.destroy?.();
        } catch (err) {
          console.warn('Sketch destroy warning:', err); // eslint-disable-line no-console
        }
      }

      const sketchViewModel = new SketchViewModel({
        view,
        layer: selectionLayerRef.current
      });
      sketchViewModelRef.current = sketchViewModel;

      const handle = sketchViewModel.on('create', async (event: any) => { // eslint-disable-line @typescript-eslint/no-explicit-any
        if (event.state === 'complete') {
          handle.remove();
          sketchViewModel.cancel?.();
          sketchViewModel.destroy?.();
          sketchViewModelRef.current = undefined;
          try {
            await handleSelectionGeometry(event.graphic?.geometry);
          } finally {
            setState((prev: WidgetState) => ({ ...prev, selecting: false }));
          }
        } else if (event.state === 'cancel') {
          handle.remove();
          sketchViewModel.cancel?.();
          sketchViewModel.destroy?.();
          sketchViewModelRef.current = undefined;
          setState((prev: WidgetState) => ({ ...prev, selecting: false }));
        }
      });

      sketchViewModel.create('polygon');
    } catch (err) {
      console.error('Selection tool error', err);
      setState((prev: WidgetState) => ({
        ...prev,
        selecting: false,
        error: err instanceof Error ? err.message : String(err)
      }));
    }
  }, [activeJimuMapView, getCellsLayer, handleSelectionGeometry, restoreCellsLayerDefaults]);

  const clearSelection = React.useCallback(() => {
    if (selectionLayerRef.current?.removeAll) {
      selectionLayerRef.current.removeAll();
    }
    if (sketchViewModelRef.current) {
      try {
        sketchViewModelRef.current.cancel?.();
        sketchViewModelRef.current.destroy?.();
      } catch (err) {
        console.warn('Sketch destroy warning:', err); // eslint-disable-line no-console
      }
      sketchViewModelRef.current = undefined;
    }

    const resetLayerState = async () => {
      if (cellsLayerRef.current) {
        restoreCellsLayerDefaults(cellsLayerRef.current);
        return;
      }
      try {
        const layer = await getCellsLayer();
        restoreCellsLayerDefaults(layer);
      } catch (err) {
        console.warn('Cells layer restoration skipped:', err); // eslint-disable-line no-console
      }
    };
    void resetLayerState();

    const view = activeJimuMapView.view as any; // eslint-disable-line @typescript-eslint/no-explicit-any
    if (view && initialViewpointRef.current) {
      try {
        const goToResult = view.goTo(initialViewpointRef.current);
        if (goToResult && typeof goToResult.catch === 'function') {
          goToResult.catch((err: Error) => {
            console.warn('Initial view restore warning:', err); // eslint-disable-line no-console
          });
        }
      } catch (err) {
        console.warn('Initial view restore immediate failure:', err); // eslint-disable-line no-console
      }
    }

    setState((prev: WidgetState) => ({
      ...prev,
      selectedCells: [],
      selecting: false,
      legendBreaks: [],
      legendExpression: undefined,
      legendTitle: undefined,
      error: undefined
    }));
    setKpiSeries([]);
    setKpiTimeSeries([]);
    setChartOpen(false);
    setLegendExpanded(false);
  }, [activeJimuMapView, getCellsLayer, restoreCellsLayerDefaults]);

  React.useEffect(() => {
    if (kpiSeries.length === 0) {
      setChartOpen(false);
      if (kpiTimeSeries.length > 0) {
        setKpiTimeSeries([]);
      }
      if (legendExpanded) {
        setLegendExpanded(false);
      }
    }
  }, [kpiSeries.length, kpiTimeSeries.length, legendExpanded]);

  const applyLegendRenderer = React.useCallback(async (legendBreaks: LegendBreak[], legendExpression: string, legendTitle: string) => {
    if (!legendExpression || !legendBreaks || legendBreaks.length === 0) {
      throw new Error('Legend is not configured. Apply KPI first.');
    }
    const layer = await getCellsLayer();
    if (!layer) {
      throw new Error('Cells layer is unavailable. Draw an area again to re-detect the polygon layer.');
    }
    const classBreakInfos = legendBreaks.map((b: LegendBreak) => ({
      minValue: Number.isFinite(b.minValue) ? b.minValue : 0,
      maxValue: Number.isFinite(b.maxValue) ? b.maxValue : 0,
      label: formatLegendLabel(b.minValue, b.maxValue) || b.label || '',
      symbol: {
        type: 'simple-fill',
        color: b.color || '#999999',
        outline: { color: '#999', width: 0.25 }
      }
    }));

    const renderer = {
      type: 'class-breaks',
      valueExpression: legendExpression,
      valueExpressionTitle: legendTitle,
      classBreakInfos,
      defaultSymbol: {
        type: 'simple-fill',
        color: [210, 210, 210, 0.35],
        outline: { color: '#bbb', width: 0.25 }
      },
      defaultLabel: 'Outside selection'
    };

    layer.renderer = renderer;
    if (typeof layer.refresh === 'function') {
      layer.refresh();
    }
  }, [getCellsLayer]);

  const handleLegendBreakChange = React.useCallback((index: number, field: 'minValue' | 'maxValue' | 'color', rawValue: string) => {
    setState((prev: WidgetState) => {
      if (!prev.legendBreaks || !prev.legendBreaks[index]) {
        return prev;
      }
      const legendBreaks = prev.legendBreaks.map((breakInfo: LegendBreak, i: number) => {
        if (i !== index) {
          return breakInfo;
        }
        const updated: LegendBreak = { ...breakInfo };
        if (field === 'color') {
          updated.color = rawValue;
        } else {
          if (rawValue === '') {
            return updated;
          }
          const numeric = Number(rawValue);
          if (!Number.isFinite(numeric)) {
            return updated;
          }
          if (field === 'minValue') {
            updated.minValue = numeric;
          } else if (field === 'maxValue') {
            updated.maxValue = numeric;
          }
        }
        updated.label = formatLegendLabel(updated.minValue, updated.maxValue);
        return updated;
      });
      return { ...prev, legendBreaks };
    });
  }, []);

  const applyLegendUpdates = React.useCallback(async () => {
    const legendBreaks = state.legendBreaks ?? [];
    const legendExpression = state.legendExpression;
    const legendTitle = state.legendTitle;

    if (!legendBreaks || legendBreaks.length === 0 || !legendExpression || !legendTitle) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Apply a KPI before updating the legend.' }));
      return;
    }

    const hasInvalid = legendBreaks.some((b: LegendBreak) => !Number.isFinite(b.minValue) || !Number.isFinite(b.maxValue));
    if (hasInvalid) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Legend ranges must be numeric values.' }));
      return;
    }

    const hasReversed = legendBreaks.some((b: LegendBreak) => b.maxValue < b.minValue);
    if (hasReversed) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Each legend range must have Max â‰¥ Min.' }));
      return;
    }

    const sortedBreaks = legendBreaks
      .map((b: LegendBreak) => ({ ...b }))
      .sort((a: LegendBreak, b: LegendBreak) => a.minValue - b.minValue)
      .map((b: LegendBreak) => ({
        ...b,
        label: formatLegendLabel(b.minValue, b.maxValue)
      }));

    try {
      await applyLegendRenderer(sortedBreaks, legendExpression, legendTitle);
      setState((prev: WidgetState) => ({
        ...prev,
        legendBreaks: sortedBreaks,
        error: undefined
      }));
    } catch (err) {
      console.error('Legend update error', err);
      setState((prev: WidgetState) => ({
        ...prev,
        error: err instanceof Error ? err.message : String(err)
      }));
    }
  }, [applyLegendRenderer, state.legendBreaks, state.legendExpression, state.legendTitle]);

  const applyKpi = React.useCallback(async () => {
    const mapKpiField = state.mapKpiField;
    const selectedCells = state.selectedCells ?? [];
    const chartKpiFields = Array.isArray(state.chartKpiFields)
      ? state.chartKpiFields.filter((field: string) => Boolean(field))
      : [];

    if (!mapKpiField) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Select a KPI to colorize the map before applying.' }));
      return;
    }
    if (chartKpiFields.length === 0) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Pick at least one KPI to plot in the chart.' }));
      return;
    }
    if (!config?.kpisUrl?.trim()) {
      return;
    }
    if (!activeJimuMapView || !activeJimuMapView.view) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Map widget not ready. Ensure the selected map widget is active.' }));
      return;
    }
    if (!selectedCells || selectedCells.length === 0) {
      setState((prev: WidgetState) => ({ ...prev, error: 'Draw a selection area before applying KPIs.' }));
      return;
    }
    setState((prev: WidgetState) => ({ ...prev, applying: true }));
    try {
      const FeatureLayer = await ensureFeatureLayer(featureLayerCtorRef);
      const kpiJoinField = KPI_JOIN_FIELD;
      const polygonField = POLYGON_CELL_FIELD;
      const analysisFields = Array.from(new Set([...chartKpiFields, mapKpiField]));

      const safeValues = selectedCells.map((cell: SelectedCell) => `'${String(cell.raw).replace(/'/g, "''")}'`);
      const whereClause = safeValues.length === 1 ? `${kpiJoinField} = ${safeValues[0]}` : `${kpiJoinField} IN (${safeValues.join(', ')})`;
      const kpiLayer = new FeatureLayer({ url: config.kpisUrl.trim() });
      if (kpiLayer.load) { await kpiLayer.load(); }
      const kpiQuery = kpiLayer.createQuery();
      kpiQuery.where = whereClause;
      kpiQuery.outFields = Array.from(new Set([...analysisFields, kpiJoinField, 'date_time_id']));
      kpiQuery.returnGeometry = false;
      const kpiResult = await kpiLayer.queryFeatures(kpiQuery);
      const kpiFeaturesResult = kpiResult.features;
      const selectedKeys = new Set(selectedCells.map((cell: SelectedCell) => cell.key));
      if (selectedKeys.size === 0) {
        throw new Error('Selection is empty. Draw an area covering the polygons you want to analyze.');
      }

      const labelByKey = new Map<string, string>(selectedCells.map((cell: SelectedCell) => [cell.key, cell.raw ?? cell.key]));
      const activeDateRange = state.selectedDateRange ?? state.dateRange;

      const aggregatedByKpi = new Map<string, Map<number, { sum: number; count: number }>>();
      chartKpiFields.forEach((field: string) => aggregatedByKpi.set(field, new Map()));
      const mapSeriesByCell = new Map<string, { label: string; points: KpiTimeSeriesPoint[] }>();

      kpiFeaturesResult.forEach((feature: QueryFeature) => {
        const attributes = feature.attributes ?? {};
        const rawKey = attributes[kpiJoinField];
        const key = normalizeKey(rawKey);
        if (!key || !selectedKeys.has(key)) {
          return;
        }

        const timestamp = parseDateTimeValue(attributes.date_time_id);
        if (timestamp === undefined || !Number.isFinite(timestamp)) {
          return;
        }
        if (activeDateRange && (timestamp < activeDateRange.start || timestamp > activeDateRange.end)) {
          return;
        }

        const label = labelByKey.get(key) ?? (rawKey ? String(rawKey) : key);

        const mapValue = attributes[mapKpiField];
        if (typeof mapValue === 'number' && Number.isFinite(mapValue)) {
          const point: KpiTimeSeriesPoint = {
            timestamp,
            value: mapValue,
            displayLabel: formatDateLabel(timestamp),
            tooltipLabel: formatDateTooltip(timestamp)
          };
          const existingSeries = mapSeriesByCell.get(key);
          if (existingSeries) {
            existingSeries.points.push(point);
          } else {
            mapSeriesByCell.set(key, { label, points: [point] });
          }
        }

        chartKpiFields.forEach((field: string) => {
          const rawValue = attributes[field];
          if (typeof rawValue !== 'number' || !Number.isFinite(rawValue)) {
            return;
          }
          const seriesMap = aggregatedByKpi.get(field);
          if (!seriesMap) {
            return;
          }
          const bucket = seriesMap.get(timestamp) ?? { sum: 0, count: 0 };
          bucket.sum += rawValue;
          bucket.count += 1;
          seriesMap.set(timestamp, bucket);
        });
      });

      const chartSeriesEntries = chartKpiFields
        .map((field: string): KpiTimeSeriesEntry | null => {
          const seriesMap = aggregatedByKpi.get(field);
          if (!seriesMap || seriesMap.size === 0) {
            return null;
          }
          const points = Array.from(seriesMap.entries())
            .map(([timestamp, stats]) => {
              const average = stats.count === 0 ? NaN : stats.sum / stats.count;
              return {
                timestamp,
                value: average,
                displayLabel: formatDateLabel(timestamp),
                tooltipLabel: formatDateTooltip(timestamp)
              } as KpiTimeSeriesPoint;
            })
            .filter((point) => Number.isFinite(point.value))
            .sort((a, b) => a.timestamp - b.timestamp);
          if (points.length === 0) {
            return null;
          }
          return {
            key: field,
            label: field,
            points
          };
  })
  .filter((entry: KpiTimeSeriesEntry | null): entry is KpiTimeSeriesEntry => entry !== null);

      if (chartSeriesEntries.length === 0) {
        throw new Error('No KPI time series data was returned for the selected KPIs. Adjust the filters or choose different KPIs.');
      }

      const mapSeriesEntries = Array.from(mapSeriesByCell.entries())
        .map(([key, data]) => ({
          key,
          label: data.label,
          points: data.points
            .slice()
            .sort((a: KpiTimeSeriesPoint, b: KpiTimeSeriesPoint) => a.timestamp - b.timestamp)
        }))
        .filter((entry: KpiTimeSeriesEntry) => entry.points.length > 0);

      if (mapSeriesEntries.length === 0) {
        throw new Error('No KPI values matched the selected polygons for the chosen date range.');
      }

      const summaryEntries: KpiSeriesEntry[] = mapSeriesEntries
        .map((entry: KpiTimeSeriesEntry) => {
          const lastPoint = entry.points[entry.points.length - 1];
          if (!lastPoint) {
            return null;
          }
          return {
            key: entry.key,
            label: entry.label,
            value: lastPoint.value
          } as KpiSeriesEntry;
        })
        .filter((entry: KpiSeriesEntry | null): entry is KpiSeriesEntry => entry !== null);

      if (summaryEntries.length === 0) {
        throw new Error('No KPI summary values could be derived.');
      }

      const decodeArgs: string[] = [];
      const values: number[] = summaryEntries.map((entry: KpiSeriesEntry) => {
        const safeKey = entry.key.replace(/"/g, '\\"');
        decodeArgs.push(`"${safeKey}"`, `${entry.value}`);
        return entry.value;
      });

      const min = Math.min(...values);
      const max = Math.max(...values);
      const classCount = DEFAULT_LEGEND_COLORS.length;
      const interval = classCount > 0 ? (max - min) / classCount : 0;
      const breaks: { minValue: number; maxValue: number }[] = [];
      for (let i = 0; i < classCount; i++) {
        const bMin = min + interval * i;
        const bMax = i === classCount - 1 ? max : min + interval * (i + 1);
        breaks.push({ minValue: bMin, maxValue: bMax });
      }
      const legendBreaks = breaks.map((b, i) => ({
        minValue: b.minValue,
        maxValue: b.maxValue,
        color: DEFAULT_LEGEND_COLORS[i] || DEFAULT_LEGEND_COLORS[DEFAULT_LEGEND_COLORS.length - 1] || '#800026',
        label: formatLegendLabel(b.minValue, b.maxValue)
      }));

      const expressionField = polygonField.replace(/"/g, '\"');
      const valueExpression = `Decode(Upper(Trim(Text($feature.${expressionField}))), ${decodeArgs.join(', ')}, Null)`;
      await applyLegendRenderer(legendBreaks, valueExpression, mapKpiField);

      const chartEntriesSorted = summaryEntries
        .slice()
        .sort((a: KpiSeriesEntry, b: KpiSeriesEntry) => b.value - a.value);
      setKpiTimeSeries(chartSeriesEntries);
      setKpiSeries(chartEntriesSorted);
      setLegendExpanded(false);

      setState((prev: WidgetState) => ({
        ...prev,
        error: undefined,
        legendBreaks,
        legendExpression: valueExpression,
        legendTitle: mapKpiField
      }));
    } catch (err) {
      console.error('Apply KPI error', err);
      setState((prev: WidgetState) => ({ ...prev, error: err instanceof Error ? err.message : String(err) }));
      setKpiSeries([]);
      setKpiTimeSeries([]);
      setChartOpen(false);
      setLegendExpanded(false);
    } finally {
      setState((prev: WidgetState) => ({ ...prev, applying: false }));
    }
  }, [
    config?.kpisUrl,
    state.mapKpiField,
    state.chartKpiFields,
    state.selectedCells,
    state.selectedDateRange,
    state.dateRange,
    activeJimuMapView,
    applyLegendRenderer,
    normalizeKey
  ]);

  const handleChartKpiToggle = React.useCallback((field: string, checked: boolean) => {
    restoreCellsLayerDefaults(undefined, { preserveEffect: true });
    setState((prev: WidgetState) => {
      const current = Array.isArray(prev.chartKpiFields) ? prev.chartKpiFields.slice() : [];
      let nextChart: string[];
      if (checked) {
        if (current.includes(field)) {
          nextChart = current;
        } else {
          nextChart = [...current, field];
        }
      } else {
        nextChart = current.filter((item: string) => item !== field);
        if (nextChart.length === 0) {
          return prev; // must keep at least one KPI selected
        }
      }

      let mapKpiField = prev.mapKpiField;
      if (!mapKpiField || !nextChart.includes(mapKpiField)) {
        mapKpiField = nextChart[0];
      }

      return {
        ...prev,
        chartKpiFields: nextChart,
        mapKpiField,
        legendBreaks: [],
        legendExpression: undefined,
        legendTitle: undefined
      };
    });
    setKpiSeries([]);
    setKpiTimeSeries([]);
    setChartOpen(false);
    setLegendExpanded(false);
  }, [restoreCellsLayerDefaults]);

  const handleMapKpiChange = React.useCallback((field: string) => {
    restoreCellsLayerDefaults(undefined, { preserveEffect: true });
    setState((prev: WidgetState) => {
      const current = Array.isArray(prev.chartKpiFields) ? prev.chartKpiFields.slice() : [];
      const nextChart = current.includes(field) ? current : [...current, field];
      return {
        ...prev,
        mapKpiField: field,
        chartKpiFields: nextChart,
        legendBreaks: [],
        legendExpression: undefined,
        legendTitle: undefined
      };
    });
    setKpiSeries([]);
    setKpiTimeSeries([]);
    setChartOpen(false);
    setLegendExpanded(false);
  }, [restoreCellsLayerDefaults]);

  const handleDateInputChange = React.useCallback((field: 'start' | 'end', rawValue: string) => {
    let didUpdate = false;
    setState((prev: WidgetState) => {
      const baseRange = prev.dateRange;
      if (!baseRange) {
        return prev;
      }
      const current = prev.selectedDateRange ?? { start: baseRange.min, end: baseRange.max };
      let start = current.start;
      let end = current.end;

      if (field === 'start') {
        const parsed = startOfDateInput(rawValue);
        if (parsed === undefined) {
          return prev;
        }
        const clampedStart = clampValue(parsed, baseRange.min, baseRange.max);
        if (clampedStart === start) {
          return prev;
        }
        start = clampedStart;
        if (start > end) {
          end = start;
        }
      } else {
        const parsed = endOfDateInput(rawValue);
        if (parsed === undefined) {
          return prev;
        }
        const clampedEnd = clampValue(parsed, baseRange.min, baseRange.max);
        if (clampedEnd === end) {
          return prev;
        }
        end = clampedEnd;
        if (end < start) {
          start = end;
        }
      }

      didUpdate = true;
      return {
        ...prev,
        selectedDateRange: { start, end },
        legendBreaks: [],
        legendExpression: undefined,
        legendTitle: undefined
      };
    });

    if (didUpdate) {
      restoreCellsLayerDefaults(undefined, { preserveEffect: true });
      setKpiSeries([]);
      setKpiTimeSeries([]);
      setChartOpen(false);
      setLegendExpanded(false);
    }
  }, [restoreCellsLayerDefaults, setState, setChartOpen, setKpiSeries, setKpiTimeSeries, setLegendExpanded]);

  const kpisUrlConfigured = Boolean(config?.kpisUrl?.trim());
  const kpiFeatures = Array.isArray(state.kpiFeatures) ? state.kpiFeatures : [];
  const candidateKpiFields = Array.isArray(state.candidateKpiFields) ? state.candidateKpiFields : [];
  const {
    loading,
    error,
    mapKpiField,
    chartKpiFields: stateChartKpiFields = [],
    applying,
    selecting,
    selectedCells,
    legendBreaks = [],
    legendExpression,
    legendTitle,
    dateRange,
    selectedDateRange
  } = state;
  const chartKpiFields = Array.isArray(stateChartKpiFields) ? stateChartKpiFields : [];
  const hasDateRange = Boolean(dateRange);
  const effectiveSelectedRange = selectedDateRange ?? (dateRange ? { start: dateRange.min, end: dateRange.max } : undefined);
  const dateStartValue = formatDateInputValue(effectiveSelectedRange?.start);
  const dateEndValue = formatDateInputValue(effectiveSelectedRange?.end);
  const dateMinValue = formatDateInputValue(dateRange?.min);
  const dateMaxValue = formatDateInputValue(dateRange?.max);
  const rangeSummaryStart = effectiveSelectedRange ? formatDateLabel(effectiveSelectedRange.start) : '';
  const rangeSummaryEnd = effectiveSelectedRange ? formatDateLabel(effectiveSelectedRange.end) : '';

  const hasBaseKpiData = kpiSeries.length > 0 && kpiTimeSeries.length > 0;
  const canApplyKpi = Boolean(mapKpiField && chartKpiFields.length > 0 && selectedCells.length > 0);
  const selectedChartKpiList = chartKpiFields.join(', ');
  const chartSeries = kpiTimeSeries;
  const hasChartData = chartSeries.some((series: KpiTimeSeriesEntry) => series.points.length > 0);
  const chartHeight = 240;
  const chartMargins = { top: 16, right: 24, bottom: 46, left: 56 };
  const chartDomain = React.useMemo(() => {
    if (!hasChartData) {
      return undefined;
    }
    const allPoints = chartSeries.flatMap((series: KpiTimeSeriesEntry) => series.points);
    if (allPoints.length === 0) {
      return undefined;
    }
    const minTime = Math.min(...allPoints.map((point: KpiTimeSeriesPoint) => point.timestamp));
    const maxTime = Math.max(...allPoints.map((point: KpiTimeSeriesPoint) => point.timestamp));
    const minValue = Math.min(...allPoints.map((point: KpiTimeSeriesPoint) => point.value));
    const maxValue = Math.max(...allPoints.map((point: KpiTimeSeriesPoint) => point.value));
    return { minTime, maxTime, minValue, maxValue };
  }, [chartSeries, hasChartData]);

  const chartScales = React.useMemo(() => {
    if (!chartDomain) {
      return undefined;
    }
  const measuredWidth = chartWidth || 0;
  const width = measuredWidth > 0 ? measuredWidth : 320;
    const innerWidth = Math.max(width - chartMargins.left - chartMargins.right, 1);
    const innerHeight = Math.max(chartHeight - chartMargins.top - chartMargins.bottom, 1);
    const timeRange = chartDomain.maxTime - chartDomain.minTime;
    const baseValueRange = chartDomain.maxValue - chartDomain.minValue;
    const padding = baseValueRange === 0
      ? Math.max(Math.abs(chartDomain.maxValue) * 0.1, 1)
      : baseValueRange * 0.1;
    const minValue = chartDomain.minValue - padding;
    const maxValue = chartDomain.maxValue + padding;
    const valueRange = maxValue - minValue || 1;
    const getX = (timestamp: number) => {
      if (timeRange === 0) {
        return chartMargins.left + innerWidth / 2;
      }
      return chartMargins.left + ((timestamp - chartDomain.minTime) / timeRange) * innerWidth;
    };
    const getY = (value: number) => {
      return chartMargins.top + innerHeight - ((value - minValue) / valueRange) * innerHeight;
    };
    return { width, innerWidth, innerHeight, getX, getY, minValue, maxValue };
  }, [chartDomain, chartWidth, chartMargins.left, chartMargins.right, chartMargins.top, chartMargins.bottom, chartHeight]);

  const preparedChartSeries = React.useMemo<PreparedChartSeries[]>(() => {
    if (!chartScales || !chartDomain) {
      return [];
    }
    return chartSeries.map((series: KpiTimeSeriesEntry, index: number) => {
      const coordinates: ChartSeriesCoordinates[] = series.points.map((point: KpiTimeSeriesPoint) => ({
        point,
        x: chartScales.getX(point.timestamp),
        y: chartScales.getY(point.value)
      }));
      const path = coordinates
        .map((coord: ChartSeriesCoordinates, coordIndex: number) => `${coordIndex === 0 ? 'M' : 'L'}${coord.x},${coord.y}`)
        .join(' ');
      return {
        key: series.key,
        label: series.label,
        color: getColorForIndex(index),
        path,
        coordinates
      };
    });
  }, [chartSeries, chartScales, chartDomain]);

  const axisTicks = React.useMemo(() => {
    if (!chartScales || !chartDomain) {
      return { xTicks: [] as { x: number; label: string }[], yTicks: [] as { y: number; label: string }[] };
    }
    const xTicks: { x: number; label: string }[] = [];
    const xTickCount = 4;
    for (let i = 0; i <= xTickCount; i++) {
      const ratio = i / xTickCount;
      const timestamp = chartDomain.minTime + ratio * (chartDomain.maxTime - chartDomain.minTime);
      xTicks.push({ x: chartScales.getX(timestamp), label: formatDateLabel(timestamp) });
    }

    const yTicks: { y: number; label: string }[] = [];
    const yTickCount = 5;
    for (let i = 0; i <= yTickCount; i++) {
      const ratio = i / yTickCount;
      const value = chartScales.minValue + ratio * (chartScales.maxValue - chartScales.minValue);
      yTicks.push({ y: chartScales.getY(value), label: formatKpiValue(value) });
    }
    return { xTicks, yTicks };
  }, [chartScales, chartDomain]);

  const chartSummary = React.useMemo(() => {
    if (!chartDomain) {
      return { min: 0, max: 0, points: 0 };
    }
    const allPoints = chartSeries.flatMap((series: KpiTimeSeriesEntry) => series.points);
    if (allPoints.length === 0) {
      return { min: 0, max: 0, points: 0 };
    }
    const min = Math.min(...allPoints.map((point: KpiTimeSeriesPoint) => point.value));
    const max = Math.max(...allPoints.map((point: KpiTimeSeriesPoint) => point.value));
    return { min, max, points: allPoints.length };
  }, [chartSeries, chartDomain]);

  const chartSvgWidth = chartScales?.width ?? Math.max(chartWidth || 0, 320);
  const chartSvgHeight = chartHeight;
  const hasRenderableChart = hasChartData && preparedChartSeries.length > 0 && Boolean(chartScales);

  React.useEffect(() => {
    if (!isChartOpen) {
      return;
    }
    const element = chartContainerRef.current;
    if (!element) {
      return;
    }
    const updateWidth = () => {
      const newWidth = element.clientWidth;
      if (newWidth > 0) {
        setChartWidth(newWidth);
      }
    };
    updateWidth();

    if (typeof ResizeObserver !== 'undefined') {
      const observer = new ResizeObserver(() => updateWidth());
      observer.observe(element);
      return () => observer.disconnect();
    }

    window.addEventListener('resize', updateWidth);
    return () => window.removeEventListener('resize', updateWidth);
  }, [isChartOpen]);

  if (!mapWidgetId) {
    return (
      <div className="widget-custom" style={{ padding: '20px' }}>
  <h3>KPI_Tool</h3>
        <p>prototype v1 still in development</p>
      </div>
    );
  }

  if (!kpisUrlConfigured) {
    return (
      <div className="widget-custom" style={{ padding: '20px' }}>
        <h3>Feature Services Data Reader</h3>
        <p>Please configure the KPI feature service URL in the widget settings.</p>
      </div>
    );
  }

  return (
    <div className="widget-custom" style={{ padding: '20px', height: '100%', overflowY: 'auto', boxSizing: 'border-box' }}>
      <JimuMapViewComponent useMapWidgetId={mapWidgetId} onActiveViewChange={handleActiveViewChange} />
  <h3>KPI_Tool</h3>

      {loading && <p>Loading dataâ€¦</p>}
      {error && <p style={{ color: 'red' }}>{error}</p>}

      {!loading && !error && (
        <div>
          <div style={{ marginTop: '20px', padding: '10px', border: '1px solid #ddd', borderRadius: 4 }}>
            <h4 style={{ marginTop: 0 }}>Select AOI</h4>
            <p style={{ fontSize: 12, marginBottom: 8 }}>Draw a polygon to apply KPI values to the selected cells.</p>
            <div style={{ display: 'flex', gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
              <button
                onClick={startSelection}
                disabled={selecting || applying}
                style={{ padding: '6px 14px', cursor: selecting || applying ? 'not-allowed' : 'pointer' }}
              >
                {selecting ? 'Drawingâ€¦' : 'Draw Area'}
              </button>
              <button
                onClick={clearSelection}
                disabled={selecting || selectedCells.length === 0}
                style={{ padding: '6px 14px', cursor: selecting || selectedCells.length === 0 ? 'not-allowed' : 'pointer' }}
              >
                Clear Selection
              </button>
              <span style={{ fontSize: 12, color: '#333' }}>Selected cells: {selectedCells.length}</span>
            </div>
          </div>

          <div style={{ marginTop: '20px', padding: '10px', border: '1px solid #ddd', borderRadius: 4 }}>
            <h4 style={{ marginTop: 0 }}>Choose KPIs</h4>
            {candidateKpiFields.length === 0 ? (
              <p style={{ fontSize: 12 }}>No numeric KPI fields detected in the KPI layer.</p>
            ) : (
              <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
                {candidateKpiFields.map((field: string, index: number) => {
                  const isSelectedForChart = chartKpiFields.includes(field);
                  const isMapField = mapKpiField === field;
                  return (
                    <div
                      key={field}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: 12,
                        padding: '6px 0',
                        borderBottom: index === candidateKpiFields.length - 1 ? 'none' : '1px solid #f1f1f1'
                      }}
                    >
                      <label style={{ display: 'flex', alignItems: 'center', gap: 8, fontSize: 12, cursor: applying || selecting ? 'not-allowed' : 'pointer' }}>
                        <input
                          type="checkbox"
                          checked={isSelectedForChart}
                          onChange={(event: React.ChangeEvent<HTMLInputElement>) => handleChartKpiToggle(field, event.target.checked)}
                          disabled={applying || selecting}
                        />
                        <span>{field}</span>
                      </label>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 6, fontSize: 11, cursor: applying || selecting ? 'not-allowed' : 'pointer' }}>
                        <input
                          type="radio"
                          name="map-kpi-field"
                          value={field}
                          checked={isMapField}
                          onChange={() => handleMapKpiChange(field)}
                          disabled={applying || selecting}
                        />
                        <span>Color map</span>
                      </label>
                    </div>
                  );
                })}
              </div>
            )}
            {candidateKpiFields.length > 0 && (
              <div style={{ marginTop: 12, display: 'flex', gap: 8, alignItems: 'center', flexWrap: 'wrap' }}>
                <button
                  type="button"
                  onClick={applyKpi}
                  disabled={!canApplyKpi || applying || selecting}
                  style={{ padding: '6px 14px', cursor: !canApplyKpi || applying || selecting ? 'not-allowed' : 'pointer' }}
                >
                  {applying ? 'Applyingâ€¦' : 'Apply KPI'}
                </button>
                <span style={{ fontSize: 12, color: '#555' }}>
                  {applying
                    ? 'Updating map symbologyâ€¦'
                    : canApplyKpi
                      ? `Ready to apply colors for ${mapKpiField ?? 'selected KPI'}.`
                      : 'Check KPIs to chart, choose a color KPI, and draw an area to enable Apply.'}
                </span>
              </div>
            )}
            {selectedChartKpiList && (
              <div style={{ marginTop: 8, fontSize: 11, color: '#555' }}>
                Plotting KPIs: <strong>{selectedChartKpiList}</strong>
                {mapKpiField ? ` | Map color KPI: ${mapKpiField}` : ''}
              </div>
            )}
            {hasDateRange && (
              <div style={{ marginTop: 12, display: 'flex', gap: 12, flexWrap: 'wrap', alignItems: 'flex-end', fontSize: 12 }}>
                <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                  <span style={{ fontWeight: 600 }}>Start Date</span>
                  <input
                    type="date"
                    value={dateStartValue}
                    min={dateMinValue || undefined}
                    max={dateMaxValue || undefined}
                    onChange={(event: React.ChangeEvent<HTMLInputElement>) => handleDateInputChange('start', event.target.value)}
                    disabled={applying || selecting}
                    style={{ padding: '6px 10px', fontSize: 12 }}
                  />
                </label>
                <label style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
                  <span style={{ fontWeight: 600 }}>End Date</span>
                  <input
                    type="date"
                    value={dateEndValue}
                    min={dateMinValue || undefined}
                    max={dateMaxValue || undefined}
                    onChange={(event: React.ChangeEvent<HTMLInputElement>) => handleDateInputChange('end', event.target.value)}
                    disabled={applying || selecting}
                    style={{ padding: '6px 10px', fontSize: 12 }}
                  />
                </label>
                {rangeSummaryStart && rangeSummaryEnd && (
                  <div style={{ fontSize: 11, color: '#555', lineHeight: 1.4 }}>
                    <div>Selected window</div>
                    <strong>{rangeSummaryStart}</strong>
                    <span> to </span>
                    <strong>{rangeSummaryEnd}</strong>
                  </div>
                )}
                {dateMinValue && dateMaxValue && (
                  <button
                    type="button"
                    onClick={() => {
                      handleDateInputChange('start', dateMinValue);
                      handleDateInputChange('end', dateMaxValue);
                    }}
                    disabled={applying || selecting}
                    style={{ padding: '6px 10px', cursor: applying || selecting ? 'not-allowed' : 'pointer' }}
                  >
                    Reset Range
                  </button>
                )}
              </div>
            )}
            <small style={{ display: 'block', marginTop: 6, color: '#555' }}>
              Choose one or more KPIs, select a single KPI for map coloring, adjust the optional date window, then click Apply to refresh the map.
            </small>
          </div>

          {legendBreaks.length > 0 && legendExpression && legendTitle && (
            <div style={{ marginTop: '16px', padding: '10px', border: '1px solid #ddd', borderRadius: 4 }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 12 }}>
                <h4 style={{ margin: '0' }}>Legend ({legendTitle})</h4>
                <button
                  type="button"
                  onClick={() => setLegendExpanded((value: boolean) => !value)}
                  style={{ padding: '6px 10px', cursor: 'pointer' }}
                >
                  {legendExpanded ? 'Collapse' : 'Expand'}
                </button>
              </div>
              {!legendExpanded && (
                <small style={{ fontSize: 11, color: '#555' }}>
                  Legend settings are hidden. Expand to adjust class breaks.
                </small>
              )}
              {legendExpanded && (
                <React.Fragment>
                  <div style={{ fontSize: 11, color: '#555', margin: '8px 0' }}>Adjust the color and range for each class, then update.</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 6, maxHeight: 220, overflowY: 'auto' }}>
                    {legendBreaks.map((legendBreak: LegendBreak, index: number) => (
                      <div
                        key={`legend-break-${index}`}
                        style={{
                          display: 'grid',
                          gridTemplateColumns: '36px 1fr 1fr',
                          gap: 6,
                          alignItems: 'center',
                          padding: '4px 6px',
                          border: '1px solid #eee',
                          borderRadius: 4
                        }}
                      >
                        <input
                          type="color"
                          value={legendBreak.color}
                          onChange={(e) => handleLegendBreakChange(index, 'color', e.target.value)}
                          aria-label={`Legend color ${index + 1}`}
                          style={{ width: 32, height: 32, padding: 0, border: 'none', background: 'transparent', cursor: 'pointer' }}
                        />
                        <input
                          type="number"
                          step="any"
                          value={legendBreak.minValue}
                          onChange={(e) => handleLegendBreakChange(index, 'minValue', e.target.value)}
                          aria-label={`Legend minimum ${index + 1}`}
                          style={{ width: '100%', padding: '4px 6px', fontSize: 12, boxSizing: 'border-box' }}
                        />
                        <input
                          type="number"
                          step="any"
                          value={legendBreak.maxValue}
                          onChange={(e) => handleLegendBreakChange(index, 'maxValue', e.target.value)}
                          aria-label={`Legend maximum ${index + 1}`}
                          style={{ width: '100%', padding: '4px 6px', fontSize: 12, boxSizing: 'border-box' }}
                        />
                      </div>
                    ))}
                  </div>
                  <div style={{ display: 'flex', gap: 8, marginTop: 10, alignItems: 'center', flexWrap: 'wrap' }}>
                    <button
                      onClick={applyLegendUpdates}
                      disabled={applying || selecting}
                      style={{ padding: '6px 12px', cursor: applying || selecting ? 'not-allowed' : 'pointer' }}
                    >
                      Update Legend
                    </button>
                    <small style={{ fontSize: 11, color: '#555' }}>
                      Modify and update the legend as needed.
                    </small>
                  </div>
                </React.Fragment>
              )}
            </div>
          )}

          {hasBaseKpiData && (
            <div style={{ marginTop: '16px', padding: '10px', border: '1px solid #ddd', borderRadius: 4 }}>
              <h4 style={{ margin: '0 0 8px 0' }}>Explore KPI Results</h4>
              <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                <button
                  onClick={() => setChartOpen((value: boolean) => !value)}
                  style={{ padding: '6px 14px', cursor: 'pointer' }}
                >
                  {isChartOpen ? 'Hide KPI Graph' : 'Show KPI Graph'}
                </button>
              </div>
              <small style={{ display: 'block', marginTop: 6, color: '#555' }}>
                Open the chart to explore KPI trends over time and review the latest values for each selected feature.
              </small>
            </div>
          )}

          {isChartOpen && hasBaseKpiData && (
            <div style={{ marginTop: '16px', padding: '10px', border: '1px solid #ddd', borderRadius: 4 }}>
              <h4 style={{ margin: '0 0 8px 0' }}>
                KPI Graph{mapKpiField ? ` (Map KPI: ${mapKpiField})` : ''}
              </h4>
              <div style={{ fontSize: 11, color: '#555', marginBottom: 8 }}>
                Lines show the average KPI value across the selected cells for each date.
              </div>
              {preparedChartSeries.length > 0 && (
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: 12, marginBottom: 8 }}>
                  {preparedChartSeries.map((series: PreparedChartSeries) => (
                    <div key={series.key} style={{ display: 'flex', alignItems: 'center', gap: 6, fontSize: 11, color: '#333' }}>
                      <span style={{ width: 12, height: 12, borderRadius: 2, background: series.color, display: 'inline-block' }} />
                      <span>{series.label}</span>
                    </div>
                  ))}
                </div>
              )}
              <div
                ref={chartContainerRef}
                style={{ width: '100%', overflowX: 'hidden', paddingTop: 12 }}
              >
                {hasRenderableChart ? (
                  <svg
                    width={chartSvgWidth}
                    height={chartSvgHeight}
                    role="img"
                    aria-label="KPI line chart"
                    style={{ maxWidth: '100%' }}
                  >
                    <rect
                      x={chartMargins.left}
                      y={chartMargins.top}
                      width={chartScales?.innerWidth ?? 0}
                      height={chartScales?.innerHeight ?? 0}
                      fill="#f8f9fa"
                      stroke="#dee2e6"
                      strokeWidth={1}
                    />
                    {axisTicks.yTicks.map((tick: { y: number; label: string }, index: number) => (
                      <g key={`y-tick-${index}`}>
                        <line
                          x1={chartMargins.left}
                          y1={tick.y}
                          x2={chartMargins.left + (chartScales?.innerWidth ?? 0)}
                          y2={tick.y}
                          stroke="#e5e5e5"
                          strokeWidth={1}
                        />
                        <text
                          x={chartMargins.left - 8}
                          y={tick.y + 4}
                          fontSize={10}
                          fill="#555"
                          textAnchor="end"
                        >
                          {tick.label}
                        </text>
                      </g>
                    ))}
                    {axisTicks.xTicks.map((tick: { x: number; label: string }, index: number) => (
                      <g key={`x-tick-${index}`}>
                        <line
                          x1={tick.x}
                          y1={chartMargins.top + (chartScales?.innerHeight ?? 0)}
                          x2={tick.x}
                          y2={chartMargins.top + (chartScales?.innerHeight ?? 0) + 6}
                          stroke="#adb5bd"
                          strokeWidth={1}
                        />
                        <text
                          x={tick.x}
                          y={chartHeight - 8}
                          fontSize={10}
                          fill="#555"
                          textAnchor="middle"
                        >
                          {tick.label}
                        </text>
                      </g>
                    ))}
                    <line
                      x1={chartMargins.left}
                      y1={chartMargins.top}
                      x2={chartMargins.left}
                      y2={chartMargins.top + (chartScales?.innerHeight ?? 0)}
                      stroke="#adb5bd"
                      strokeWidth={1}
                    />
                    <line
                      x1={chartMargins.left}
                      y1={chartMargins.top + (chartScales?.innerHeight ?? 0)}
                      x2={chartMargins.left + (chartScales?.innerWidth ?? 0)}
                      y2={chartMargins.top + (chartScales?.innerHeight ?? 0)}
                      stroke="#adb5bd"
                      strokeWidth={1}
                    />
                    {preparedChartSeries.map((series: PreparedChartSeries) => (
                      <g key={series.key}>
                        <path
                          d={series.path}
                          fill="none"
                          stroke={series.color}
                          strokeWidth={2}
                          strokeLinecap="round"
                        />
                        {series.coordinates.map((coord: ChartSeriesCoordinates, idx: number) => (
                          <g key={`${series.key}-${coord.point.timestamp}-${idx}`}>
                            <circle cx={coord.x} cy={coord.y} r={4} fill="#fff" stroke={series.color} strokeWidth={2} />
                            <title>{`${coord.point.tooltipLabel}: ${formatKpiValue(coord.point.value)}`}</title>
                          </g>
                        ))}
                      </g>
                    ))}
                    <text
                      x={chartMargins.left + (chartScales?.innerWidth ?? 0) / 2}
                      y={chartHeight - 2}
                      textAnchor="middle"
                      fontSize={11}
                      fill="#333"
                    >
                      Date
                    </text>
                    <text
                      x={chartMargins.left - 40}
                      y={chartMargins.top + (chartScales?.innerHeight ?? 0) / 2}
                      textAnchor="middle"
                      fontSize={11}
                      fill="#333"
                      transform={`rotate(-90 ${chartMargins.left - 40} ${chartMargins.top + (chartScales?.innerHeight ?? 0) / 2})`}
                    >
                      KPI Value
                    </text>
                  </svg>
                ) : (
                  <div style={{ padding: '12px 0', fontSize: 12, color: '#555' }}>
                    No chart records for the current filters. Adjust the date range or reapply the KPI to refresh the data.
                  </div>
                )}
              </div>
              {hasRenderableChart && (
                <div style={{ marginTop: 10, fontSize: 11, color: '#444', display: 'flex', gap: 16, flexWrap: 'wrap' }}>
                  <span>Min: {formatKpiValue(chartSummary.min)}</span>
                  <span>Max: {formatKpiValue(chartSummary.max)}</span>
                  <span>Points: {chartSummary.points}</span>
                </div>
              )}
            </div>
          )}
          
          {/* Hide the reloa button as it's not functional. */}
          {/* <button
            onClick={handleReload}
            style={{ marginTop: '20px', padding: '8px 16px', cursor: 'pointer' }}
          >
            Reload Data
          </button> */}

          {/* No map preview section. This widget only controls the renderer of the detected polygon cells layer in the main map widget. */}
        </div>
      )}
    </div>
  );
};

export default Widget;
