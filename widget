/** @jsx jsx */
import { React, AllWidgetProps, jsx, css } from 'jimu-core';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';

export default class Widget extends React.PureComponent<AllWidgetProps<any>, any> {
  mapContainer: HTMLDivElement;
  map: maplibregl.Map;
  debounceTimeout: any = null;
  currentToken: string = null;
  tokenExpiresAt: number = null;
  fetchController: AbortController = null;
  featureBuffer: any[] = [];

  FEATURE_SERVER_URL = 'https://url/arcgissecure/rest/services/On_Air_MGRS_100m_Single_Layer/FeatureServer/0';
  MAX_RECORDS = 4000;

  constructor(props) {
    super(props);
    this.state = {
      status: 'Initializing...',
      error: null,
      count: 0,
      token: null,
      dynamicLoading: false
    };
  }

  componentDidMount() {
    this.initMap();
  }

  // ─── TOKEN MANAGEMENT ───────────────────────────────────────────────

  getOauthToken = async () => {
    try {
      const response = await fetch("https://url/egis-js-app/token", {
        method: "GET",
        mode: 'cors'
      });
      if (!response.ok) throw new Error(`Response status: ${response.status}`);
      const result = await response.json();
      const rawToken = result.access_token;
      const expiresIn = result.expires_in || 7200;
      this.currentToken = rawToken;
      this.tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000);
      return rawToken;
    } catch (error) {
      console.error("Error fetching token:", error);
      return null;
    }
  }

  isTokenValid = () => {
    return this.currentToken && this.tokenExpiresAt && Date.now() < this.tokenExpiresAt;
  }

  ensureValidToken = async () => {
    if (!this.isTokenValid()) {
      const token = await this.getOauthToken();
      if (token) this.setState({ token });
      return token;
    }
    return this.currentToken;
  }

  // ─── MAP INIT ───────────────────────────────────────────────────────

  initMap = () => {
    this.setState({ status: 'Loading basemap...' });

    this.map = new maplibregl.Map({
      container: this.mapContainer,
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [-97, 38],
      zoom: 4
    });

    this.map.on('load', () => {
      this.setState({ status: 'Basemap loaded. Ready.' });
    });

    this.map.on('moveend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });

    this.map.on('zoomend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });
  }

  // ─── DYNAMIC LOADING CONTROLS ──────────────────────────────────────

  enableDynamicLoading = async () => {
    this.clearMap();
    this.setState({ status: 'Getting token...', error: null });
    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token failed', error: 'Could not get token' });
      return;
    }
    this.setState({ token, dynamicLoading: true, status: 'Dynamic loading enabled' });
    this.loadCurrentViewport();
  }

  disableDynamicLoading = () => {
    this.setState({ dynamicLoading: false, status: 'Dynamic loading disabled' });
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
  }

  debouncedLoadViewport = () => {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    this.debounceTimeout = setTimeout(() => {
      this.loadCurrentViewport();
    }, 500);
  }

  // ─── CORE LOADING LOGIC ────────────────────────────────────────────

  loadCurrentViewport = async () => {
    if (this.fetchController) this.fetchController.abort();
    this.fetchController = new AbortController();
    const signal = this.fetchController.signal;

    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token expired', error: 'Failed to refresh token' });
      return;
    }

    const zoom = this.map.getZoom();

    if (zoom < 12) {
      this.setState({ status: `Zoom in to 12+ to load features (current: ${Math.floor(zoom)})`, count: 0 });
      this.clearMap();
      return;
    }

    const bounds = this.map.getBounds();
    const bbox = {
      xmin: bounds.getWest(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      ymax: bounds.getNorth()
    };

    const grid = this.getGridSize(zoom);

    // Reset buffer, ensure source
    this.featureBuffer = [];
    this.ensureSourceExists();
    this.pushToMap(); // Clear visual immediately

    if (grid === 1) {
      this.setState({ status: 'Loading...' });
      try {
        const features = await this.fetchBbox(bbox, token, signal);
        if (signal.aborted) return;
        this.featureBuffer = features;
        this.pushToMap();
        this.setState({ status: `✓ ${features.length.toLocaleString()} features`, count: features.length, error: null });
      } catch (err) {
        if (err.name === 'AbortError') return;
        this.setState({ status: 'Failed', error: err.message });
      }
    } else {
      await this.fetchGriddedProgressive(bbox, token, signal, grid);
    }
  }

  getGridSize = (zoom: number): number => {
    // With 4000 max records per request:
    // zoom 12: ~38K features in viewport → 3x3=9 cells → 36K cap, close fit
    // zoom 13: ~9.6K features → 2x2=4 cells → 16K cap, plenty
    // zoom 14+: ~2.4K features → single request enough
    if (zoom >= 14) return 1;
    if (zoom >= 13) return 2;
    return 3; // zoom 12
  }

  // ─── FETCH HELPERS ─────────────────────────────────────────────────

  buildQueryUrl = (bbox: any, token: string): string => {
    let tokenParam = encodeURIComponent(token);
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E';
    }

    const geometryFilter = encodeURIComponent(JSON.stringify({
      ...bbox,
      spatialReference: { wkid: 4326 }
    }));

    return `${this.FEATURE_SERVER_URL}/query?where=1=1&outFields=OBJECTID,rsrp&resultRecordCount=${this.MAX_RECORDS}&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`;
  }

  fetchBbox = async (bbox: any, token: string, signal: AbortSignal): Promise<any[]> => {
    if (signal.aborted) return [];

    const url = this.buildQueryUrl(bbox, token);

    try {
      const res = await fetch(url, { signal });
      const text = await res.text();

      if (text.startsWith('<')) return [];

      const json = JSON.parse(text);
      if (json.error) {
        console.warn('ArcGIS error:', json.error.message);
        return [];
      }

      return json.features || [];
    } catch (err) {
      if (err.name === 'AbortError') return [];
      console.warn('Fetch error:', err.message);
      return [];
    }
  }

  fetchGriddedProgressive = async (bbox: any, token: string, signal: AbortSignal, gridSize: number) => {
    const cellWidth = (bbox.xmax - bbox.xmin) / gridSize;
    const cellHeight = (bbox.ymax - bbox.ymin) / gridSize;

    const cells: any[] = [];
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        cells.push({
          xmin: bbox.xmin + c * cellWidth,
          ymin: bbox.ymin + r * cellHeight,
          xmax: bbox.xmin + (c + 1) * cellWidth,
          ymax: bbox.ymin + (r + 1) * cellHeight
        });
      }
    }

    const seen = new Set<string>();
    let completed = 0;

    try {
      // Fire ALL requests at once — max cells is 9, all parallel
      const allPromises = cells.map(cell => this.fetchBbox(cell, token, signal));
      
      // Process as they resolve
      const results = await Promise.all(
        allPromises.map((p, idx) =>
          p.then(features => {
            if (signal.aborted) return;

            for (const f of features) {
              const id = f.id || f.properties?.OBJECTID || f.properties?.objectid;
              if (id != null) {
                const key = String(id);
                if (seen.has(key)) continue;
                seen.add(key);
              }
              this.featureBuffer.push(f);
            }

            completed++;
            this.pushToMap();
            this.setState({
              status: `Loading ${completed}/${cells.length}... (${this.featureBuffer.length.toLocaleString()})`,
              count: this.featureBuffer.length
            });
          })
        )
      );

      if (!signal.aborted) {
        this.setState({
          status: `✓ ${this.featureBuffer.length.toLocaleString()} features loaded`,
          count: this.featureBuffer.length,
          error: null
        });
      }
    } catch (err) {
      if (err.name === 'AbortError') return;
      console.error('Grid fetch error:', err);
      this.setState({ status: 'Failed', error: err.message });
    }
  }

  // ─── MAP SOURCE & RENDERING ────────────────────────────────────────

  ensureSourceExists = () => {
    if (this.map.getSource('data')) return;

    this.map.addSource('data', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] }
    });

    this.map.addLayer({
      id: 'layer-fill',
      type: 'fill',
      source: 'data',
      paint: {
        'fill-color': [
          'step',
          ['get', 'rsrp'],
          '#9c27b0',
          -118, '#f44336',
          -115, '#ff9800',
          -110, '#ffeb3b',
          -105, '#80deea',
          -95, '#2196f3',
          -85, '#4caf50'
        ],
        'fill-opacity': 0.7
      }
    });

    this.map.addLayer({
      id: 'layer-outline',
      type: 'line',
      source: 'data',
      paint: { 'line-color': '#ffffff', 'line-width': 0.5 }
    });
  }

  pushToMap = () => {
    const source = this.map.getSource('data') as any;
    if (source) {
      source.setData({ type: 'FeatureCollection', features: this.featureBuffer });
    }
  }

  clearMap = () => {
    this.featureBuffer = [];
    if (this.map.getLayer('layer-fill')) this.map.removeLayer('layer-fill');
    if (this.map.getLayer('layer-outline')) this.map.removeLayer('layer-outline');
    if (this.map.getSource('data')) this.map.removeSource('data');
    this.setState({ count: 0 });
  }

  componentWillUnmount() {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
    if (this.map) this.map.remove();
  }

  render() {
    return (
      <div css={css`width: 100%; height: 100%; position: relative;`}>
        <div ref={el => this.mapContainer = el} css={css`width: 100%; height: 100%;`} />

        <div css={css`
          position: absolute;
          top: 10px;
          left: 10px;
          background: white;
          padding: 12px 15px;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          font-size: 13px;
          z-index: 1;
          min-width: 280px;
        `}>
          <div css={css`margin-bottom: 10px;`}>
            {!this.state.dynamicLoading ? (
              <button onClick={this.enableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px;`}>
                Enable Dynamic Loading
              </button>
            ) : (
              <button onClick={this.disableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px; background: #d32f2f; color: white; border: none;`}>
                Disable Dynamic Loading
              </button>
            )}
          </div>
          <div><strong>Status:</strong> {this.state.status}</div>
          {this.state.token && <div><strong>Token:</strong> ✓</div>}
          {this.state.count > 0 && <div><strong>Features:</strong> {this.state.count.toLocaleString()}</div>}
          {this.state.error && (
            <div css={css`color: #d32f2f; margin-top: 8px; font-size: 12px;`}>
              <strong>Error:</strong><br/>{this.state.error}
            </div>
          )}
        </div>
      </div>
    );
  }
}
