/** @jsx jsx */
import { React, AllWidgetProps, jsx, css } from 'jimu-core';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';

export default class Widget extends React.PureComponent<AllWidgetProps<any>, any> {
  mapContainer: HTMLDivElement;
  map: maplibregl.Map;
  debounceTimeout: any = null;
  currentToken: string = null;
  tokenExpiresAt: number = null;
  fetchController: AbortController = null;

  FEATURE_SERVER_URL = 'https://url/arcgissecure/rest/services/On_Air_MGRS_100m_Single_Layer/FeatureServer/0';

  constructor(props) {
    super(props);
    this.state = {
      status: 'Initializing...',
      error: null,
      count: 0,
      token: null,
      dynamicLoading: false
    };
  }

  componentDidMount() {
    this.initMap();
  }

  // ─── TOKEN MANAGEMENT ───────────────────────────────────────────────

  getOauthToken = async () => {
    try {
      const response = await fetch("https://url/egis-js-app/token", {
        method: "GET",
        mode: 'cors'
      });
      if (!response.ok) throw new Error(`Response status: ${response.status}`);
      const result = await response.json();
      const rawToken = result.access_token;
      const expiresIn = result.expires_in || 7200;
      this.currentToken = rawToken;
      this.tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000);
      return rawToken;
    } catch (error) {
      console.error("Error fetching token:", error);
      return null;
    }
  }

  isTokenValid = () => {
    return this.currentToken && this.tokenExpiresAt && Date.now() < this.tokenExpiresAt;
  }

  ensureValidToken = async () => {
    if (!this.isTokenValid()) {
      const token = await this.getOauthToken();
      if (token) this.setState({ token });
      return token;
    }
    return this.currentToken;
  }

  // ─── MAP INIT ───────────────────────────────────────────────────────

  initMap = () => {
    this.setState({ status: 'Loading basemap...' });

    this.map = new maplibregl.Map({
      container: this.mapContainer,
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [-97, 38],
      zoom: 4
    });

    this.map.on('load', () => {
      this.setState({ status: 'Basemap loaded. Ready.' });
    });

    this.map.on('moveend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });

    this.map.on('zoomend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });
  }

  // ─── DYNAMIC LOADING CONTROLS ──────────────────────────────────────

  enableDynamicLoading = async () => {
    this.clearMap();
    this.setState({ status: 'Getting token...', error: null });
    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token failed', error: 'Could not get token' });
      return;
    }
    this.setState({ token, dynamicLoading: true, status: 'Dynamic loading enabled' });
    this.loadCurrentViewport();
  }

  disableDynamicLoading = () => {
    this.setState({ dynamicLoading: false, status: 'Dynamic loading disabled' });
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
  }

  debouncedLoadViewport = () => {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    this.debounceTimeout = setTimeout(() => {
      this.loadCurrentViewport();
    }, 500);
  }

  // ─── CORE LOADING LOGIC ────────────────────────────────────────────

  loadCurrentViewport = async () => {
    // Cancel any in-flight requests
    if (this.fetchController) this.fetchController.abort();
    this.fetchController = new AbortController();
    const signal = this.fetchController.signal;

    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token expired', error: 'Failed to refresh token' });
      return;
    }

    const zoom = this.map.getZoom();

    if (zoom < 7) {
      this.setState({ status: `Zoom in to 7+ to load features (current: ${Math.floor(zoom)})`, count: 0 });
      this.clearMap();
      return;
    }

    const bounds = this.map.getBounds();

    if (zoom >= 13) {
      // High zoom: single query, no simplification
      this.setState({ status: 'Loading viewport...' });
      await this.fetchSingleBbox(bounds, token, signal, null);
    } else {
      // Zoom 7-12: grid-based parallel fetching
      const gridConfig = this.getGridConfig(zoom);
      this.setState({ status: `Loading (${gridConfig.cols}x${gridConfig.rows} grid, zoom ${Math.floor(zoom)})...` });
      await this.fetchGridded(bounds, token, signal, gridConfig, zoom);
    }
  }

  // Determine grid size and maxAllowableOffset based on zoom
  getGridConfig = (zoom: number): { rows: number, cols: number, maxOffset: number } => {
    if (zoom >= 11) {
      return { rows: 2, cols: 2, maxOffset: 0.0005 };   // 4 cells
    } else if (zoom >= 9) {
      return { rows: 3, cols: 3, maxOffset: 0.001 };     // 9 cells
    } else {
      // zoom 7-8
      return { rows: 4, cols: 4, maxOffset: 0.005 };     // 16 cells
    }
  }

  // Build query URL for a given bbox
  buildQueryUrl = (bbox: { xmin: number, ymin: number, xmax: number, ymax: number }, token: string, maxOffset: number | null, offset: number = 0): string => {
    let tokenParam = encodeURIComponent(token);
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E';
    }

    const geometryFilter = encodeURIComponent(JSON.stringify({
      ...bbox,
      spatialReference: { wkid: 4326 }
    }));

    let url = `${this.FEATURE_SERVER_URL}/query?where=1=1&outFields=*&resultRecordCount=2000&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`;

    if (maxOffset !== null) {
      url += `&maxAllowableOffset=${maxOffset}`;
    }

    if (offset > 0) {
      url += `&resultOffset=${offset}`;
    }

    return url;
  }

  // Fetch all pages for a single bbox (handles pagination)
  fetchAllPages = async (bbox: { xmin: number, ymin: number, xmax: number, ymax: number }, token: string, signal: AbortSignal, maxOffset: number | null): Promise<any[]> => {
    let allFeatures: any[] = [];
    let offset = 0;
    const limit = 2000;

    while (true) {
      if (signal.aborted) return allFeatures;

      const url = this.buildQueryUrl(bbox, token, maxOffset, offset);
      const res = await fetch(url, { signal });
      const text = await res.text();

      if (text.startsWith('<')) {
        console.warn('Got HTML response, skipping this cell');
        break;
      }

      const json = JSON.parse(text);

      if (json.error) {
        console.warn('ArcGIS error for cell:', json.error.message);
        break;
      }

      if (!json.features || json.features.length === 0) break;

      allFeatures = allFeatures.concat(json.features);

      // If we got less than the limit, we have all data for this cell
      if (json.features.length < limit) break;

      // Otherwise paginate
      offset += limit;

      // Safety cap: max 5 pages per cell (10,000 features)
      if (offset >= limit * 5) {
        console.warn('Hit pagination cap for cell, moving on');
        break;
      }
    }

    return allFeatures;
  }

  // Single bbox fetch (zoom 13+)
  fetchSingleBbox = async (mapBounds: maplibregl.LngLatBounds, token: string, signal: AbortSignal, maxOffset: number | null) => {
    const bbox = {
      xmin: mapBounds.getWest(),
      ymin: mapBounds.getSouth(),
      xmax: mapBounds.getEast(),
      ymax: mapBounds.getNorth()
    };

    try {
      const features = await this.fetchAllPages(bbox, token, signal, maxOffset);
      if (signal.aborted) return;
      this.renderFeatures(features);
    } catch (err) {
      if (err.name === 'AbortError') return;
      console.error('Fetch error:', err);
      this.setState({ status: 'Failed', error: err.message });
    }
  }

  // Grid-based parallel fetch (zoom 7-12)
  fetchGridded = async (mapBounds: maplibregl.LngLatBounds, token: string, signal: AbortSignal, config: { rows: number, cols: number, maxOffset: number }, zoom: number) => {
    const west = mapBounds.getWest();
    const south = mapBounds.getSouth();
    const east = mapBounds.getEast();
    const north = mapBounds.getNorth();

    const cellWidth = (east - west) / config.cols;
    const cellHeight = (north - south) / config.rows;

    // Build grid cells
    const cells: { xmin: number, ymin: number, xmax: number, ymax: number }[] = [];
    for (let r = 0; r < config.rows; r++) {
      for (let c = 0; c < config.cols; c++) {
        cells.push({
          xmin: west + c * cellWidth,
          ymin: south + r * cellHeight,
          xmax: west + (c + 1) * cellWidth,
          ymax: south + (r + 1) * cellHeight
        });
      }
    }

    try {
      let completedCells = 0;
      const totalCells = cells.length;

      // Fetch all cells in parallel (with concurrency limit)
      const allFeatures: any[] = [];
      const concurrency = 6; // Max parallel requests

      for (let i = 0; i < cells.length; i += concurrency) {
        if (signal.aborted) return;

        const batch = cells.slice(i, i + concurrency);
        const batchResults = await Promise.all(
          batch.map(cell => this.fetchAllPages(cell, token, signal, config.maxOffset))
        );

        for (const features of batchResults) {
          allFeatures.push(...features);
          completedCells++;
        }

        if (!signal.aborted) {
          this.setState({ status: `Loading cells ${completedCells}/${totalCells}...` });
        }
      }

      if (signal.aborted) return;

      // Deduplicate features by ObjectID (grid cells may overlap slightly)
      const seen = new Set<string>();
      const uniqueFeatures = allFeatures.filter(f => {
        const id = f.id || f.properties?.OBJECTID || f.properties?.objectid || f.properties?.FID;
        if (id !== undefined && id !== null) {
          const key = String(id);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }
        return true; // Keep features without IDs
      });

      this.renderFeatures(uniqueFeatures);

    } catch (err) {
      if (err.name === 'AbortError') return;
      console.error('Grid fetch error:', err);
      this.setState({ status: 'Failed', error: err.message });
    }
  }

  // ─── RENDERING ─────────────────────────────────────────────────────

  renderFeatures = (features: any[]) => {
    if (features.length === 0) {
      this.setState({ status: 'No features in viewport', error: null, count: 0 });
      this.clearMap();
      return;
    }

    const geojson: any = {
      type: 'FeatureCollection',
      features: features
    };

    // Update or create source
    if (this.map.getSource('data')) {
      (this.map.getSource('data') as any).setData(geojson);
    } else {
      this.map.addSource('data', {
        type: 'geojson',
        data: geojson
      });

      const geomType = features[0].geometry.type.toLowerCase();

      if (geomType.includes('point')) {
        this.map.addLayer({
          id: 'layer',
          type: 'circle',
          source: 'data',
          paint: {
            'circle-radius': 6,
            'circle-color': '#e74c3c',
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });
      } else if (geomType.includes('line')) {
        this.map.addLayer({
          id: 'layer',
          type: 'line',
          source: 'data',
          paint: {
            'line-color': '#3498db',
            'line-width': 3
          }
        });
      } else if (geomType.includes('polygon')) {
        this.map.addLayer({
          id: 'layer',
          type: 'fill',
          source: 'data',
          paint: {
            'fill-color': [
              'step',
              ['get', 'rsrp'],
              '#9c27b0',
              -118, '#f44336',
              -115, '#ff9800',
              -110, '#ffeb3b',
              -105, '#80deea',
              -95, '#2196f3',
              -85, '#4caf50'
            ],
            'fill-opacity': 0.7
          }
        });
        this.map.addLayer({
          id: 'outline',
          type: 'line',
          source: 'data',
          paint: {
            'line-color': '#ffffff',
            'line-width': 0.5
          }
        });
      }
    }

    this.setState({
      status: `✓ ${features.length} features loaded`,
      count: features.length,
      error: null
    });
  }

  // ─── CLEANUP ───────────────────────────────────────────────────────

  clearMap = () => {
    if (this.map.getLayer('layer')) this.map.removeLayer('layer');
    if (this.map.getLayer('outline')) this.map.removeLayer('outline');
    if (this.map.getSource('data')) this.map.removeSource('data');
    this.setState({ count: 0 });
  }

  componentWillUnmount() {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
    if (this.map) this.map.remove();
  }

  // ─── RENDER ────────────────────────────────────────────────────────

  render() {
    return (
      <div css={css`width: 100%; height: 100%; position: relative;`}>
        <div ref={el => this.mapContainer = el} css={css`width: 100%; height: 100%;`} />

        <div css={css`
          position: absolute;
          top: 10px;
          left: 10px;
          background: white;
          padding: 12px 15px;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          font-size: 13px;
          z-index: 1;
          min-width: 250px;
        `}>
          <div css={css`margin-bottom: 10px; display: flex; gap: 6px; flex-wrap: wrap;`}>
            {!this.state.dynamicLoading ? (
              <button onClick={this.enableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px;`}>
                Enable Dynamic Loading
              </button>
            ) : (
              <button onClick={this.disableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px; background: #d32f2f; color: white; border: none;`}>
                Disable Dynamic Loading
              </button>
            )}
          </div>
          <div><strong>Status:</strong> {this.state.status}</div>
          {this.state.token && <div><strong>Token:</strong> ✓ Acquired</div>}
          {this.state.count > 0 && <div><strong>Features:</strong> {this.state.count.toLocaleString()}</div>}
          {this.state.error && (
            <div css={css`color: #d32f2f; margin-top: 8px; font-size: 12px;`}>
              <strong>Error:</strong><br/>{this.state.error}
            </div>
          )}
        </div>
      </div>
    );
  }
}
