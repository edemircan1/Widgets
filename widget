/** @jsx jsx */
import { React, AllWidgetProps, jsx, css } from 'jimu-core';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';

export default class Widget extends React.PureComponent<AllWidgetProps<any>, any> {
  mapContainer: HTMLDivElement;
  map: maplibregl.Map;
  debounceTimeout: any = null;
  currentToken: string = null;
  tokenExpiresAt: number = null;
  fetchController: AbortController = null;

  FEATURE_SERVER_URL = 'https://url/arcgissecure/rest/services/On_Air_MGRS_100m_Single_Layer/FeatureServer/0';
  MAX_RECORD_COUNT = 2000;
  MAX_DEPTH = 5; // Max quadtree subdivision depth

  constructor(props) {
    super(props);
    this.state = {
      status: 'Initializing...',
      error: null,
      count: 0,
      token: null,
      dynamicLoading: false,
      cellsProcessed: 0,
      cellsTotal: 0
    };
  }

  componentDidMount() {
    this.initMap();
  }

  // ─── TOKEN MANAGEMENT ───────────────────────────────────────────────

  getOauthToken = async () => {
    try {
      const response = await fetch("https://url/egis-js-app/token", {
        method: "GET",
        mode: 'cors'
      });
      if (!response.ok) throw new Error(`Response status: ${response.status}`);
      const result = await response.json();
      const rawToken = result.access_token;
      const expiresIn = result.expires_in || 7200;
      this.currentToken = rawToken;
      this.tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000);
      return rawToken;
    } catch (error) {
      console.error("Error fetching token:", error);
      return null;
    }
  }

  isTokenValid = () => {
    return this.currentToken && this.tokenExpiresAt && Date.now() < this.tokenExpiresAt;
  }

  ensureValidToken = async () => {
    if (!this.isTokenValid()) {
      const token = await this.getOauthToken();
      if (token) this.setState({ token });
      return token;
    }
    return this.currentToken;
  }

  // ─── MAP INIT ───────────────────────────────────────────────────────

  initMap = () => {
    this.setState({ status: 'Loading basemap...' });

    this.map = new maplibregl.Map({
      container: this.mapContainer,
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [-97, 38],
      zoom: 4
    });

    this.map.on('load', () => {
      this.setState({ status: 'Basemap loaded. Ready.' });
    });

    this.map.on('moveend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });

    this.map.on('zoomend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });
  }

  // ─── DYNAMIC LOADING CONTROLS ──────────────────────────────────────

  enableDynamicLoading = async () => {
    this.clearMap();
    this.setState({ status: 'Getting token...', error: null });
    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token failed', error: 'Could not get token' });
      return;
    }
    this.setState({ token, dynamicLoading: true, status: 'Dynamic loading enabled' });
    this.loadCurrentViewport();
  }

  disableDynamicLoading = () => {
    this.setState({ dynamicLoading: false, status: 'Dynamic loading disabled' });
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
  }

  debouncedLoadViewport = () => {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    this.debounceTimeout = setTimeout(() => {
      this.loadCurrentViewport();
    }, 500);
  }

  // ─── CORE LOADING LOGIC ────────────────────────────────────────────

  loadCurrentViewport = async () => {
    if (this.fetchController) this.fetchController.abort();
    this.fetchController = new AbortController();
    const signal = this.fetchController.signal;

    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token expired', error: 'Failed to refresh token' });
      return;
    }

    const zoom = this.map.getZoom();

    if (zoom < 7) {
      this.setState({ status: `Zoom in to 7+ to load features (current: ${Math.floor(zoom)})`, count: 0 });
      this.clearMap();
      return;
    }

    const bounds = this.map.getBounds();
    const bbox = {
      xmin: bounds.getWest(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      ymax: bounds.getNorth()
    };

    const initialGrid = this.getInitialGrid(zoom);
    const maxOffset = this.getMaxOffset(zoom);

    // Split viewport into initial grid cells
    const initialCells = this.splitBbox(bbox, initialGrid.cols, initialGrid.rows);

    this.setState({
      status: `Loading (zoom ${Math.floor(zoom)}, ${initialCells.length} cells)...`,
      cellsProcessed: 0,
      cellsTotal: initialCells.length
    });

    try {
      const allFeatures = await this.processAllCells(initialCells, token, signal, maxOffset, 0);

      if (signal.aborted) return;

      const uniqueFeatures = this.deduplicateFeatures(allFeatures);
      this.renderFeatures(uniqueFeatures);

    } catch (err) {
      if (err.name === 'AbortError') return;
      console.error('Load error:', err);
      this.setState({ status: 'Failed', error: err.message });
    }
  }

  getInitialGrid = (zoom: number): { rows: number, cols: number } => {
    if (zoom >= 13) return { rows: 1, cols: 1 };
    if (zoom >= 11) return { rows: 2, cols: 2 };
    if (zoom >= 9)  return { rows: 3, cols: 3 };
    return { rows: 4, cols: 4 }; // zoom 7-8
  }

  getMaxOffset = (zoom: number): number | null => {
    if (zoom >= 13) return null;
    if (zoom >= 11) return 0.0005;
    if (zoom >= 9)  return 0.001;
    return 0.005;
  }

  // Split a bbox into cols x rows smaller bboxes
  splitBbox = (bbox: any, cols: number, rows: number): any[] => {
    const cellWidth = (bbox.xmax - bbox.xmin) / cols;
    const cellHeight = (bbox.ymax - bbox.ymin) / rows;
    const cells = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        cells.push({
          xmin: bbox.xmin + c * cellWidth,
          ymin: bbox.ymin + r * cellHeight,
          xmax: bbox.xmin + (c + 1) * cellWidth,
          ymax: bbox.ymin + (r + 1) * cellHeight
        });
      }
    }
    return cells;
  }

  // Process a batch of cells with concurrency control
  processAllCells = async (cells: any[], token: string, signal: AbortSignal, maxOffset: number | null, depth: number): Promise<any[]> => {
    const allFeatures: any[] = [];
    const concurrency = 6;

    for (let i = 0; i < cells.length; i += concurrency) {
      if (signal.aborted) return allFeatures;

      const batch = cells.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(cell => this.fetchCell(cell, token, signal, maxOffset, depth))
      );

      for (const features of batchResults) {
        allFeatures.push(...features);
      }
    }

    return allFeatures;
  }

  // Fetch a single cell. If it returns exactly MAX_RECORD_COUNT, subdivide into 4 and recurse.
  fetchCell = async (bbox: any, token: string, signal: AbortSignal, maxOffset: number | null, depth: number): Promise<any[]> => {
    if (signal.aborted) return [];

    const url = this.buildQueryUrl(bbox, token, maxOffset);

    try {
      const res = await fetch(url, { signal });
      const text = await res.text();

      if (text.startsWith('<')) {
        console.warn('HTML response, skipping cell');
        this.incrementProcessed();
        return [];
      }

      const json = JSON.parse(text);

      if (json.error) {
        console.warn('ArcGIS error:', json.error.message);
        this.incrementProcessed();
        return [];
      }

      if (!json.features || json.features.length === 0) {
        this.incrementProcessed();
        return [];
      }

      const count = json.features.length;

      // If we got exactly the limit, this cell is incomplete — subdivide
      if (count >= this.MAX_RECORD_COUNT && depth < this.MAX_DEPTH) {
        console.log(`Cell hit limit (${count}) at depth ${depth}, subdividing into 4...`);

        // Update cell count: this cell becomes 4 sub-cells
        this.setState(prev => ({ cellsTotal: prev.cellsTotal + 3 }));

        const subCells = this.splitBbox(bbox, 2, 2);
        return await this.processAllCells(subCells, token, signal, maxOffset, depth + 1);
      }

      // Cell is fully loaded
      this.incrementProcessed();
      console.log(`Cell done: ${count} features (depth ${depth})`);
      return json.features;

    } catch (err) {
      if (err.name === 'AbortError') return [];
      console.warn('Fetch error for cell:', err.message);
      this.incrementProcessed();
      return [];
    }
  }

  incrementProcessed = () => {
    this.setState(prev => {
      const newProcessed = prev.cellsProcessed + 1;
      return {
        cellsProcessed: newProcessed,
        status: `Loading cells ${newProcessed}/${prev.cellsTotal}...`
      };
    });
  }

  buildQueryUrl = (bbox: any, token: string, maxOffset: number | null): string => {
    let tokenParam = encodeURIComponent(token);
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E';
    }

    const geometryFilter = encodeURIComponent(JSON.stringify({
      ...bbox,
      spatialReference: { wkid: 4326 }
    }));

    let url = `${this.FEATURE_SERVER_URL}/query?where=1=1&outFields=*&resultRecordCount=${this.MAX_RECORD_COUNT}&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`;

    if (maxOffset !== null) {
      url += `&maxAllowableOffset=${maxOffset}`;
    }

    return url;
  }

  deduplicateFeatures = (features: any[]): any[] => {
    const seen = new Set<string>();
    return features.filter(f => {
      const id = f.id || f.properties?.OBJECTID || f.properties?.objectid || f.properties?.FID;
      if (id !== undefined && id !== null) {
        const key = String(id);
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      }
      return true;
    });
  }

  // ─── RENDERING ─────────────────────────────────────────────────────

  renderFeatures = (features: any[]) => {
    if (features.length === 0) {
      this.setState({ status: 'No features in viewport', error: null, count: 0 });
      this.clearMap();
      return;
    }

    const geojson: any = {
      type: 'FeatureCollection',
      features: features
    };

    if (this.map.getSource('data')) {
      (this.map.getSource('data') as any).setData(geojson);
    } else {
      this.map.addSource('data', { type: 'geojson', data: geojson });

      const geomType = features[0].geometry.type.toLowerCase();

      if (geomType.includes('point')) {
        this.map.addLayer({
          id: 'layer',
          type: 'circle',
          source: 'data',
          paint: {
            'circle-radius': 6,
            'circle-color': '#e74c3c',
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });
      } else if (geomType.includes('line')) {
        this.map.addLayer({
          id: 'layer',
          type: 'line',
          source: 'data',
          paint: { 'line-color': '#3498db', 'line-width': 3 }
        });
      } else if (geomType.includes('polygon')) {
        this.map.addLayer({
          id: 'layer',
          type: 'fill',
          source: 'data',
          paint: {
            'fill-color': [
              'step',
              ['get', 'rsrp'],
              '#9c27b0',
              -118, '#f44336',
              -115, '#ff9800',
              -110, '#ffeb3b',
              -105, '#80deea',
              -95, '#2196f3',
              -85, '#4caf50'
            ],
            'fill-opacity': 0.7
          }
        });
        this.map.addLayer({
          id: 'outline',
          type: 'line',
          source: 'data',
          paint: { 'line-color': '#ffffff', 'line-width': 0.5 }
        });
      }
    }

    this.setState({
      status: `✓ ${features.length.toLocaleString()} features loaded`,
      count: features.length,
      error: null
    });
  }

  // ─── CLEANUP ───────────────────────────────────────────────────────

  clearMap = () => {
    if (this.map.getLayer('layer')) this.map.removeLayer('layer');
    if (this.map.getLayer('outline')) this.map.removeLayer('outline');
    if (this.map.getSource('data')) this.map.removeSource('data');
    this.setState({ count: 0 });
  }

  componentWillUnmount() {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
    if (this.map) this.map.remove();
  }

  // ─── RENDER ────────────────────────────────────────────────────────

  render() {
    return (
      <div css={css`width: 100%; height: 100%; position: relative;`}>
        <div ref={el => this.mapContainer = el} css={css`width: 100%; height: 100%;`} />

        <div css={css`
          position: absolute;
          top: 10px;
          left: 10px;
          background: white;
          padding: 12px 15px;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          font-size: 13px;
          z-index: 1;
          min-width: 250px;
        `}>
          <div css={css`margin-bottom: 10px; display: flex; gap: 6px; flex-wrap: wrap;`}>
            {!this.state.dynamicLoading ? (
              <button onClick={this.enableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px;`}>
                Enable Dynamic Loading
              </button>
            ) : (
              <button onClick={this.disableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px; background: #d32f2f; color: white; border: none;`}>
                Disable Dynamic Loading
              </button>
            )}
          </div>
          <div><strong>Status:</strong> {this.state.status}</div>
          {this.state.token && <div><strong>Token:</strong> ✓ Acquired</div>}
          {this.state.count > 0 && <div><strong>Features:</strong> {this.state.count.toLocaleString()}</div>}
          {this.state.error && (
            <div css={css`color: #d32f2f; margin-top: 8px; font-size: 12px;`}>
              <strong>Error:</strong><br/>{this.state.error}
            </div>
          )}
        </div>
      </div>
    );
  }
}
