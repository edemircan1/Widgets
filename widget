/** @jsx jsx */
import { React, AllWidgetProps, jsx, css } from 'jimu-core';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';

export default class Widget extends React.PureComponent<AllWidgetProps<any>, any> {
  mapContainer: HTMLDivElement;
  map: maplibregl.Map;
  debounceTimeout: any = null;
  currentToken: string = null;
  tokenExpiresAt: number = null;

  FEATURE_SERVER_URL = 'https://url/arcgissecure/rest/services/On_Air_MGRS_100m_Single_Layer/FeatureServer/0';

  constructor(props) {
    super(props);
    this.state = {
      status: 'Initializing...',
      error: null,
      count: 0,
      token: null,
      method: null,
      dynamicLoading: false
    };
  }

  componentDidMount() {
    this.initMap();
  }
  

  getOauthToken = async () => {
    try {
      const response = await fetch("https://url/egis-js-app/token", {
        method: "GET",
        mode: 'cors'
      });

      if (!response.ok) {
        throw new Error(`Response status: ${response.status}`);
      }
      const result = await response.json();
      const rawToken = result.access_token;
      const expiresIn = result.expires_in || 7200; // Default to 7200 seconds (2 hours)
      
      // Store token and calculate expiration time (with 60 second buffer)
      this.currentToken = rawToken;
      this.tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000);
      
      console.log('Raw token from API:', rawToken);
      console.log('Token expires in:', expiresIn, 'seconds');
      console.log('Token ends with period:', rawToken.endsWith('.'));
      return rawToken;

    } catch (error) {
      console.error("Error fetching token:", error);
      return null;
    }
  }

  isTokenValid = () => {
    if (!this.currentToken || !this.tokenExpiresAt) {
      return false;
    }
    return Date.now() < this.tokenExpiresAt;
  }

  ensureValidToken = async () => {
    if (!this.isTokenValid()) {
      console.log('Token expired or missing, fetching new token...');
      const token = await this.getOauthToken();
      if (token) {
        this.setState({ token: token });
      }
      return token;
    }
    return this.currentToken;
  }

  initMap = () => {
    this.setState({ status: 'Loading basemap...' });

    this.map = new maplibregl.Map({
      container: this.mapContainer,
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [-97, 38],
      zoom: 4
    });

    this.map.on('load', () => {
      this.setState({ status: 'Basemap loaded. Ready.' });
    });

    // Add listeners for dynamic loading
    this.map.on('moveend', () => {
      if (this.state.dynamicLoading) {
        this.debouncedLoadViewport();
      }
    });

    this.map.on('zoomend', () => {
      if (this.state.dynamicLoading) {
        this.debouncedLoadViewport();
      }
    });
  }

  // Enable dynamic loading
  enableDynamicLoading = async () => {
    this.clearMap();
    this.setState({ status: 'Getting token...', method: 'dynamic', error: null });
    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token failed', error: 'Could not get token' });
      return;
    }
    this.setState({ token: token, dynamicLoading: true, status: 'Dynamic loading enabled' });
    // Load initial viewport
    this.loadCurrentViewport();
  }

  disableDynamicLoading = () => {
    this.setState({ dynamicLoading: false, status: 'Dynamic loading disabled' });
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }
  }

  debouncedLoadViewport = () => {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }
    this.debounceTimeout = setTimeout(() => {
      this.loadCurrentViewport();
    }, 500); // Wait 500ms after user stops moving
  }

  loadCurrentViewport = async () => {
    // Ensure we have a valid token before loading
    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token expired', error: 'Failed to refresh token' });
      return;
    }

    const zoom = this.map.getZoom();
    console.log('Current zoom level:', zoom);

    // Only fetch data at zoom level 15 or higher
    if (zoom < 13) {
      this.setState({ 
        status: `Zoom in to level 15+ to load features (current: ${Math.floor(zoom)})`,
        count: 0 
      });
      this.clearMap();
      return;
    }

    const bounds = this.map.getBounds();
    const bbox = {
      xmin: bounds.getWest(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      ymax: bounds.getNorth(),
      spatialReference: { wkid: 4326 }
    };

    // Encode the token, then replace any trailing period with %2E
    let tokenParam = encodeURIComponent(token);
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E';
    }

    const geometryFilter = encodeURIComponent(JSON.stringify(bbox));
    const url = `${this.FEATURE_SERVER_URL}/query?where=1=1&outFields=*&resultRecordCount=2000&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`;
    
    console.log('Loading viewport at zoom', zoom, ':', bbox);
    this.fetchAndRender(url, {});
  }

  fetchAndRender = async (url: string, fetchOptions: any) => {
    try {
      const statusPrefix = this.state.dynamicLoading ? 'Loading viewport...' : `${this.state.status} → Fetching features...`;
      this.setState({ status: statusPrefix });

      const res = await fetch(url, fetchOptions);

      const contentType = res.headers.get('content-type');
      console.log('Response content-type:', contentType);

      const text = await res.text();
      console.log('Raw response (first 500 chars):', text.substring(0, 500));

      if (text.startsWith('<')) {
        this.setState({
          status: `Got HTML, not JSON`,
          error: `Server returned HTML instead of JSON. Likely a redirect or auth page.`
        });
        return;
      }

      const json = JSON.parse(text);
      console.log('Response:', json);

      if (json.error) {
        this.setState({
          status: `ArcGIS Error`,
          error: `${json.error.message || JSON.stringify(json.error)}`
        });
        return;
      }

      if (!json.features || json.features.length === 0) {
        this.setState({
          status: this.state.dynamicLoading ? 'No features in viewport' : 'No features',
          error: null,
          count: 0
        });
        this.clearMap();
        return;
      }

      this.setState({
        status: `Loading ${json.features.length} features...`,
        count: json.features.length
      });

      // Debug: Check RSRP values
      const rsrpValues = json.features.slice(0, 10).map(f => f.properties?.rsrp);
      console.log('Sample RSRP values:', rsrpValues);
      console.log('Sample feature properties:', json.features[0]?.properties);

      // Clear existing data if present
      if (this.map.getSource('data')) {
        // Update existing source
        const source: any = this.map.getSource('data');
        source.setData(json);
      } else {
        // Add new source and layers
        this.map.addSource('data', {
          type: 'geojson',
          data: json
        });

        const geomType = json.features[0].geometry.type.toLowerCase();

        if (geomType.includes('point')) {
          this.map.addLayer({
            id: 'layer',
            type: 'circle',
            source: 'data',
            paint: {
              'circle-radius': 6,
              'circle-color': '#e74c3c',
              'circle-stroke-width': 2,
              'circle-stroke-color': '#fff'
            }
          });
        } else if (geomType.includes('line')) {
          this.map.addLayer({
            id: 'layer',
            type: 'line',
            source: 'data',
            paint: {
              'line-color': '#3498db',
              'line-width': 3
            }
          });
        } else if (geomType.includes('polygon')) {
          this.map.addLayer({
            id: 'layer',
            type: 'fill',
            source: 'data',
            paint: {
              'fill-color': [
                'step',
                ['get', 'rsrp'],
                '#9c27b0',      // < -118: purple (worst signal)
                -118, '#f44336',  // -118 to -115: red
                -115, '#ff9800',  // -115 to -110: orange
                -110, '#ffeb3b',  // -110 to -105: yellow
                -105, '#80deea',  // -105 to -95: turquoise/cyan
                -95, '#2196f3',   // -95 to -85: blue
                -85, '#4caf50'    // > -85: green (best signal)
              ],
              'fill-opacity': 0.7
            }
          });
          this.map.addLayer({
            id: 'outline',
            type: 'line',
            source: 'data',
            paint: {
              'line-color': '#ffffff',
              'line-width': 1
            }
          });
        }
      }

      // Only fit bounds if not in dynamic loading mode
      if (!this.state.dynamicLoading) {
        const bounds = new maplibregl.LngLatBounds();

        json.features.forEach(feature => {
          const geom = feature.geometry;
          if (geom.type === 'Point') {
            bounds.extend(geom.coordinates);
          } else if (geom.type === 'LineString') {
            geom.coordinates.forEach(coord => bounds.extend(coord));
          } else if (geom.type === 'Polygon') {
            geom.coordinates[0].forEach(coord => bounds.extend(coord));
          } else if (geom.type === 'MultiPolygon') {
            geom.coordinates.forEach(polygon => {
              polygon[0].forEach(coord => bounds.extend(coord));
            });
          }
        });

        if (!bounds.isEmpty()) {
          this.map.fitBounds(bounds, { padding: 50, maxZoom: 15 });
        }
      }

      this.setState({
        status: this.state.dynamicLoading ? `Viewport: ${json.features.length} features` : `✓ Loaded ${json.features.length} features`,
        count: json.features.length,
        error: null
      });

    } catch (err) {
      console.error('Error:', err);
      this.setState({
        status: `Failed`,
        error: err.message
      });
    }
  }

  clearMap = () => {
    if (this.map.getLayer('layer')) this.map.removeLayer('layer');
    if (this.map.getLayer('outline')) this.map.removeLayer('outline');
    if (this.map.getSource('data')) this.map.removeSource('data');
    this.setState({ count: 0 });
  }

  componentWillUnmount() {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }
    if (this.map) this.map.remove();
  }

  render() {
    return (
      <div css={css`width: 100%; height: 100%; position: relative;`}>
        <div ref={el => this.mapContainer = el} css={css`width: 100%; height: 100%;`} />

        <div css={css`
          position: absolute;
          top: 10px;
          left: 10px;
          background: white;
          padding: 12px 15px;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          font-size: 13px;
          z-index: 1;
          min-width: 250px;
        `}>
          <div css={css`margin-bottom: 10px; display: flex; gap: 6px; flex-wrap: wrap;`}>
            {!this.state.dynamicLoading ? (
              <button onClick={this.enableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px;`}>
                Enable Dynamic Loading
              </button>
            ) : (
              <button onClick={this.disableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px; background: #d32f2f; color: white; border: none;`}>
                Disable Dynamic Loading
              </button>
            )}
          </div>
          <div><strong>Status:</strong> {this.state.status}</div>
          {this.state.token && (
            <div><strong>Token:</strong> ✓ Acquired</div>
          )}
          {this.state.count > 0 && (
            <div><strong>Features:</strong> {this.state.count}</div>
          )}
          {this.state.error && (
            <div css={css`color: #d32f2f; margin-top: 8px; font-size: 12px;`}>
              <strong>Error:</strong><br/>{this.state.error}
            </div>
          )}
        </div>
      </div>
    );
  }
}
