/** @jsx jsx */
import { React, AllWidgetProps, jsx, css } from 'jimu-core';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';

export default class Widget extends React.PureComponent<AllWidgetProps<any>, any> {
  mapContainer: HTMLDivElement;
  map: maplibregl.Map;
  debounceTimeout: any = null;
  currentToken: string = null;
  tokenExpiresAt: number = null;
  fetchController: AbortController = null;

  FEATURE_SERVER_URL = 'https://url/arcgissecure/rest/services/On_Air_MGRS_100m_Single_Layer/FeatureServer/0';
  MAX_RECORDS = 2000;

  constructor(props) {
    super(props);
    this.state = {
      status: 'Initializing...',
      error: null,
      count: 0,
      token: null,
      dynamicLoading: false
    };
  }

  componentDidMount() {
    this.initMap();
  }

  // ─── TOKEN MANAGEMENT ───────────────────────────────────────────────

  getOauthToken = async () => {
    try {
      const response = await fetch("https://url/egis-js-app/token", {
        method: "GET",
        mode: 'cors'
      });
      if (!response.ok) throw new Error(`Response status: ${response.status}`);
      const result = await response.json();
      const rawToken = result.access_token;
      const expiresIn = result.expires_in || 7200;
      this.currentToken = rawToken;
      this.tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000);
      return rawToken;
    } catch (error) {
      console.error("Error fetching token:", error);
      return null;
    }
  }

  isTokenValid = () => {
    return this.currentToken && this.tokenExpiresAt && Date.now() < this.tokenExpiresAt;
  }

  ensureValidToken = async () => {
    if (!this.isTokenValid()) {
      const token = await this.getOauthToken();
      if (token) this.setState({ token });
      return token;
    }
    return this.currentToken;
  }

  // ─── MAP INIT ───────────────────────────────────────────────────────

  initMap = () => {
    this.setState({ status: 'Loading basemap...' });

    this.map = new maplibregl.Map({
      container: this.mapContainer,
      style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
      center: [-97, 38],
      zoom: 4
    });

    this.map.on('load', () => {
      this.setState({ status: 'Basemap loaded. Ready.' });
    });

    this.map.on('moveend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });

    this.map.on('zoomend', () => {
      if (this.state.dynamicLoading) this.debouncedLoadViewport();
    });
  }

  // ─── DYNAMIC LOADING CONTROLS ──────────────────────────────────────

  enableDynamicLoading = async () => {
    this.clearMap();
    this.setState({ status: 'Getting token...', error: null });
    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token failed', error: 'Could not get token' });
      return;
    }
    this.setState({ token, dynamicLoading: true, status: 'Dynamic loading enabled' });
    this.loadCurrentViewport();
  }

  disableDynamicLoading = () => {
    this.setState({ dynamicLoading: false, status: 'Dynamic loading disabled' });
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
  }

  debouncedLoadViewport = () => {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    this.debounceTimeout = setTimeout(() => {
      this.loadCurrentViewport();
    }, 500);
  }

  // ─── CORE LOADING LOGIC ────────────────────────────────────────────

  loadCurrentViewport = async () => {
    if (this.fetchController) this.fetchController.abort();
    this.fetchController = new AbortController();
    const signal = this.fetchController.signal;

    const token = await this.ensureValidToken();
    if (!token) {
      this.setState({ status: 'Token expired', error: 'Failed to refresh token' });
      return;
    }

    const zoom = this.map.getZoom();

    if (zoom < 12) {
      this.setState({ status: `Zoom in to 12+ to load features (current: ${Math.floor(zoom)})`, count: 0 });
      this.clearMap();
      return;
    }

    const bounds = this.map.getBounds();
    const west = bounds.getWest();
    const south = bounds.getSouth();
    const east = bounds.getEast();
    const north = bounds.getNorth();

    // Get strategy based on zoom
    const strategy = this.getStrategy(zoom);

    // Calculate the fetch area (center-cropped for lower zooms, full for high zooms)
    const fetchBbox = this.getFetchBbox(west, south, east, north, strategy.viewportRatio);

    this.setState({ status: `Loading (zoom ${Math.floor(zoom)}, ${strategy.grid}x${strategy.grid} grid)...` });

    try {
      if (strategy.grid === 1) {
        // Single query
        const features = await this.fetchBbox(fetchBbox, token, signal);
        if (signal.aborted) return;
        this.renderFeatures(this.dedup(features));
      } else {
        // Grid-based parallel fetch
        const features = await this.fetchGridded(fetchBbox, token, signal, strategy.grid);
        if (signal.aborted) return;
        this.renderFeatures(this.dedup(features));
      }
    } catch (err) {
      if (err.name === 'AbortError') return;
      console.error('Load error:', err);
      this.setState({ status: 'Failed', error: err.message });
    }
  }

  // Strategy per zoom level
  getStrategy = (zoom: number): { grid: number, viewportRatio: number } => {
    // viewportRatio: 1.0 = full viewport, 0.5 = center 50% of viewport
    if (zoom >= 14) return { grid: 1, viewportRatio: 1.0 };
    if (zoom >= 13) return { grid: 3, viewportRatio: 1.0 };
    // zoom 12
    return { grid: 4, viewportRatio: 0.6 };
  }

  // Crop viewport to center portion based on ratio
  getFetchBbox = (west: number, south: number, east: number, north: number, ratio: number) => {
    if (ratio >= 1.0) {
      return { xmin: west, ymin: south, xmax: east, ymax: north };
    }

    const cx = (west + east) / 2;
    const cy = (south + north) / 2;
    const halfW = ((east - west) / 2) * ratio;
    const halfH = ((north - south) / 2) * ratio;

    return {
      xmin: cx - halfW,
      ymin: cy - halfH,
      xmax: cx + halfW,
      ymax: cy + halfH
    };
  }

  // ─── FETCH HELPERS ─────────────────────────────────────────────────

  buildQueryUrl = (bbox: any, token: string): string => {
    let tokenParam = encodeURIComponent(token);
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E';
    }

    const geometryFilter = encodeURIComponent(JSON.stringify({
      ...bbox,
      spatialReference: { wkid: 4326 }
    }));

    return `${this.FEATURE_SERVER_URL}/query?where=1=1&outFields=*&resultRecordCount=${this.MAX_RECORDS}&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`;
  }

  // Fetch a single bbox, returns features array
  fetchBbox = async (bbox: any, token: string, signal: AbortSignal): Promise<any[]> => {
    if (signal.aborted) return [];

    const url = this.buildQueryUrl(bbox, token);

    try {
      const res = await fetch(url, { signal });
      const text = await res.text();

      if (text.startsWith('<')) {
        console.warn('HTML response, skipping');
        return [];
      }

      const json = JSON.parse(text);

      if (json.error) {
        console.warn('ArcGIS error:', json.error.message);
        return [];
      }

      return json.features || [];
    } catch (err) {
      if (err.name === 'AbortError') return [];
      console.warn('Fetch error:', err.message);
      return [];
    }
  }

  // Grid-based parallel fetch
  fetchGridded = async (bbox: any, token: string, signal: AbortSignal, gridSize: number): Promise<any[]> => {
    const cellWidth = (bbox.xmax - bbox.xmin) / gridSize;
    const cellHeight = (bbox.ymax - bbox.ymin) / gridSize;

    const cells: any[] = [];
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        cells.push({
          xmin: bbox.xmin + c * cellWidth,
          ymin: bbox.ymin + r * cellHeight,
          xmax: bbox.xmin + (c + 1) * cellWidth,
          ymax: bbox.ymin + (r + 1) * cellHeight
        });
      }
    }

    const allFeatures: any[] = [];
    const concurrency = 6;
    let completed = 0;

    for (let i = 0; i < cells.length; i += concurrency) {
      if (signal.aborted) return allFeatures;

      const batch = cells.slice(i, i + concurrency);
      const results = await Promise.all(
        batch.map(cell => this.fetchBbox(cell, token, signal))
      );

      for (const features of results) {
        allFeatures.push(...features);
        completed++;
      }

      if (!signal.aborted) {
        this.setState({ status: `Loading cells ${completed}/${cells.length}...` });
      }
    }

    return allFeatures;
  }

  // Deduplicate by feature ID
  dedup = (features: any[]): any[] => {
    const seen = new Set<string>();
    return features.filter(f => {
      const id = f.id || f.properties?.OBJECTID || f.properties?.objectid || f.properties?.FID;
      if (id != null) {
        const key = String(id);
        if (seen.has(key)) return false;
        seen.add(key);
      }
      return true;
    });
  }

  // ─── RENDERING ─────────────────────────────────────────────────────

  renderFeatures = (features: any[]) => {
    if (features.length === 0) {
      this.setState({ status: 'No features in viewport', error: null, count: 0 });
      this.clearMap();
      return;
    }

    const geojson: any = { type: 'FeatureCollection', features };

    if (this.map.getSource('data')) {
      (this.map.getSource('data') as any).setData(geojson);
    } else {
      this.map.addSource('data', { type: 'geojson', data: geojson });

      const geomType = features[0].geometry.type.toLowerCase();

      if (geomType.includes('point')) {
        this.map.addLayer({
          id: 'layer',
          type: 'circle',
          source: 'data',
          paint: {
            'circle-radius': 6,
            'circle-color': '#e74c3c',
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });
      } else if (geomType.includes('line')) {
        this.map.addLayer({
          id: 'layer',
          type: 'line',
          source: 'data',
          paint: { 'line-color': '#3498db', 'line-width': 3 }
        });
      } else if (geomType.includes('polygon')) {
        this.map.addLayer({
          id: 'layer',
          type: 'fill',
          source: 'data',
          paint: {
            'fill-color': [
              'step',
              ['get', 'rsrp'],
              '#9c27b0',
              -118, '#f44336',
              -115, '#ff9800',
              -110, '#ffeb3b',
              -105, '#80deea',
              -95, '#2196f3',
              -85, '#4caf50'
            ],
            'fill-opacity': 0.7
          }
        });
        this.map.addLayer({
          id: 'outline',
          type: 'line',
          source: 'data',
          paint: { 'line-color': '#ffffff', 'line-width': 0.5 }
        });
      }
    }

    this.setState({
      status: `✓ ${features.length.toLocaleString()} features loaded`,
      count: features.length,
      error: null
    });
  }

  // ─── CLEANUP ───────────────────────────────────────────────────────

  clearMap = () => {
    if (this.map.getLayer('layer')) this.map.removeLayer('layer');
    if (this.map.getLayer('outline')) this.map.removeLayer('outline');
    if (this.map.getSource('data')) this.map.removeSource('data');
    this.setState({ count: 0 });
  }

  componentWillUnmount() {
    if (this.debounceTimeout) clearTimeout(this.debounceTimeout);
    if (this.fetchController) this.fetchController.abort();
    if (this.map) this.map.remove();
  }

  // ─── RENDER ────────────────────────────────────────────────────────

  render() {
    return (
      <div css={css`width: 100%; height: 100%; position: relative;`}>
        <div ref={el => this.mapContainer = el} css={css`width: 100%; height: 100%;`} />

        <div css={css`
          position: absolute;
          top: 10px;
          left: 10px;
          background: white;
          padding: 12px 15px;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          font-size: 13px;
          z-index: 1;
          min-width: 250px;
        `}>
          <div css={css`margin-bottom: 10px; display: flex; gap: 6px; flex-wrap: wrap;`}>
            {!this.state.dynamicLoading ? (
              <button onClick={this.enableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px;`}>
                Enable Dynamic Loading
              </button>
            ) : (
              <button onClick={this.disableDynamicLoading} css={css`padding: 5px 10px; cursor: pointer; font-size: 12px; background: #d32f2f; color: white; border: none;`}>
                Disable Dynamic Loading
              </button>
            )}
          </div>
          <div><strong>Status:</strong> {this.state.status}</div>
          {this.state.token && <div><strong>Token:</strong> ✓ Acquired</div>}
          {this.state.count > 0 && <div><strong>Features:</strong> {this.state.count.toLocaleString()}</div>}
          {this.state.error && (
            <div css={css`color: #d32f2f; margin-top: 8px; font-size: 12px;`}>
              <strong>Error:</strong><br/>{this.state.error}
            </div>
          )}
        </div>
      </div>
    );
  }
}
