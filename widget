import { React } from 'jimu-core'
import maplibregl, { type LayerSpecification, type Map as MapLibreMap, type StyleSpecification, type CustomRenderMethodInput } from 'maplibre-gl'
import MapLibreWorker from 'maplibre-gl/dist/maplibre-gl-csp-worker'
import { type IMConfig, type Config, type LayerConfig } from '../../config'
import { ThreeD, type SectorData } from '../../lib/three-d-sectors'
import cubeIcon from '../../../cube.svg'

interface MapLibreViewProps {
  config: IMConfig
}

const DEFAULT_CENTER: [number, number] = [-98.5795, 39.8283]
const DEFAULT_ZOOM = 3.2
const DEFAULT_PITCH = 0
const DEFAULT_BEARING = 0
const DEFAULT_STYLE_URL = 'https://tiles.openfreemap.org/styles/positron'
const DEFAULT_TOKEN_URL = 'https://egisportal.dev.abc.com/egis-rhea-client/token'
const DEFAULT_SECTOR_ENDPOINT = 'https://rhea.web.abc.com/oauth21/api/sector/tile/{sector_name}/12.0/RSRP/style.json'
// const DEFAULT_VISUALIZATION_STYLE_URL = 'https://rhea.web.abc.com/oauth21/api/visualization/assets/styles/basic/style.json'
const DEFAULT_METADATA_SECTOR_STYLE_URL = 'https://rhea.web.abc.com/oauth21/api/metadata/sector/tile/style.json'
const DEFAULT_COVERAGE_STYLE_URL = 'https://rhea.web.abc.com/oauth21/api/vector/styles/all/style.json?coverageLayer={coverage_layer}'
const DEFAULT_BBOX_COVERAGE_ENDPOINT = 'https://rhea.web.abc.com/oauth21/api/rhea/bbox/{min_lng}/{min_lat}/{max_lng}/{max_lat}/output.json?resolution=4.0'
const DEFAULT_TOKEN_EXPIRY_SECONDS = 3599
const MIN_REFRESH_OFFSET_SECONDS = 60
const STATUS_POLL_INTERVAL_MS = 1909
const CELL_NAME = 'NWL91056_7C_1' 
const DEFAULT_SECTOR_NAME = CELL_NAME || 'replace-with-sector-name'
const ENABLE_WIDGET_3D_BUILDINGS_LAYER = false



type CoverageLayer = 'rsrp_dbm_poly' | 'sector_id_poly' | 'usid_poly' | 'bin_state_poly' | 'sector_counter_poly'

type OptimizationLayerType = 'none' | 'bin_state_pre' | 'bin_state_post' | 'bin_state_diff' | 
  'sinr_pre' | 'sinr_post' | 'sinr_floor' | 'sinr_delta' | 
  'sector_id_pre' | 'sector_id_post' | 'sector_id_diff' | 
  'rsrp_pre' | 'rsrp_post' | 'rsrp_diff' | 
  'user_density'

const OPTIMIZATION_LAYER_OPTIONS: Array<{ value: OptimizationLayerType, label: string, category: string }> = [
  { value: 'none', label: 'None (Hide Layer)', category: 'Control' },
  { value: 'bin_state_pre', label: 'Pre Optimization', category: 'Bin State' },
  { value: 'bin_state_post', label: 'Post Optimization', category: 'Bin State' },
  { value: 'bin_state_diff', label: 'Difference', category: 'Bin State' },
  { value: 'sinr_pre', label: 'Pre Optimization', category: 'SINR' },
  { value: 'sinr_post', label: 'Post Optimization', category: 'SINR' },
  { value: 'sinr_floor', label: 'Floor Data', category: 'SINR' },
  { value: 'sinr_delta', label: 'Delta', category: 'SINR' },
  { value: 'sector_id_pre', label: 'Pre Optimization', category: 'Sector ID' },
  { value: 'sector_id_post', label: 'Post Optimization', category: 'Sector ID' },
  { value: 'sector_id_diff', label: 'Difference', category: 'Sector ID' },
  { value: 'rsrp_pre', label: 'Pre Optimization', category: 'RSRP' },
  { value: 'rsrp_post', label: 'Post Optimization', category: 'RSRP' },
  { value: 'rsrp_diff', label: 'Difference', category: 'RSRP' },
  { value: 'user_density', label: 'User Density', category: 'User Density' }
]

const COVERAGE_LAYER_OPTIONS: Array<{ value: CoverageLayer, label: string }> = [
  { value: 'rsrp_dbm_poly', label: 'rsrp_dbm_poly' },
  { value: 'sector_id_poly', label: 'sector_id_poly' },
  { value: 'usid_poly', label: 'usid_poly' },
  { value: 'bin_state_poly', label: 'bin_state_poly' },
  { value: 'sector_counter_poly', label: 'sector_counter_poly' }
]

interface ApiVisibilityEntry {
  label: string
  enabled: boolean
}

interface BBoxBounds {
  minLng: number
  minLat: number
  maxLng: number
  maxLat: number
}

interface OptimizationResult {
  id: string
  sessionId: string
  jobId: string
  bounds: BBoxBounds
  data: any
  timestamp: number
  label: string
  color: string
  source: 'submitted' | 'recalled'
}

interface RecallFormState {
  sessionId: string
  jobId: string
  error: string | null
  loading: boolean
}

const RESULT_COLORS = ['#00ff00', '#0080ff', '#ff8000', '#ff00ff', '#ffff00', '#00ffff']

const clampLngLat = (lng: number, lat: number): [number, number] => {
  const clampedLng = Math.max(-180, Math.min(180, lng))
  const clampedLat = Math.max(-85, Math.min(85, lat))
  return [clampedLng, clampedLat]
}

const normalizeBBox = (a: [number, number], b: [number, number]): BBoxBounds => {
  const minLng = Math.min(a[0], b[0])
  const maxLng = Math.max(a[0], b[0])
  const minLat = Math.min(a[1], b[1])
  const maxLat = Math.max(a[1], b[1])
  return { minLng, minLat, maxLng, maxLat }
}

const formatCoord = (value: number): string => {
  return Number.isFinite(value) ? value.toFixed(6) : String(value)
}

// Generate unique ID using crypto API or fallback to timestamp-based UUID
const generateUniqueId = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID()
  }
  // Fallback: timestamp + random for uniqueness
  return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`
}

const looksLikeBinLayer = (layer: any): boolean => {
  if (!layer || typeof layer !== 'object') {
    return false
  }

  // Heuristic: only treat a layer as a "bin" layer if it is explicitly named/grouped
  // as bins. (Many non-bin layers are also circles.)
  const type = String(layer.type ?? '').toLowerCase()
  const id = String(layer.id ?? '').toLowerCase()
  const sourceLayer = String(layer['source-layer'] ?? '').toLowerCase()
  const metadataGroup = String(layer?.metadata?.group ?? '').toLowerCase()

  const mentionsBins = id.includes('bin') || id.includes('bins') || sourceLayer.includes('bin') || sourceLayer.includes('bins') || metadataGroup.includes('bin') || metadataGroup.includes('bins')

  if (mentionsBins && (type === 'circle' || type === 'symbol' || type === 'fill' || type === 'line')) {
    return true
  }

  return false
}

const looksLikeAggregatedLayer = (layer: any): boolean => {
  if (!layer || typeof layer !== 'object') {
    return false
  }
  // Heuristic: blended/aggregated coverage is commonly a heatmap.
  const type = String(layer.type ?? '').toLowerCase()
  return type === 'heatmap'
}

// Helper to extract bounding box from optimization results data
const extractBoundsFromResults = (data: any): BBoxBounds | null => {
  // Try to extract bounds from various possible locations in the API response
  if (data?.metadata?.bounds) {
    const b = data.metadata.bounds
    if (typeof b.minLng === 'number' && typeof b.minLat === 'number' &&
        typeof b.maxLng === 'number' && typeof b.maxLat === 'number') {
      return b
    }
  }

  if (data?.bounds) {
    const b = data.bounds
    if (typeof b.minLng === 'number' && typeof b.minLat === 'number' &&
        typeof b.maxLng === 'number' && typeof b.maxLat === 'number') {
      return b
    }
  }

  // Could add more extraction logic based on actual API response structure
  return null
}

;(maplibregl as typeof maplibregl & { workerClass?: typeof Worker }).workerClass = MapLibreWorker as typeof Worker

const findLabelLayerId = (map: MapLibreMap): string | undefined => {
  const style = map.getStyle()
  if (!style?.layers?.length) {
    return undefined
  }

  // We want overlays to render *above roads* but keep labels on top.
  // Using the first label layer can place overlays too low (under later road layers).
  // Pick the top-most label layer (last symbol layer with a text-field).
  for (let i = style.layers.length - 1; i >= 0; i--) {
    const layer = style.layers[i] as LayerSpecification
    if (layer?.type !== 'symbol') {
      continue
    }
    const layout = (layer as any)?.layout
    if (layout?.['text-field']) {
      return layer.id
    }
  }

  return undefined
}

const findOverlayBeforeLayerId = (map: MapLibreMap): string | undefined => {
  const style = map.getStyle()
  if (!style?.layers?.length) {
    return undefined
  }

  const layers = style.layers as LayerSpecification[]

  const isLabelLayer = (layer: LayerSpecification): boolean => {
    if (layer?.type !== 'symbol') {
      return false
    }
    const layout = (layer as any)?.layout
    return Boolean(layout?.['text-field'])
  }

  const isRoadLayer = (layer: LayerSpecification): boolean => {
    if (!layer || typeof layer !== 'object') {
      return false
    }

    // Heuristic: match common road naming conventions in ids/source-layers.
    // This is intentionally loose; goal is to find the *highest* road-ish layer.
    const type = String((layer as any)?.type ?? '').toLowerCase()
    if (type !== 'line') {
      return false
    }

    const id = String((layer as any)?.id ?? '').toLowerCase()
    const sourceLayer = String((layer as any)?.['source-layer'] ?? '').toLowerCase()
    const metadataGroup = String((layer as any)?.metadata?.group ?? '').toLowerCase()
    const haystack = `${id} ${sourceLayer} ${metadataGroup}`

    return (
      haystack.includes('road') ||
      haystack.includes('roads') ||
      haystack.includes('street') ||
      haystack.includes('streets') ||
      haystack.includes('highway') ||
      haystack.includes('motorway') ||
      haystack.includes('transportation') ||
      haystack.includes('transport') ||
      haystack.includes('route') ||
      haystack.includes('routes') ||
      haystack.includes('path') ||
      haystack.includes('paths') ||
      haystack.includes('tunnel') ||
      haystack.includes('bridge')
    )
  }

  // 1) Find the top-most road layer index.
  let lastRoadIndex = -1
  for (let i = 0; i < layers.length; i++) {
    if (isRoadLayer(layers[i])) {
      lastRoadIndex = i
    }
  }

  // 2) Insert overlays just above roads, but before the next "always-on-top" layer
  // (labels or extrusions) after roads.
  if (lastRoadIndex >= 0) {
    let candidateId: string | undefined
    for (let i = lastRoadIndex + 1; i < layers.length; i++) {
      const layer = layers[i]
      if (layer?.type === 'fill-extrusion' || isLabelLayer(layer)) {
        candidateId = layer.id
        break
      }
    }

    // If we found a reasonable layer to stay under, use it.
    if (candidateId) {
      return candidateId
    }

    // Otherwise, no labels/extrusions above roads; add overlay to the top.
    return undefined
  }

  // 3) If we can't identify roads, fall back to staying under top-most labels.
  return findLabelLayerId(map)
}

const MapLibreView = ({ config }: MapLibreViewProps) => {
  const mapContainerRef = React.useRef<HTMLDivElement>(null)
  const mapRef = React.useRef<MapLibreMap | null>(null)
  const [mapReady, setMapReady] = React.useState(false)
  const overlayRef = React.useRef<Record<string, { sourceIds: string[], layerIds: string[] }>>({})
  const coverageOriginalOpacityRef = React.useRef<Record<string, number>>({})
  const threeDSceneRef = React.useRef<ThreeD.Scene>(new ThreeD.Scene())
  const [show3DSectors, setShow3DSectors] = React.useState<boolean>(true)
  const [sectorScale, setSectorScale] = React.useState<number>(1)
  const terrainChangedRef = React.useRef<boolean>(false)

  const fallbackConfig = React.useMemo<Config>(() => ({
    mapStyleUrl: DEFAULT_STYLE_URL,
    initialView: {
      center: DEFAULT_CENTER,
      zoom: DEFAULT_ZOOM,
      bearing: DEFAULT_BEARING,
      pitch: DEFAULT_PITCH
    },
    layers: [],
    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,
    api: {
      tokenUrl: DEFAULT_TOKEN_URL,
      sectorEndpoint: DEFAULT_SECTOR_ENDPOINT,
      sectorName: DEFAULT_SECTOR_NAME,
      refreshOffsetSeconds: MIN_REFRESH_OFFSET_SECONDS
    }
  }), [])

  const runtimeConfig = React.useMemo<Config>(() => {
    return config?.asMutable({ deep: true }) ?? fallbackConfig
  }, [config, fallbackConfig])

  const [authState, setAuthState] = React.useState<{ accessToken: string | null, expiresIn: number | null }>({ accessToken: null, expiresIn: null })
  const [visualizationData, setVisualizationData] = React.useState<any>(null)
  const [visualizationStatus, setVisualizationStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [visualizationError, setVisualizationError] = React.useState<string | null>(null)
  const [lastVisualizationUrl, setLastVisualizationUrl] = React.useState<string | null>(null)

  const [metadataStyleData, setMetadataStyleData] = React.useState<any>(null)
  const [metadataStyleStatus, setMetadataStyleStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [metadataStyleError, setMetadataStyleError] = React.useState<string | null>(null)
  const [lastMetadataStyleUrl, setLastMetadataStyleUrl] = React.useState<string | null>(null)

  const [clickedSectorData, setClickedSectorData] = React.useState<SectorData | null>(null)
  const [sectorStyleData, setSectorStyleData] = React.useState<any>(null)
  const [sectorStyleStatus, setSectorStyleStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [sectorStyleError, setSectorStyleError] = React.useState<string | null>(null)
  const [lastSectorStyleUrl, setLastSectorStyleUrl] = React.useState<string | null>(null)

  const [coverageStyleData, setCoverageStyleData] = React.useState<any>(null)
  const [coverageStyleStatus, setCoverageStyleStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [coverageStyleError, setCoverageStyleError] = React.useState<string | null>(null)
  const [lastCoverageStyleUrl, setLastCoverageStyleUrl] = React.useState<string | null>(null)
  const [coverageShowBins, setCoverageShowBins] = React.useState<boolean>(false)
  const [coverageLayer, setCoverageLayer] = React.useState<CoverageLayer>('rsrp_dbm_poly')
  const [coverageOpacity, setCoverageOpacity] = React.useState<number>(50)
  const [coverageVisible, setCoverageVisible] = React.useState<boolean>(true)
  const [legendExpanded, setLegendExpanded] = React.useState<boolean>(false)

  // IQI Layer State
  const [iqiVisible, setIqiVisible] = React.useState<boolean>(false)
  const [iqiOpacity, setIqiOpacity] = React.useState<number>(100)
  const [iqiToken, setIqiToken] = React.useState<string | null>(null)
  const [iqiTokenExpiresAt, setIqiTokenExpiresAt] = React.useState<number | null>(null)
  const [iqiStatus, setIqiStatus] = React.useState<'idle' | 'loading-token' | 'loading-data' | 'success' | 'error'>('idle')
  const [iqiError, setIqiError] = React.useState<string | null>(null)
  const [iqiFeatureCount, setIqiFeatureCount] = React.useState<number>(0)
  const iqiFetchControllerRef = React.useRef<AbortController | null>(null)
  const iqiTokenRefreshTimerRef = React.useRef<number | null>(null)

  const coverageStyleLayerSummary = React.useMemo(() => {
    const layers = Array.isArray((coverageStyleData as any)?.layers) ? (coverageStyleData as any).layers : []
    const total = layers.length
    const circleCount = layers.filter((l: any) => String(l?.type ?? '').toLowerCase() === 'circle').length
    const heatmapCount = layers.filter((l: any) => String(l?.type ?? '').toLowerCase() === 'heatmap').length
    const binLikeCount = layers.filter((l: any) => looksLikeBinLayer(l)).length
    const nonBinCount = Math.max(total - binLikeCount, 0)
    return { total, circleCount, heatmapCount, binLikeCount, nonBinCount }
  }, [coverageStyleData])

  // RSRP Coverage Legend Data
  const RSRP_LEGEND = React.useMemo(() => [
    { value: -126, color: '#a0d5e8', label: '≤ -126' },
    { value: -118, color: '#90cde0', label: '≤ -118' },
    { value: -109, color: '#7bc5d8', label: '≤ -109' },
    { value: -100, color: '#90d090', label: '≤ -100' },
    { value: -92, color: '#70c070', label: '≤ -92' },
    { value: -83, color: '#b8d050', label: '≤ -83' },
    { value: -75, color: '#f0d040', label: '≤ -75' },
    { value: -66, color: '#f09030', label: '≤ -66' },
    { value: -57, color: '#f05030', label: '≤ -57' },
    { value: -49, color: '#e03040', label: '≤ -49' },
    { value: -48, color: '#c02060', label: '≤ -48' }
  ], [])

  // Bin State Legend Data
  const BIN_STATE_LEGEND = React.useMemo(() => [
    { value: 'no_coverage', color: '#c0c0c0', label: 'No Coverage' },
    { value: 'dominance', color: '#6b4c3f', label: 'Dominance' },
    { value: 'lack_dominance', color: '#d4702d', label: 'Lack of Dominance' },
    { value: 'interference', color: '#d03030', label: 'Interference' },
    { value: 'not_defined', color: '#2a2a2a', label: 'Not Defined' }
  ], [])

  // Sector Counter Legend Data
  const SECTOR_COUNTER_LEGEND = React.useMemo(() => [
    { value: 100, color: '#2b4cff', label: '100' },
    { value: 200, color: '#1a2fa8', label: '200' },
    { value: 300, color: '#26c6da', label: '300' },
    { value: 400, color: '#00b3b3', label: '400' },
    { value: 500, color: '#00c853', label: '500' },
    { value: 600, color: '#7ed957', label: '600' },
    { value: 700, color: '#ffd500', label: '700' },
    { value: 800, color: '#ff9800', label: '800' },
    { value: 900, color: '#e53935', label: '900' },
    { value: 1000, color: '#b71c1c', label: '1000' }
  ], [])

  const [showApiControls, setShowApiControls] = React.useState<boolean>(false)
  const [apiVisibility, setApiVisibility] = React.useState<Record<string, ApiVisibilityEntry>>({})

  const [optimizationDrawEnabled, setOptimizationDrawEnabled] = React.useState<boolean>(false)
  const [optimizationBounds, setOptimizationBounds] = React.useState<BBoxBounds | null>(null)
  const optimizationBoundsRef = React.useRef<BBoxBounds | null>(null)
  const optimizationDrawRef = React.useRef<{ sourceId: string, fillLayerId: string, lineLayerId: string } | null>(null)
  const optimizationDrawingStateRef = React.useRef<{ active: boolean, startPoint: maplibregl.PointLike, startLngLat: maplibregl.LngLatLike } | null>(null)
  const [optimizationSectors, setOptimizationSectors] = React.useState<number[]>([])
  const [selectedOptimizationSector, setSelectedOptimizationSector] = React.useState<number | null>(null)
  const [selectedNetworkType, setSelectedNetworkType] = React.useState<string>('LTE')
  const [optimizationStatus, setOptimizationStatus] = React.useState<'idle' | 'drawing' | 'ready' | 'loading' | 'success' | 'error'>('idle')
  const [optimizationError, setOptimizationError] = React.useState<string | null>(null)
  const [lastOptimizationUrl, setLastOptimizationUrl] = React.useState<string | null>(null)

  const [sessionId, setSessionId] = React.useState<string>('')
  const [jobId, setJobId] = React.useState<string>('')
  const [optimizationJobStatus, setOptimizationJobStatus] = React.useState<'idle' | 'submitting' | 'polling' | 'completed' | 'error'>('idle')
  const [optimizationJobError, setOptimizationJobError] = React.useState<string | null>(null)
  const [statusMessage, setStatusMessage] = React.useState<string>('')
  const [statusDetails, setStatusDetails] = React.useState<any>(null)
  const [submissionResponse, setSubmissionResponse] = React.useState<any>(null)
  const [lastSubmissionUrl, setLastSubmissionUrl] = React.useState<string | null>(null)
  const [lastStatusUrl, setLastStatusUrl] = React.useState<string | null>(null)
  const [pollingCount, setPollingCount] = React.useState<number>(0)
  const [optimizationResults, setOptimizationResults] = React.useState<any>(null)
  const [showResultsView, setShowResultsView] = React.useState<boolean>(false)
  const [resultsError, setResultsError] = React.useState<string | null>(null)
  const [showJsonDetails, setShowJsonDetails] = React.useState<boolean>(false)
  const [showTiltTableModal, setShowTiltTableModal] = React.useState<boolean>(false)
  const pollingTimerRef = React.useRef<number | null>(null)

  // Multi-Result Management (New)
  const [optimizationResultsArray, setOptimizationResultsArray] = React.useState<OptimizationResult[]>([])
  const [activeResultIndex, setActiveResultIndex] = React.useState<number | null>(null)
  const [showResultsPanel, setShowResultsPanel] = React.useState<boolean>(false)

  // Recall Functionality
  const [recallFormVisible, setRecallFormVisible] = React.useState<boolean>(false)
  const [recallForm, setRecallForm] = React.useState<RecallFormState>({
    sessionId: '',
    jobId: '',
    error: null,
    loading: false
  })

  // Comparison View
  const [comparisonMode, setComparisonMode] = React.useState<boolean>(false)
  const [selectedComparisonIndices, setSelectedComparisonIndices] = React.useState<[number, number]>([0, 1])

  // Bounding Box Visualization
  const [visibleBoundingBoxes, setVisibleBoundingBoxes] = React.useState<Set<string>>(new Set())

  // Optimization Hyperparameters
  const DEFAULT_HYPERPARAMETERS = React.useMemo(() => ({
    rsrp_threshold: -106,
    sinr_threshold: 0,
    alpha_condition_change: 0.9,
    alpha_bin_to_bin: 0.6,
    condition_change_multiplier: 5,
    rsrp_bin_to_bin_loss_tolerance: 0,
    rsrp_condition_change_loss_tolerance: 0,
    use_user_density_cache: true,
    use_default_antenna_pabcerns_only: false
  }), [])

  const HYPERPARAMETER_TOOLTIPS = React.useMemo(() => ({
    rsrp_threshold: 'Threshold for good/bad RSRP in dBm.',
    sinr_threshold: 'Threshold for good/bad SINR in dBm.',
    alpha_condition_change: 'SINR/RSRP weightage for condition change score. At 1.0, SINR has 100% weightage, and RSRP 0%. At 0.5, both have equal weightage. At 0.0, RSRP has 100% weightage, and SINR 0%.',
    alpha_bin_to_bin: 'SINR/RSRP weightage for bin-to-bin improvement score. At 1.0, SINR has 100% weightage, and RSRP 0%. At 0.5, both have equal weightage. At 0.0, RSRP has 100% weightage, and SINR 0%.',
    condition_change_multiplier: 'Multiplier for condition change score, as compared to bin-to-bin score. At 1, condition change and bin-to-bin scores have equal weightage. At 0.5, condition change has half the weightage of bin-to-bin. At 5, condition change has 5 times the weightage of bin-to-bin.',
    rsrp_bin_to_bin_loss_tolerance: 'Percentage of Net RSRP Bin to Bin that you are willing to sacrifice in exchange for SINR improvement. Should be between -100 and 0, i.e -0.5 means a tolerance of -0.5% Net RSRP Bin to Bin.',
    rsrp_condition_change_loss_tolerance: 'Percentage of Net RSRP Condition Change that you are willing to sacrifice in exchange for SINR improvement. Should be between -100 and 0, i.e -0.5 means a tolerance of -0.5% Net RSRP Condition.',
    use_user_density_cache: 'If true, use user density cache for optimization. If false, do not use user density cache for optimization.',
    use_default_antenna_pabcerns_only: 'If true, only uses default antenna pabcern types.'
  }), [])

  const [hyperparameters, setHyperparameters] = React.useState(DEFAULT_HYPERPARAMETERS)
  const [hyperparametersExpanded, setHyperparametersExpanded] = React.useState<boolean>(false)

  const hasHyperparametersChanged = React.useCallback(() => {
    return Object.keys(hyperparameters).some(
      key => hyperparameters[key as keyof typeof hyperparameters] !== DEFAULT_HYPERPARAMETERS[key as keyof typeof DEFAULT_HYPERPARAMETERS]
    )
  }, [hyperparameters, DEFAULT_HYPERPARAMETERS])

  // Computed value: get active result's data for backward compatibility
  const activeResultData = React.useMemo(() => {
    if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
      return optimizationResultsArray[activeResultIndex].data
    }
    return null
  }, [optimizationResultsArray, activeResultIndex])

  const [optimizationLayerType, setOptimizationLayerType] = React.useState<string>('none')
  const [optimizationLayerData, setOptimizationLayerData] = React.useState<any>(null)
  const [optimizationLayerStatus, setOptimizationLayerStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [optimizationLayerError, setOptimizationLayerError] = React.useState<string | null>(null)

  // Per-result optimization layer tracking
  const [resultLayerTypes, setResultLayerTypes] = React.useState<Record<string, OptimizationLayerType>>({})
  const resultLayerDataRef = React.useRef<Record<string, any>>({})
  const resultLayerStatusRef = React.useRef<Record<string, 'idle' | 'loading' | 'success' | 'error'>>({})

  const [tokenStatus, setTokenStatus] = React.useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [tokenError, setTokenError] = React.useState<string | null>(null)
  const [lastTokenUrlTried, setLastTokenUrlTried] = React.useState<string | null>(null)
  const [lastMapError, setLastMapError] = React.useState<string | null>(null)
  const tokenRefreshTimerRef = React.useRef<number | null>(null)
  const [sectorName, setSectorName] = React.useState<string>(runtimeConfig.api?.sectorName ?? DEFAULT_SECTOR_NAME)
  const authTokenRef = React.useRef<string | null>(null)
  const [lastAccessToken, setLastAccessToken] = React.useState<string | null>(null)

  const defaultApiLabel = React.useCallback((key: string): string => {
    const trimmed = (key ?? '').trim()
    if (trimmed.length === 0) {
      return 'API'
    }

    const known: Record<string, string> = {
      sector: 'Sector',
      bbox: 'BBox Coverage',
      coverage: 'Coverage',
      viz: 'Vegetation',
      meta: 'Metadata'
    }

    if (known[trimmed]) {
      return known[trimmed]
    }

    const spaced = trimmed
      .replace(/[-_]+/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')

    return spaced
      .split(' ')
      .filter(Boolean)
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
      .join(' ')
  }, [])

  const registerApi = React.useCallback((key: string, label?: string) => {
    const normalizedKey = String(key ?? '').trim()
    if (normalizedKey.length === 0) {
      return
    }

    setApiVisibility((prev: Record<string, ApiVisibilityEntry>) => {
      if (prev[normalizedKey]) {
        return prev
      }
      return {
        ...prev,
        [normalizedKey]: {
          label: typeof label === 'string' && label.trim().length > 0 ? label.trim() : defaultApiLabel(normalizedKey),
          enabled: true
        }
      }
    })
  }, [defaultApiLabel])

  const isApiEnabled = React.useCallback((key: string): boolean => {
    const normalizedKey = String(key ?? '').trim()
    if (normalizedKey.length === 0) {
      return true
    }
    return apiVisibility[normalizedKey]?.enabled ?? true
  }, [apiVisibility])

  React.useEffect(() => {
    // Seed known APIs so the list is visible before first successful fetch.
    registerApi('sector', 'Sector')
    registerApi('bbox', 'BBox Coverage')
    registerApi('coverage', 'Coverage')
    registerApi('viz', 'Vegetation')
    registerApi('meta', 'Metadata')
  }, [registerApi])

  const clearOverlay = React.useCallback((overlayKey: string) => {
    if (!mapRef.current) {
      overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }
      return
    }

    const map = mapRef.current
    const prior = overlayRef.current[overlayKey]
    if (!prior) {
      overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }
      return
    }

    prior.layerIds.forEach((layerId: string) => {
      if (map.getLayer(layerId)) {
        map.removeLayer(layerId)
      }
    })

    prior.sourceIds.forEach((sourceId: string) => {
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId)
      }
    })

    overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }
  }, [])

  const applyGeoJsonOverlay = React.useCallback((overlayKey: string, geojson: any) => {
    registerApi(overlayKey)

    if (!isApiEnabled(overlayKey)) {
      clearOverlay(overlayKey)
      return
    }

    if (!mapRef.current) {
      return
    }

    const map = mapRef.current

    const isGeoJsonFeatureCollection = geojson && typeof geojson === 'object' && geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)
    const isGeoJsonFeature = geojson && typeof geojson === 'object' && geojson.type === 'Feature' && geojson.geometry
    if (!isGeoJsonFeatureCollection && !isGeoJsonFeature) {
      throw new Error('Response is not a MapLibre style or GeoJSON')
    }

    clearOverlay(overlayKey)

    const sourceId = `${overlayKey}-geojson-src`
    const fillLayerId = `${overlayKey}-geojson-fill`
    const lineLayerId = `${overlayKey}-geojson-line`

    if (map.getSource(sourceId)) {
      map.removeSource(sourceId)
    }

    map.addSource(sourceId, {
      type: 'geojson',
      data: geojson
    } as any)

    const beforeLayerId = findOverlayBeforeLayerId(map)

    if (map.getLayer(fillLayerId)) {
      map.removeLayer(fillLayerId)
    }
    map.addLayer({
      id: fillLayerId,
      type: 'fill',
      source: sourceId,
      paint: {
        'fill-color': '#fff',
        'fill-opacity': 0.2
      }
    } as any, beforeLayerId)

    if (map.getLayer(lineLayerId)) {
      map.removeLayer(lineLayerId)
    }
    map.addLayer({
      id: lineLayerId,
      type: 'line',
      source: sourceId,
      paint: {
        'line-color': '#fff',
        'line-width': 2
      }
    } as any, beforeLayerId)

    overlayRef.current[overlayKey] = { sourceIds: [sourceId], layerIds: [fillLayerId, lineLayerId] }
  }, [clearOverlay, isApiEnabled, registerApi])

  const applyOverlayStyle = React.useCallback((overlayKey: string, styleJson: any) => {
    registerApi(overlayKey)

    if (!isApiEnabled(overlayKey)) {
      clearOverlay(overlayKey)
      return
    }

    if (!mapRef.current) {
      return
    }

    const map = mapRef.current
    const style = styleJson as Partial<StyleSpecification>

    const sources = style?.sources
    const layers = style?.layers

    if (!sources || typeof sources !== 'object' || !Array.isArray(layers)) {
      throw new Error('Response is not a valid MapLibre style (missing sources/layers)')
    }

    const prior = overlayRef.current[overlayKey]
    if (prior) {
      prior.layerIds.forEach((layerId: string) => {
        if (map.getLayer(layerId)) {
          map.removeLayer(layerId)
        }
      })
      prior.sourceIds.forEach((sourceId: string) => {
        if (map.getSource(sourceId)) {
          map.removeSource(sourceId)
        }
      })
    }
    overlayRef.current[overlayKey] = { sourceIds: [], layerIds: [] }

    const sourceIdMap = new Map<string, string>()
    Object.entries(sources).forEach(([sourceKey, sourceValue]) => {
      const newSourceId = `${overlayKey}-src-${sourceKey}`
      sourceIdMap.set(sourceKey, newSourceId)

      if (map.getSource(newSourceId)) {
        map.removeSource(newSourceId)
      }
      map.addSource(newSourceId, sourceValue as any)
      overlayRef.current[overlayKey].sourceIds.push(newSourceId)
    })

    const beforeLayerId = findOverlayBeforeLayerId(map)

    // Map layer ids so styles that use `ref` (layer references) keep working.
    const layerIdMap = new Map<string, string>()
    layers.forEach((layer: any) => {
      const originalId = typeof layer?.id === 'string' ? layer.id : undefined
      if (!originalId) {
        return
      }
      layerIdMap.set(originalId, `${overlayKey}-lyr-${originalId}`)
    })

    layers.forEach((layer: any) => {
      if (!layer || typeof layer !== 'object') {
        return
      }

      if (layer.type === 'background') {
        return
      }

      const originalId = typeof layer.id === 'string' ? layer.id : undefined
      const mappedSource = typeof layer.source === 'string' ? sourceIdMap.get(layer.source) : undefined
      if (typeof layer.source === 'string' && !mappedSource) {
        return
      }

      const newLayerId = originalId ? (layerIdMap.get(originalId) ?? `${overlayKey}-lyr-${originalId}`) : `${overlayKey}-lyr-${String(Math.random()).slice(2)}`
      const newLayer: any = { ...layer, id: newLayerId }
      if (mappedSource) {
        newLayer.source = mappedSource
      }

      if (typeof newLayer.ref === 'string') {
        const mappedRef = layerIdMap.get(newLayer.ref)
        if (mappedRef) {
          newLayer.ref = mappedRef
        }
      }

      if (map.getLayer(newLayerId)) {
        map.removeLayer(newLayerId)
      }
      map.addLayer(newLayer as any, beforeLayerId)
      overlayRef.current[overlayKey].layerIds.push(newLayerId)
      
      // Store original opacity values for coverage layers
      if (overlayKey === 'coverage') {
        const paint = newLayer.paint || {}
        const layerType = newLayer.type
        if (layerType === 'fill' && typeof paint['fill-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['fill-opacity']
        } else if (layerType === 'line' && typeof paint['line-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['line-opacity']
        } else if (layerType === 'circle' && typeof paint['circle-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['circle-opacity']
        } else if (layerType === 'heatmap' && typeof paint['heatmap-opacity'] === 'number') {
          coverageOriginalOpacityRef.current[newLayerId] = paint['heatmap-opacity']
        } else if (layerType === 'symbol') {
          if (typeof paint['text-opacity'] === 'number') {
            coverageOriginalOpacityRef.current[`${newLayerId}-text`] = paint['text-opacity']
          }
          if (typeof paint['icon-opacity'] === 'number') {
            coverageOriginalOpacityRef.current[`${newLayerId}-icon`] = paint['icon-opacity']
          }
        }
      }
    })
  }, [clearOverlay, isApiEnabled, registerApi])

  const styleUrl = React.useMemo(() => {
    const configuredStyle = runtimeConfig?.mapStyleUrl?.trim()
    return configuredStyle && configuredStyle.length > 0 ? configuredStyle : DEFAULT_STYLE_URL
  }, [runtimeConfig?.mapStyleUrl])

  const pixelRatio = React.useMemo(() => {
    const fallback = typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1
    const configuredRatio = runtimeConfig?.pixelRatio
    const desired = typeof configuredRatio === 'number' && Number.isFinite(configuredRatio)
      ? configuredRatio
      : fallback
    return Math.min(Math.max(desired, 1), 3)
  }, [runtimeConfig?.pixelRatio])

  const refreshToken = React.useCallback(async () => {
    setTokenStatus('loading')
    setTokenError(null)
    setLastTokenUrlTried(DEFAULT_TOKEN_URL)

    try {
      const response = await fetch(DEFAULT_TOKEN_URL, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json'
        }
      })

      if (!response.ok) {
        throw new Error(`Token fetch failed with status ${response.status}`)
      }

      const tokenData = await response.json()
      
      if (!tokenData.access_token || typeof tokenData.access_token !== 'string') {
        throw new Error('Invalid token response: missing or invalid access_token field')
      }

      const accessToken = tokenData.access_token.trim()
      const expiresIn = typeof tokenData.expires_in === 'number' ? tokenData.expires_in : DEFAULT_TOKEN_EXPIRY_SECONDS

      setAuthState({ accessToken, expiresIn })
      authTokenRef.current = accessToken
      setLastAccessToken(accessToken)
      setTokenStatus('success')
      setTokenError(null)

      // Schedule next token refresh with safety margin
      const refreshIntervalMs = Math.max((expiresIn - MIN_REFRESH_OFFSET_SECONDS) * 1000, 60000)
      if (tokenRefreshTimerRef.current) {
        window.clearTimeout(tokenRefreshTimerRef.current)
      }
      tokenRefreshTimerRef.current = window.setTimeout(() => {
        void refreshToken()
      }, refreshIntervalMs)

      return accessToken
    } catch (error) {
      console.error('Failed to fetch token from', DEFAULT_TOKEN_URL, error)
      setAuthState({ accessToken: null, expiresIn: null })
      authTokenRef.current = null
      setLastAccessToken(null)
      setTokenStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching token endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setTokenError(message)

      if (tokenRefreshTimerRef.current) {
        window.clearTimeout(tokenRefreshTimerRef.current)
        tokenRefreshTimerRef.current = null
      }

      return null
    }
  }, [])

  // ─── IQI LAYER TOKEN MANAGEMENT ───────────────────────────────────────────────

  const fetchIqiToken = React.useCallback(async (): Promise<string | null> => {
    const IQI_TOKEN_URL = 'https://egisportal.dev.abc.com/egis-js-app/token'
    
    try {
      const response = await fetch(IQI_TOKEN_URL, {
        method: 'GET',
        mode: 'cors',
        cache: 'no-store'
      })
      
      if (!response.ok) {
        throw new Error(`IQI token fetch failed with status ${response.status}`)
      }
      
      const result = await response.json()
      const rawToken = result.access_token
      const expiresIn = result.expires_in || 7200
      
      if (!rawToken || typeof rawToken !== 'string') {
        throw new Error('Invalid IQI token response: missing or invalid access_token field')
      }
      
      const tokenExpiresAt = Date.now() + ((expiresIn - 60) * 1000)
      setIqiToken(rawToken)
      setIqiTokenExpiresAt(tokenExpiresAt)
      
      // Schedule next token refresh with safety margin
      const refreshIntervalMs = Math.max((expiresIn - 60) * 1000, 60000)
      if (iqiTokenRefreshTimerRef.current) {
        window.clearTimeout(iqiTokenRefreshTimerRef.current)
      }
      iqiTokenRefreshTimerRef.current = window.setTimeout(() => {
        void fetchIqiToken()
      }, refreshIntervalMs)
      
      return rawToken
    } catch (error) {
      console.error('Failed to fetch IQI token from', IQI_TOKEN_URL, error)
      setIqiToken(null)
      setIqiTokenExpiresAt(null)
      setIqiError(error instanceof Error ? error.message : 'Failed to fetch IQI token')
      
      if (iqiTokenRefreshTimerRef.current) {
        window.clearTimeout(iqiTokenRefreshTimerRef.current)
        iqiTokenRefreshTimerRef.current = null
      }
      
      return null
    }
  }, [])

  const ensureIqiToken = React.useCallback(async (): Promise<string | null> => {
    if (iqiToken && iqiTokenExpiresAt && Date.now() < iqiTokenExpiresAt) {
      return iqiToken
    }
    return await fetchIqiToken()
  }, [iqiToken, iqiTokenExpiresAt, fetchIqiToken])

  // ─── IQI LAYER DATA FETCHING ──────────────────────────────────────────────────

  const fetchIqiData = React.useCallback(async () => {
    if (!mapRef.current) {
      return
    }

    const map = mapRef.current
    const zoom = map.getZoom()

    // Only load at zoom level 12+
    if (zoom < 12) {
      setIqiStatus('idle')
      setIqiFeatureCount(0)
      setIqiError(`Zoom in to 12+ to load features (current: ${Math.floor(zoom)})`)
      clearOverlay('iqi')
      return
    }

    // Abort any previous fetch
    if (iqiFetchControllerRef.current) {
      iqiFetchControllerRef.current.abort()
    }
    iqiFetchControllerRef.current = new AbortController()
    const signal = iqiFetchControllerRef.current.signal

    setIqiStatus('loading-token')
    setIqiError(null)

    const token = await ensureIqiToken()
    if (!token) {
      setIqiStatus('error')
      setIqiError('Failed to get IQI token')
      return
    }

    if (signal.aborted) return

    const bounds = map.getBounds()
    const bbox = {
      xmin: bounds.getWest(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      ymax: bounds.getNorth()
    }

    const FEATURE_SERVER_URL = 'https://egisarcgis.dev.abc.com/arcgissecure/rest/services/On_Air_MGRS_100m_Single_Layer/FeatureServer/0'
    const MAX_RECORDS = 2000

    // Determine grid size based on zoom level
    // With 2000 max records, need more cells to cover dense areas
    // Key: each cell must contain < 2000 features to avoid truncation
    const gridSize = zoom >= 15 ? 1 : zoom >= 14 ? 2 : zoom >= 13 ? 4 : 6

    try {
      let featureBuffer: any[] = []

      if (gridSize === 1) {
        // Single request for entire viewport
        setIqiStatus('loading-data')
        featureBuffer = await fetchIqiBbox(bbox, token, signal, FEATURE_SERVER_URL, MAX_RECORDS)
        
        if (signal.aborted) return
        
        if (featureBuffer.length === 0) {
          setIqiStatus('idle')
          setIqiFeatureCount(0)
          setIqiError('No IQI features in viewport')
          clearOverlay('iqi')
          return
        }
        
        renderIqiFeatures(featureBuffer)
        setIqiFeatureCount(featureBuffer.length)
        setIqiStatus('success')
        setIqiError(null)
      } else {
        // Grid-based progressive fetching
        const cellWidth = (bbox.xmax - bbox.xmin) / gridSize
        const cellHeight = (bbox.ymax - bbox.ymin) / gridSize

        const cells: any[] = []
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            cells.push({
              xmin: bbox.xmin + c * cellWidth,
              ymin: bbox.ymin + r * cellHeight,
              xmax: bbox.xmin + (c + 1) * cellWidth,
              ymax: bbox.ymin + (r + 1) * cellHeight
            })
          }
        }

        const seen = new Set<string>()
        let completed = 0
        const total = cells.length

        // Fire all requests at once — browser will manage concurrency (6 parallel)
        const promises = cells.map(cell =>
          fetchIqiBbox(cell, token, signal, FEATURE_SERVER_URL, MAX_RECORDS).then(features => {
            if (signal.aborted) return

            for (const f of features) {
              const id = f.id || f.properties?.OBJECTID || f.properties?.objectid
              if (id != null) {
                const key = String(id)
                if (seen.has(key)) continue
                seen.add(key)
              }
              featureBuffer.push(f)
            }

            completed++
            
            // Progressive rendering and status updates
            if (featureBuffer.length > 0) {
              renderIqiFeatures(featureBuffer)
            }
            
            setIqiFeatureCount(featureBuffer.length)
            setIqiStatus('loading-data')
            setIqiError(`Loading ${completed}/${total}... (${featureBuffer.length.toLocaleString()})`)
          })
        )

        await Promise.all(promises)

        if (signal.aborted) return

        if (featureBuffer.length === 0) {
          setIqiStatus('idle')
          setIqiFeatureCount(0)
          setIqiError('No IQI features in viewport')
          clearOverlay('iqi')
          return
        }

        setIqiStatus('success')
        setIqiFeatureCount(featureBuffer.length)
        setIqiError(null)
      }
    } catch (error) {
      if (signal.aborted) return
      
      console.error('IQI data fetch error:', error)
      setIqiStatus('error')
      setIqiError(error instanceof Error ? error.message : 'Failed to fetch IQI data')
      setIqiFeatureCount(0)
      clearOverlay('iqi')
    }
  }, [ensureIqiToken, clearOverlay])

  const fetchIqiBbox = async (
    bbox: any,
    token: string,
    signal: AbortSignal,
    featureServerUrl: string,
    maxRecords: number
  ): Promise<any[]> => {
    if (signal.aborted) return []

    let tokenParam = encodeURIComponent(token)
    if (token.endsWith('.')) {
      tokenParam = tokenParam.slice(0, -1) + '%2E'
    }

    const geometryFilter = encodeURIComponent(JSON.stringify({
      ...bbox,
      spatialReference: { wkid: 4326 }
    }))

    const url = `${featureServerUrl}/query?where=1=1&outFields=OBJECTID,rsrp&resultRecordCount=${maxRecords}&geometry=${geometryFilter}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&f=geoJson&returnGeometry=true&outSR=4326&token=${tokenParam}`

    try {
      const res = await fetch(url, { signal })
      
      if (!res.ok) {
        console.warn(`IQI: HTTP ${res.status} for cell, skipping`)
        return []
      }
      
      const text = await res.text()

      if (text.startsWith('<')) {
        console.warn('IQI: HTML response received, skipping')
        return []
      }

      const json = JSON.parse(text)

      if (json.error) {
        console.warn('IQI: ArcGIS error:', json.error.message)
        return []
      }

      return json.features || []
    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') return []
      console.warn('IQI fetch error:', err)
      return []
    }
  }

  const renderIqiFeatures = React.useCallback((features: any[]) => {
    if (!mapRef.current || features.length === 0) {
      return
    }

    const map = mapRef.current
    const geojson: any = { type: 'FeatureCollection', features }

    const sourceId = 'iqi-data-source'
    const fillLayerId = 'iqi-fill-layer'
    const outlineLayerId = 'iqi-outline-layer'

    // Remove existing layers and source
    if (map.getLayer(outlineLayerId)) map.removeLayer(outlineLayerId)
    if (map.getLayer(fillLayerId)) map.removeLayer(fillLayerId)
    if (map.getSource(sourceId)) map.removeSource(sourceId)

    // Add source
    map.addSource(sourceId, {
      type: 'geojson',
      data: geojson
    } as any)

    // Determine layer position - should be on top of everything
    // But still respect the label layers
    const beforeLayerId = findLabelLayerId(map)

    // Add fill layer with RSRP-based styling
    map.addLayer({
      id: fillLayerId,
      type: 'fill',
      source: sourceId,
      paint: {
        'fill-color': [
          'step',
          ['get', 'rsrp'],
          '#9c27b0',        // < -118
          -118, '#f44336',  // -118 to -115
          -115, '#ff9800',  // -115 to -110
          -110, '#ffeb3b',  // -110 to -105
          -105, '#80deea',  // -105 to -95
          -95, '#2196f3',   // -95 to -85
          -85, '#4caf50'    // >= -85
        ],
        'fill-opacity': 0.7
      }
    } as any, beforeLayerId)

    // Add outline layer
    map.addLayer({
      id: outlineLayerId,
      type: 'line',
      source: sourceId,
      paint: {
        'line-color': '#ffffff',
        'line-width': 0.5,
        'line-opacity': 0.7
      }
    } as any, beforeLayerId)

    // Track the layers in overlay ref
    overlayRef.current['iqi'] = {
      sourceIds: [sourceId],
      layerIds: [fillLayerId, outlineLayerId]
    }
  }, [])

  const fetchOptimizationSectors = React.useCallback(async (activeToken: string, bounds: BBoxBounds) => {
    const requestUrl = `https://rhea.web.abc.com/oauth21/api/metadata/sector/list/opto_area/frequency/${formatCoord(bounds.minLng)}/${formatCoord(bounds.minLat)}/${formatCoord(bounds.maxLng)}/${formatCoord(bounds.maxLat)}/`

    setOptimizationStatus('loading')
    setOptimizationError(null)
    setLastOptimizationUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Optimization request failed with status ${response.status}`)
      }

      const body = await response.json()
      if (Array.isArray(body)) {
        setOptimizationSectors(body)
        setOptimizationStatus('success')
        if (body.length > 0) {
          setSelectedOptimizationSector(body[0])
        }
      } else {
        throw new Error('Expected array response from optimization API')
      }
    } catch (error) {
      console.error('Failed to load optimization sectors', error)
      setOptimizationSectors([])
      setOptimizationStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching optimization endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationError(message)
    }
  }, [])

  const runOptimizationFetch = React.useCallback(async () => {
    const token = authTokenRef.current
    const bounds = optimizationBoundsRef.current
    if (!token) {
      setOptimizationError('Missing token')
      return
    }
    if (!bounds) {
      setOptimizationError('Draw a bounding box first')
      return
    }
    await fetchOptimizationSectors(token, bounds)
  }, [fetchOptimizationSectors])

  const submitOptimizationJob = React.useCallback(async () => {
    const token = authTokenRef.current
    const bounds = optimizationBoundsRef.current
    const sector = selectedOptimizationSector

    if (!token) {
      setOptimizationJobError('Missing authentication token')
      return
    }
    if (!bounds) {
      setOptimizationJobError('Missing bounding box')
      return
    }
    if (!sector) {
      setOptimizationJobError('Please select a sector')
      return
    }
    if (!sessionId || !jobId) {
      setOptimizationJobError('Session/Job IDs not generated')
      return
    }

    const requestUrl = `https://rhea.web.abc.com/oauth21/api/rhea/bbox/optimize/${encodeURIComponent(sessionId)}/?output=json&job_id=${encodeURIComponent(jobId)}`

    setOptimizationJobStatus('submitting')
    setOptimizationJobError(null)
    setStatusMessage('Submitting optimization job...')
    setStatusDetails(null)
    setSubmissionResponse(null)
    setLastSubmissionUrl(requestUrl)
    setPollingCount(0)
    console.log('[Optimization] Submitting job to:', requestUrl)

    try {
      const basePayload = {
        min_latitude: bounds.minLat,
        min_longitude: bounds.minLng,
        max_latitude: bounds.maxLat,
        max_longitude: bounds.maxLng,
        frequencies: [sector],
        technologies: [selectedNetworkType]
      }

      // Add hyperparameters only if they've been modified from defaults
      const payload = hasHyperparametersChanged()
        ? { ...basePayload, ...hyperparameters }
        : basePayload

      console.log('[Optimization] Request payload:', JSON.stringify(payload, null, 2))

      const response = await fetch(requestUrl, {
        method: 'POST',
        cache: 'no-store',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(payload)
      })

      console.log('[Optimization] Response status:', response.status, response.statusText)

      let body: any = null
      let bodyText = ''
      try {
        bodyText = await response.text()
        console.log('[Optimization] Response body (raw):', bodyText)
        if (bodyText) {
          body = JSON.parse(bodyText)
          console.log('[Optimization] Response body (parsed):', body)
        }
      } catch (parseError) {
        console.error('[Optimization] Failed to parse response:', parseError)
        body = { raw: bodyText }
      }

      setSubmissionResponse(body)

      if (!response.ok) {
        const errorMsg = body?.message || body?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(`Job submission failed: ${errorMsg}`)
      }

      console.log('[Optimization] Checking for results in response...')
      console.log('[Optimization] Has results property?', !!body?.results)
      console.log('[Optimization] Response keys:', Object.keys(body || {}))
      
      // Check if response contains complete results data (with histograms, scores, etc.)
      // If results exist, we can display them immediately without polling
      const hasCompleteResults = body?.results?.histograms && body?.results?.total_scores
      
      if (hasCompleteResults) {
        console.log('[Optimization] ✓ Complete results found in submission response - NO POLLING NEEDED')
        setOptimizationResults(body)
        setStatusMessage(`Job completed successfully with results`)
        setOptimizationJobStatus('completed')
        // Don't start polling since we already have complete results
      } else {
        console.log('[Optimization] ✗ No complete results in submission response - starting status polling')
        console.log('[Optimization] Will poll status endpoint until status is TRACE_ENDING or OK')
        setStatusMessage(`Job submitted. Polling for completion status...`)
        setOptimizationJobStatus('polling')
        
        // Start polling for status after a short delay
        setTimeout(() => {
          void pollOptimizationStatus()
        }, STATUS_POLL_INTERVAL_MS)
      }
    } catch (error) {
      console.error('[Optimization] Failed to submit job:', error)
      setOptimizationJobStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching optimization endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationJobError(message)
      setStatusMessage('Job submission failed')
    }
  }, [sessionId, jobId, selectedOptimizationSector])

  const pollOptimizationStatus = React.useCallback(async () => {
    const token = authTokenRef.current

    if (!token || !sessionId || !jobId) {
      console.log('[Optimization] Polling aborted: missing token or IDs')
      return
    }

    const statusUrl = `https://rhea.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(sessionId)}/${encodeURIComponent(jobId)}/status.json`
    setLastStatusUrl(statusUrl)

    const currentCount = pollingCount + 1
    setPollingCount(currentCount)
    console.log(`[Optimization] Polling abcempt #${currentCount}:`, statusUrl)

    try {
      const response = await fetch(statusUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        }
      })

      console.log(`[Optimization] Status response #${currentCount}:`, response.status, response.statusText)

      let body: any = null
      let bodyText = ''
      try {
        bodyText = await response.text()
        console.log(`[Optimization] Status body #${currentCount} (raw):`, bodyText)
        if (bodyText) {
          body = JSON.parse(bodyText)
          console.log(`[Optimization] Status body #${currentCount} (parsed):`, body)
        }
      } catch (parseError) {
        console.error('[Optimization] Failed to parse status response:', parseError)
        body = { raw: bodyText, parseError: String(parseError) }
      }

      if (!response.ok) {
        const errorMsg = body?.message || body?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(`Status polling failed: ${errorMsg}`)
      }

      setStatusDetails(body)
      setOptimizationJobError(null)
      
      if (body?.message) {
        setStatusMessage(`[Poll #${currentCount}] ${body.message}`)
      } else {
        setStatusMessage(`[Poll #${currentCount}] Status: ${body?.status || 'unknown'}`)
      }

      // Check if job is complete - looking for status: "TRACE_ENDING" or "OK"
      const isComplete = body?.status === 'TRACE_ENDING' || body?.status === 'OK'
      const isFailed = body?.status === 'FAILED' || body?.status === 'ERROR'
      
      if (isComplete || isFailed) {
        console.log('[Optimization] Job reached terminal state:', body.status)
        setOptimizationJobStatus('completed')
        
        if (pollingTimerRef.current) {
          window.clearTimeout(pollingTimerRef.current)
          pollingTimerRef.current = null
        }
        
        if (isComplete) {
          console.log('[Optimization] ✓ Job completed successfully (status: ' + body.status + ')')
          setStatusMessage(`Job completed: ${body.message || 'Ready to view results'}`)
          
          // Check if we already have results in submission response
          if (submissionResponse?.results) {
            console.log('[Optimization] Using results from submission response')
            setOptimizationResults(submissionResponse)
          } else {
            console.log('[Optimization] Fetching results from data.json endpoint...')
            setTimeout(() => {
              void fetchOptimizationResults()
            }, 500)
          }
        } else {
          console.log('[Optimization] ✗ Job failed with status:', body.status)
          setStatusMessage(`Job ${body.status.toLowerCase()}: ${body.message || 'No message'}`)
        }
      } else {
        // Continue polling every 3 seconds
        console.log(`[Optimization] Job status: ${body?.status || 'unknown'}, continuing to poll...`)
        if (pollingTimerRef.current) {
          window.clearTimeout(pollingTimerRef.current)
        }
        pollingTimerRef.current = window.setTimeout(() => {
          void pollOptimizationStatus()
        }, STATUS_POLL_INTERVAL_MS)
      }
    } catch (error) {
      console.error(`[Optimization] Polling error #${currentCount}:`, error)
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching status endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationJobError(message)
      setOptimizationJobStatus('error')
      setStatusMessage(`[Poll #${currentCount}] Error: ${message}`)

      // Stop polling on error and surface status message
      if (pollingTimerRef.current) {
        window.clearTimeout(pollingTimerRef.current)
        pollingTimerRef.current = null
      }
    }
  }, [sessionId, jobId, pollingCount])

  // Cleanup polling timer on unmount
  React.useEffect(() => {
    return () => {
      if (pollingTimerRef.current) {
        window.clearTimeout(pollingTimerRef.current)
        pollingTimerRef.current = null
      }
    }
  }, [])

  const fetchOptimizationLayer = React.useCallback(async (activeToken: string, layerType: OptimizationLayerType) => {
    if (layerType === 'none') {
      clearOverlay('optimization-layer')
      setOptimizationLayerData(null)
      setOptimizationLayerStatus('idle')
      setOptimizationLayerError(null)
      return
    }

    // Get session/job IDs from active result instead of component state
    let activeSessionId = sessionId
    let activeJobId = jobId

    if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
      const activeResult = optimizationResultsArray[activeResultIndex]
      activeSessionId = activeResult.sessionId
      activeJobId = activeResult.jobId
    }

    if (!activeSessionId || !activeJobId) {
      setOptimizationLayerError('Session ID and Job ID are required')
      return
    }

    const layerPathMap: Record<string, string> = {
      bin_state_pre: `bin_state/pre_data`,
      bin_state_post: `bin_state/post_data`,
      bin_state_diff: `bin_state/diff_data`,
      sinr_pre: `sinr/pre_data`,
      sinr_post: `sinr/post_data`,
      sinr_floor: `sinr/floor_data`,
      sinr_delta: `sinr/delta_data`,
      sector_id_pre: `sector_id/pre_data`,
      sector_id_post: `sector_id/post_data`,
      sector_id_diff: `sector_id/diff_data`,
      rsrp_pre: `rsrp_dbm/pre_data`,
      rsrp_post: `rsrp_dbm/post_data`,
      rsrp_diff: `rsrp_dbm/diff_data`,
      user_density: `user_density/any`
    }

    const layerPath = layerPathMap[layerType]
    if (!layerPath) {
      setOptimizationLayerError(`Unknown layer type: ${layerType}`)
      return
    }

    const requestUrl = `https://rhea.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(activeSessionId)}/${encodeURIComponent(activeJobId)}/${layerPath}/style.json`

    setOptimizationLayerStatus('loading')
    setOptimizationLayerError(null)

    try {
      const response = await fetch(requestUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Layer request failed with status ${response.status}`)
      }

      const body = await response.json()

      // Store data per result if we have an active result
      if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
        const resultId = optimizationResultsArray[activeResultIndex].id
        resultLayerDataRef.current[resultId] = body
        resultLayerStatusRef.current[resultId] = 'success'

        // Apply overlay with result-specific key
        applyOverlayStyle(`optimization-layer-${resultId}`, body)
      }

      // Also update global state for backward compatibility
      setOptimizationLayerData(body)
      setOptimizationLayerStatus('success')
    } catch (error) {
      console.error('Failed to load optimization layer', error)

      // Update per-result status if we have an active result
      if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
        const resultId = optimizationResultsArray[activeResultIndex].id
        resultLayerStatusRef.current[resultId] = 'error'
      }

      setOptimizationLayerData(null)
      setOptimizationLayerStatus('error')
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching layer endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setOptimizationLayerError(message)
    }
  }, [sessionId, jobId, activeResultIndex, optimizationResultsArray, clearOverlay, applyOverlayStyle])

  const fetchOptimizationResults = React.useCallback(async () => {
    const token = authTokenRef.current

    if (!token || !sessionId || !jobId) {
      console.log('[Optimization] Cannot fetch results: missing token or IDs')
      return
    }

    const resultsUrl = `https://rhea.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(sessionId)}/${encodeURIComponent(jobId)}/data.json`
    console.log('[Optimization] Fetching results from:', resultsUrl)
    setResultsError(null)

    try {
      const response = await fetch(resultsUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        }
      })

      console.log('[Optimization] Results response:', response.status, response.statusText)

      let body: any = null
      let bodyText = ''
      try {
        bodyText = await response.text()
        console.log('[Optimization] Results body (raw, first 500 chars):', bodyText.substring(0, 500))
        if (bodyText) {
          body = JSON.parse(bodyText)
          console.log('[Optimization] Results parsed successfully')
        }
      } catch (parseError) {
        console.error('[Optimization] Failed to parse results:', parseError)
        throw new Error('Failed to parse results JSON')
      }

      if (!response.ok) {
        const errorMsg = body?.message || body?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(`Results fetch failed: ${errorMsg}`)
      }

      // Dual-write: Keep old state for backward compatibility
      setOptimizationResults(body)
      setShowResultsView(true)

      // New: Add to results array
      const bounds: BBoxBounds = optimizationBoundsRef.current || { minLng: 0, minLat: 0, maxLng: 0, maxLat: 0 }
      const colorIndex = optimizationResultsArray.length % RESULT_COLORS.length
      const color = RESULT_COLORS[colorIndex]

      const newResult: OptimizationResult = {
        id: generateUniqueId(),
        sessionId,
        jobId,
        bounds,
        data: body,
        timestamp: Date.now(),
        label: `Submitted: ${new Date().toLocaleString()}`,
        color,
        source: 'submitted'
      }

      setOptimizationResultsArray((prev: OptimizationResult[]) => [...prev, newResult])
      setActiveResultIndex(optimizationResultsArray.length)
      setShowResultsPanel(true)

      console.log('[Optimization] Results loaded successfully, added to array:', newResult.id)
    } catch (error) {
      console.error('[Optimization] Failed to fetch results:', error)
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching results endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setResultsError(message)
    }
  }, [sessionId, jobId])

  const recallOptimizationResult = React.useCallback(async (recallSessionId: string, recallJobId: string) => {
    const token = authTokenRef.current

    if (!token) {
      setRecallForm((prev: RecallFormState) => ({ ...prev, error: 'No authentication token available', loading: false }))
      return
    }

    const trimmedSessionId = recallSessionId.trim()
    const trimmedJobId = recallJobId.trim()

    if (!trimmedSessionId || !trimmedJobId) {
      setRecallForm((prev: RecallFormState) => ({ ...prev, error: 'Session ID and Job ID are required', loading: false }))
      return
    }

    setRecallForm((prev: RecallFormState) => ({ ...prev, loading: true, error: null }))

    const resultsUrl = `https://rhea.web.abc.com/oauth21/api/optimization/tile/${encodeURIComponent(trimmedSessionId)}/${encodeURIComponent(trimmedJobId)}/data.json`
    console.log('[Recall] Fetching results from:', resultsUrl)

    try {
      const response = await fetch(resultsUrl, {
        method: 'GET',
        cache: 'no-store',
        headers: {
          Accept: 'application/json',
          Authorization: `Bearer ${token}`
        }
      })

      console.log('[Recall] Response:', response.status, response.statusText)

      if (!response.ok) {
        let body: any = {}
        try {
          const bodyText = await response.text()
          body = JSON.parse(bodyText)
        } catch {
          // Ignore parse errors
        }
        const errorMsg = body?.message || body?.error || `HTTP ${response.status}: ${response.statusText}`
        throw new Error(`Failed to recall results: ${errorMsg}`)
      }

      const data = await response.json()
      console.log('[Recall] Results loaded successfully')

      // Extract bounding box from results data if available, otherwise use placeholder
      const bounds: BBoxBounds = extractBoundsFromResults(data) || {
        minLng: 0,
        minLat: 0,
        maxLng: 0,
        maxLat: 0
      }

      // Assign color from palette based on current array length
      const colorIndex = optimizationResultsArray.length % RESULT_COLORS.length
      const color = RESULT_COLORS[colorIndex]

      const newResult: OptimizationResult = {
        id: generateUniqueId(),
        sessionId: trimmedSessionId,
        jobId: trimmedJobId,
        bounds,
        data,
        timestamp: Date.now(),
        label: `Recalled: ${new Date().toLocaleString()}`,
        color,
        source: 'recalled'
      }

      // Add to results array and set as active
      setOptimizationResultsArray((prev: OptimizationResult[]) => [...prev, newResult])
      setActiveResultIndex(optimizationResultsArray.length)
      setShowResultsPanel(true)

      // Clear and hide recall form
      setRecallForm({ sessionId: '', jobId: '', error: null, loading: false })
      setRecallFormVisible(false)

      console.log('[Recall] Result added to array:', newResult.id)
    } catch (error) {
      console.error('[Recall] Failed to fetch results:', error)
      const message = error instanceof TypeError
        ? 'Network or CORS error reaching results endpoint'
        : error instanceof Error
          ? error.message
          : 'Unknown error'
      setRecallForm((prev: RecallFormState) => ({ ...prev, error: message, loading: false }))
    }
  }, [optimizationResultsArray])

  const fetchVisualizationStyle = React.useCallback(async (activeToken: string) => {
    const requestUrl = DEFAULT_VISUALIZATION_STYLE_URL
    setVisualizationStatus('loading')
    setVisualizationError(null)
    setLastVisualizationUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Visualization style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setVisualizationData(body)
      setVisualizationStatus('success')
    } catch (error) {
      console.error('Failed to load visualization style', error)
      setVisualizationData(null)
      setVisualizationStatus('error')
      setVisualizationError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const fetchMetadataSectorStyle = React.useCallback(async (activeToken: string) => {
    const requestUrl = DEFAULT_METADATA_SECTOR_STYLE_URL
    setMetadataStyleStatus('loading')
    setMetadataStyleError(null)
    setLastMetadataStyleUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Metadata sector style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setMetadataStyleData(body)
      setMetadataStyleStatus('success')
    } catch (error) {
      console.error('Failed to load metadata sector style', error)
      setMetadataStyleData(null)
      setMetadataStyleStatus('error')
      setMetadataStyleError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const fetchCoverageStyle = React.useCallback(async (activeToken: string, layer: CoverageLayer) => {
    const requestUrl = DEFAULT_COVERAGE_STYLE_URL.replace('{coverage_layer}', encodeURIComponent(layer))
    setCoverageStyleStatus('loading')
    setCoverageStyleError(null)
    setLastCoverageStyleUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Coverage style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setCoverageStyleData(body)
      setCoverageStyleStatus('success')
    } catch (error) {
      console.error('Failed to load coverage style', error)
      setCoverageStyleData(null)
      setCoverageStyleStatus('error')
      setCoverageStyleError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const fetchSectorStyle = React.useCallback(async (activeToken: string, sectorName: string) => {
    const requestUrl = DEFAULT_SECTOR_ENDPOINT.replace('{sector_name}', encodeURIComponent(sectorName))
    setSectorStyleStatus('loading')
    setSectorStyleError(null)
    setLastSectorStyleUrl(requestUrl)

    try {
      const response = await fetch(requestUrl, {
        headers: {
          Authorization: `Bearer ${activeToken}`
        }
      })

      if (!response.ok) {
        throw new Error(`Sector style request failed with status ${response.status}`)
      }

      const body = await response.json()
      setSectorStyleData(body)
      setSectorStyleStatus('success')
    } catch (error) {
      console.error('Failed to load sector style', error)
      setSectorStyleData(null)
      setSectorStyleStatus('error')
      setSectorStyleError(error instanceof Error ? error.message : 'Unknown error')
    }
  }, [])

  const clearSectorView = React.useCallback(() => {
    setClickedSectorData(null)
    setSectorStyleData(null)
    setSectorStyleStatus('idle')
    setSectorStyleError(null)
    setLastSectorStyleUrl(null)
    if (mapRef.current && mapReady) {
      clearOverlay('clicked-sector')
    }
  }, [mapReady, clearOverlay])

  React.useEffect(() => {
    // When user switches the coverageLayer option, clear the old overlay/state.
    setCoverageStyleData(null)
    setCoverageStyleStatus('idle')
    setCoverageStyleError(null)
    setLastCoverageStyleUrl(null)
    coverageOriginalOpacityRef.current = {}
    if (mapReady) {
      clearOverlay('coverage')
    }
  }, [coverageLayer, mapReady, clearOverlay])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !optimizationLayerData) {
      return
    }

    try {
      applyOverlayStyle('optimization-layer', optimizationLayerData)
      
      // Robustly hide coverage layer when optimization layer is applied
      if (optimizationLayerType !== 'none') {
        setCoverageVisible(false)
        
        // Force immediate hiding of coverage layers
        const overlay = overlayRef.current['coverage']
        if (overlay?.layerIds?.length) {
          const map = mapRef.current
          overlay.layerIds.forEach((layerId: string) => {
            if (map.getLayer(layerId)) {
              map.setLayoutProperty(layerId, 'visibility', 'none')
              // Also set opacity to 0 as additional safeguard
              const layer: any = map.getLayer(layerId)
              if (layer) {
                const layerType = layer.type
                if (layerType === 'fill') {
                  map.setPaintProperty(layerId, 'fill-opacity', 0)
                } else if (layerType === 'line') {
                  map.setPaintProperty(layerId, 'line-opacity', 0)
                } else if (layerType === 'circle') {
                  map.setPaintProperty(layerId, 'circle-opacity', 0)
                } else if (layerType === 'heatmap') {
                  map.setPaintProperty(layerId, 'heatmap-opacity', 0)
                } else if (layerType === 'symbol') {
                  map.setPaintProperty(layerId, 'text-opacity', 0)
                  map.setPaintProperty(layerId, 'icon-opacity', 0)
                }
              }
            }
          })
        }
      }
    } catch (error) {
      console.error('Failed to apply optimization layer', error)
      setOptimizationLayerStatus('error')
      setOptimizationLayerError(error instanceof Error ? error.message : 'Failed to apply optimization layer')
    }
  }, [mapReady, optimizationLayerData, optimizationLayerType, applyOverlayStyle])

  React.useEffect(() => {
    const handler = (event: Event) => {
      const detail = (event as CustomEvent)?.detail as { sectorName?: string }
      if (typeof detail?.sectorName === 'string' && detail.sectorName.trim().length > 0) {
        setSectorName(detail.sectorName.trim())
      }
    }

    window.addEventListener('map-widget:set-sector', handler as EventListener)
    return () => window.removeEventListener('map-widget:set-sector', handler as EventListener)
  }, [])

  React.useEffect(() => {
    const win = window as Window & { mapWidgetSetSector?: (sector: string) => void }
    win.mapWidgetSetSector = (sector: string) => {
      if (typeof sector === 'string' && sector.trim().length > 0) {
        setSectorName(sector.trim())
      }
    }
    return () => {
      if (win.mapWidgetSetSector) {
        delete win.mapWidgetSetSector
      }
    }
  }, [])

  React.useEffect(() => {
    void refreshToken()

    return () => {
      if (tokenRefreshTimerRef.current) {
        window.clearTimeout(tokenRefreshTimerRef.current)
      }
    }
  }, [refreshToken])

  React.useEffect(() => {
    if (!authState.accessToken) {
      return
    }

    if (isApiEnabled('viz')) {
      void fetchVisualizationStyle(authState.accessToken)
    }

    if (isApiEnabled('meta')) {
      void fetchMetadataSectorStyle(authState.accessToken)
    }

    if (isApiEnabled('coverage')) {
      void fetchCoverageStyle(authState.accessToken, coverageLayer)
    }
  }, [authState.accessToken, coverageLayer, fetchVisualizationStyle, fetchMetadataSectorStyle, fetchCoverageStyle, isApiEnabled])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !coverageStyleData) {
      return
    }

    if (!isApiEnabled('coverage')) {
      clearOverlay('coverage')
      return
    }

    try {
      applyOverlayStyle('coverage', coverageStyleData)
      
      // If coverage is not visible, immediately hide all layers
      if (!coverageVisible && mapRef.current) {
        const overlay = overlayRef.current['coverage']
        if (overlay?.layerIds?.length) {
          const map = mapRef.current
          overlay.layerIds.forEach((layerId: string) => {
            if (map.getLayer(layerId)) {
              map.setLayoutProperty(layerId, 'visibility', 'none')
            }
          })
        }
      }
    } catch (error) {
      console.error('Failed to apply coverage style', error)
      setCoverageStyleStatus('error')
      setCoverageStyleError(error instanceof Error ? error.message : 'Failed to apply coverage style')
    }
  }, [mapReady, coverageStyleData, applyOverlayStyle, clearOverlay, isApiEnabled, coverageVisible])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    if (!isApiEnabled('coverage')) {
      return
    }

    const overlay = overlayRef.current['coverage']
    if (!overlay?.layerIds?.length) {
      return
    }

    const map = mapRef.current
    const opacityMultiplier = coverageVisible ? coverageOpacity / 50 : 0

    overlay.layerIds.forEach((layerId: string) => {
      const layer: any = map.getLayer(layerId)
      if (!layer) {
        return
      }

      // Apply opacity to all coverage layers by multiplying original opacity with slider value
      const layerType = layer.type
      if (layerType === 'fill') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'fill-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'line') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'line-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'circle') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'circle-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'heatmap') {
        const originalOpacity = coverageOriginalOpacityRef.current[layerId] ?? 1
        map.setPaintProperty(layerId, 'heatmap-opacity', originalOpacity * opacityMultiplier)
      } else if (layerType === 'symbol') {
        const originalTextOpacity = coverageOriginalOpacityRef.current[`${layerId}-text`] ?? 1
        const originalIconOpacity = coverageOriginalOpacityRef.current[`${layerId}-icon`] ?? 1
        map.setPaintProperty(layerId, 'text-opacity', originalTextOpacity * opacityMultiplier)
        map.setPaintProperty(layerId, 'icon-opacity', originalIconOpacity * opacityMultiplier)
      }

      // Handle visibility based on coverageVisible flag
      if (!coverageVisible) {
        map.setLayoutProperty(layerId, 'visibility', 'none')
        return
      }

      // Match website behavior:
      // - Show bins ON  => show dots, hide blended/heatmap layers
      // - Show bins OFF => hide dots, show blended/heatmap layers
      if (looksLikeBinLayer(layer)) {
        // If this style has *only* bin layers, don't hide them (otherwise we'd blank the overlay).
        const shouldHideBins = !coverageShowBins && coverageStyleLayerSummary.nonBinCount > 0
        map.setLayoutProperty(layerId, 'visibility', shouldHideBins ? 'none' : 'visible')
        return
      }

      if (looksLikeAggregatedLayer(layer)) {
        map.setLayoutProperty(layerId, 'visibility', coverageShowBins ? 'none' : 'visible')
      } else {
        map.setLayoutProperty(layerId, 'visibility', 'visible')
      }
    })
  }, [mapReady, coverageShowBins, coverageOpacity, coverageVisible, coverageStyleData, coverageStyleLayerSummary.nonBinCount, isApiEnabled])

  // ─── IQI LAYER EFFECTS ─────────────────────────────────────────────────────────

  // Handle IQI visibility toggle
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    if (iqiVisible) {
      // Fetch IQI data when toggled on
      void fetchIqiData()
    } else {
      // Clear IQI overlay when toggled off
      clearOverlay('iqi')
      setIqiStatus('idle')
      setIqiFeatureCount(0)
      setIqiError(null)
      
      // Abort any in-flight fetches
      if (iqiFetchControllerRef.current) {
        iqiFetchControllerRef.current.abort()
        iqiFetchControllerRef.current = null
      }
    }
  }, [mapReady, iqiVisible, fetchIqiData, clearOverlay])

  // Handle IQI opacity changes
  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !iqiVisible) {
      return
    }

    const overlay = overlayRef.current['iqi']
    if (!overlay?.layerIds?.length) {
      return
    }

    const map = mapRef.current
    const opacityValue = iqiOpacity / 100

    overlay.layerIds.forEach((layerId: string) => {
      const layer: any = map.getLayer(layerId)
      if (!layer) {
        return
      }

      if (layer.type === 'fill') {
        map.setPaintProperty(layerId, 'fill-opacity', opacityValue)
      } else if (layer.type === 'line') {
        map.setPaintProperty(layerId, 'line-opacity', opacityValue)
      }
    })
  }, [mapReady, iqiOpacity, iqiVisible])

  // Handle map move/zoom for dynamic IQI loading
  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !iqiVisible) {
      return
    }

    const map = mapRef.current
    let debounceTimer: number | null = null

    const handleMapChange = () => {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer)
      }
      debounceTimer = window.setTimeout(() => {
        void fetchIqiData()
      }, 500)
    }

    map.on('moveend', handleMapChange)
    map.on('zoomend', handleMapChange)

    return () => {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer)
      }
      map.off('moveend', handleMapChange)
      map.off('zoomend', handleMapChange)
    }
  }, [mapReady, iqiVisible, fetchIqiData])

  // Cleanup IQI token refresh timer on unmount
  React.useEffect(() => {
    return () => {
      if (iqiTokenRefreshTimerRef.current) {
        window.clearTimeout(iqiTokenRefreshTimerRef.current)
        iqiTokenRefreshTimerRef.current = null
      }
      if (iqiFetchControllerRef.current) {
        iqiFetchControllerRef.current.abort()
        iqiFetchControllerRef.current = null
      }
    }
  }, [])

  // ─── END IQI LAYER EFFECTS ─────────────────────────────────────────────────────

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !visualizationData) {
      return
    }

    if (!isApiEnabled('viz')) {
      clearOverlay('viz')
      return
    }

    try {
      applyOverlayStyle('viz', visualizationData)
    } catch (error) {
      console.error('Failed to apply visualization style', error)
      setVisualizationStatus('error')
      setVisualizationError(error instanceof Error ? error.message : 'Failed to apply visualization style')
    }
  }, [mapReady, visualizationData, applyOverlayStyle, clearOverlay, isApiEnabled])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !metadataStyleData) {
      return
    }

    if (!isApiEnabled('meta')) {
      clearOverlay('meta')
      return
    }

    try {
      applyOverlayStyle('meta', metadataStyleData)
      console.log('[3D Sectors] Metadata layer loaded, triggering 3D scene update')
      
      // Trigger 3D sectors to update after metadata layer is added
      setTimeout(() => {
        if (mapRef.current && show3DSectors) {
          const updated = threeDSceneRef.current.updateAfterMove()
          if (updated) {
            console.log('[3D Sectors] Scene updated after metadata load')
            mapRef.current.triggerRepaint()
          }
        }
      }, 500)
    } catch (error) {
      console.error('Failed to apply metadata sector style', error)
      setMetadataStyleStatus('error')
      setMetadataStyleError(error instanceof Error ? error.message : 'Failed to apply metadata sector style')
    }
  }, [mapReady, metadataStyleData, applyOverlayStyle, clearOverlay, isApiEnabled, show3DSectors])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current || !sectorStyleData) {
      return
    }

    try {
      // Hide coverage layer when showing sector view
      if (coverageStyleData) {
        clearOverlay('coverage')
      }
      
      applyOverlayStyle('clicked-sector', sectorStyleData)
    } catch (error) {
      console.error('Failed to apply sector style', error)
      setSectorStyleStatus('error')
      setSectorStyleError(error instanceof Error ? error.message : 'Failed to apply sector style')
    }
  }, [mapReady, sectorStyleData, applyOverlayStyle, coverageStyleData, clearOverlay])

  React.useEffect(() => {
    // Re-show coverage layer when sector view is cleared
    if (!clickedSectorData && !sectorStyleData && coverageStyleData && mapReady && mapRef.current) {
      try {
        applyOverlayStyle('coverage', coverageStyleData)
        
        // If coverage is not visible, immediately hide all layers
        if (!coverageVisible && mapRef.current) {
          const overlay = overlayRef.current['coverage']
          if (overlay?.layerIds?.length) {
            const map = mapRef.current
            overlay.layerIds.forEach((layerId: string) => {
              if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', 'none')
              }
            })
          }
        }
      } catch (error) {
        console.error('Failed to re-apply coverage style', error)
      }
    }
  }, [clickedSectorData, sectorStyleData, coverageStyleData, mapReady, applyOverlayStyle, coverageVisible])

  // Define sector color theme
  const getSectorColor = React.useCallback((data: SectorData): number => {
    // Color by band - using softer, more muted tones
    const bandColors: Record<string, number> = {
      // 700 MHz bands - Soft Coral
      '700': 0xcc7a7a,
      '700_B14': 0xcc7a7a,
      'LTE700': 0xcc7a7a,
      
      // 850 MHz band - Soft Orange
      '850': 0xcc9966,
      'LTE850': 0xcc9966,
      
      // 1900 MHz / PCS band - Soft Green
      'PCS': 0x7fbc7f,
      '1900': 0x7fbc7f,
      'LTE1900': 0x7fbc7f,
      
      // 2100 MHz / AWS band - Soft Teal
      'AWS': 0x70b8b8,
      'AWS-1': 0x70b8b8,
      '2100': 0x70b8b8,
      'LTE2100': 0x70b8b8,
      
      // 2300 MHz / WCS band - Soft Blue
      'WCS': 0x7a9fd9,
      '2300': 0x7a9fd9,
      'LTE2300': 0x7a9fd9,
      
      // 2500 MHz band - Soft Lavender
      '2500': 0xbf8fbf,
      'LTE2500': 0xbf8fbf,
      
      // 3500 MHz / n77/n78 5G band - Soft Yellow
      '3500': 0xcccc7a,
      'NR3500': 0xcccc7a,
      'n77': 0xcccc7a,
      'n78': 0xcccc7a,
      
      // mmWave / 28 GHz - Soft Pink
      '28000': 0xd98fad,
      'NR28000': 0xd98fad,
      'n261': 0xd98fad
    }
    const color = bandColors[data.band] ?? 0xcccccc
    return color
  }, [])

  React.useEffect(() => {
    if (!mapRef.current) {
      return
    }

    const handleError = (event: any) => {
      const message = event?.error?.message || 'Map error'
      console.error('MapLibre error event', event)
      setLastMapError(message)
    }

    mapRef.current.on('error', handleError)
    return () => {
      mapRef.current?.off('error', handleError)
    }
  }, [mapReady])

  React.useEffect(() => {
    if (!mapContainerRef.current) {
      return
    }

    const mapOptions: maplibregl.MapOptions & { antialias?: boolean } = {
      container: mapContainerRef.current,
      style: styleUrl,
      center: DEFAULT_CENTER,
      zoom: DEFAULT_ZOOM,
      bearing: DEFAULT_BEARING,
      pitch: DEFAULT_PITCH,
      antialias: true,
      pixelRatio,
      transformRequest: (url: string) => {
        const token = authTokenRef.current
        if (!token) {
          return { url }
        }

        try {
          const parsed = new URL(url, window.location.origin)
          const host = parsed.hostname.toLowerCase()
          const isRheaHost =
            host === 'rhea.web.abc.com' || host.endsWith('.rhea.web.abc.com') ||
            host === 'rhea.research.abc.com' || host.endsWith('.rhea.research.abc.com')
          if (isRheaHost) {
            return {
              url,
              headers: {
                Authorization: `Bearer ${token}`
              }
            }
          }
        } catch (_ignored) {
          // fall through to default
        }

        return { url }
      }
    }

    const map = new maplibregl.Map(mapOptions)

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right')
    mapRef.current = map

    const handleLoad = () => {
      // Add 3D Sectors custom layer
      if (!map.getLayer('three-d-sectors-layer')) {
        console.log('[3D Sectors] Adding 3D sectors custom layer')
        map.addLayer({
          id: 'three-d-sectors-layer',
          type: 'custom',
          renderingMode: '3d',
          onAdd: function (_map: MapLibreMap, gl: WebGLRenderingContext | WebGL2RenderingContext) {
            console.log('[3D Sectors] Initializing 3D scene')
            threeDSceneRef.current.initialize(_map, gl)
            threeDSceneRef.current.setLayerProps(ThreeD.LayerType.Sectors, {
              getSectorColor: getSectorColor,
              visible: show3DSectors,
              scale: sectorScale
            })
            // Initial update - metadata layer may not be loaded yet
            console.log('[3D Sectors] Initial scene update (metadata layer may not be ready yet)')
            const updated = threeDSceneRef.current.updateAfterMove()
            if (updated) {
              console.log('[3D Sectors] Initial update successful')
              _map.triggerRepaint()
            } else {
              console.log('[3D Sectors] Waiting for metadata layer to load...')
            }
          },
          render: function (_gl: WebGLRenderingContext | WebGL2RenderingContext, args: any) {
            threeDSceneRef.current.render(args as CustomRenderMethodInput)
          }
        } as any)
      }
      
      setMapReady(true)
    }
    
    const handleMouseMove = (e: maplibregl.MapLayerMouseEvent) => {
      const hoverStateChange = threeDSceneRef.current.hoverAtPoint(e.point)
      if (hoverStateChange.changed()) {
        const canvas = map.getCanvas()
        if (hoverStateChange.selected()) {
          canvas.style.cursor = 'pointer'
        } else if (hoverStateChange.deselected()) {
          canvas.style.cursor = ''
        }
        map.triggerRepaint()
      }
    }
    
    const handleClick = (e: maplibregl.MapLayerMouseEvent) => {
      const selectionStateChange = threeDSceneRef.current.selectAtPoint(e.point)
      if (selectionStateChange.changed()) {
        if (selectionStateChange.after?.mesh?.userData) {
          const sectorData = selectionStateChange.after.mesh.userData as SectorData
          console.log('Selected sector:', sectorData.sector_name, sectorData)
          setClickedSectorData(sectorData)
          
          // Fetch sector coverage layer
          const token = authTokenRef.current
          if (token && sectorData.sector_name) {
            void fetchSectorStyle(token, sectorData.sector_name)
          }
        }
        map.triggerRepaint()
      }
    }
    
    const handleMoveEnd = () => {
      let updateFromTerrain = false
      if (terrainChangedRef.current) {
        terrainChangedRef.current = false
        updateFromTerrain = threeDSceneRef.current.updateAfterTerrainChange()
      }
      
      const currentZoom = map.getZoom()
      const minZoom = threeDSceneRef.current.minZoom
      console.log(`[3D Sectors] Zoom: ${currentZoom.toFixed(1)} (min required: ${minZoom})`)
      
      const updated = threeDSceneRef.current.updateAfterMove()
      if (updated || updateFromTerrain) {
        console.log('[3D Sectors] Scene updated after map move')
        map.triggerRepaint()
      } else if (currentZoom < minZoom) {
        console.log(`[3D Sectors] Zoom too low for 3D sectors (need ${minZoom}+)`)
      }
    }
    
    const handleIdle = () => {
      let updated = false
      if (terrainChangedRef.current) {
        terrainChangedRef.current = false
        updated = threeDSceneRef.current.updateAfterTerrainChange()
      }
      
      if (updated) {
        map.triggerRepaint()
      }
    }
    
    map.on('load', handleLoad)
    map.on('mousemove', handleMouseMove)
    map.on('click', handleClick)
    map.on('moveend', handleMoveEnd)
    map.on('idle', handleIdle)

    return () => {
      map.off('load', handleLoad)
      map.off('mousemove', handleMouseMove)
      map.off('click', handleClick)
      map.off('moveend', handleMoveEnd)
      map.off('idle', handleIdle)

      // Clean up any overlay layers/sources we added.
      const overlays = Object.values(overlayRef.current) as Array<{ sourceIds: string[], layerIds: string[] }>
      overlays.forEach((overlay) => {
        overlay.layerIds.forEach((layerId: string) => {
          if (map.getLayer(layerId)) {
            map.removeLayer(layerId)
          }
        })
        overlay.sourceIds.forEach((sourceId: string) => {
          if (map.getSource(sourceId)) {
            map.removeSource(sourceId)
          }
        })
      })
      overlayRef.current = {}

      map.remove()
      mapRef.current = null
      setMapReady(false)
    }
  }, [runtimeConfig?.initialView, styleUrl, pixelRatio])

  // Optimization drawing effect - keeps box visible on map until cleared
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current
    const sourceId = 'map-widget-optimization-draw-src'
    const fillLayerId = 'map-widget-optimization-draw-fill'
    const lineLayerId = 'map-widget-optimization-draw-line'

    // Helper to update the drawn feature
    const setDrawFeature = (bounds: BBoxBounds | null) => {
      const source = map.getSource(sourceId) as any
      if (!source) {
        return
      }

      if (!bounds) {
        source.setData({ type: 'FeatureCollection', features: [] })
        return
      }

      const ring = [
        [bounds.minLng, bounds.minLat],
        [bounds.maxLng, bounds.minLat],
        [bounds.maxLng, bounds.maxLat],
        [bounds.minLng, bounds.maxLat],
        [bounds.minLng, bounds.minLat]
      ]

      source.setData({
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [ring] },
            properties: {}
          }
        ]
      })
    }

    // Ensure source and layers exist
    if (!map.getSource(sourceId)) {
      map.addSource(sourceId, {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      } as any)
    }

    if (!map.getLayer(fillLayerId)) {
      map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: sourceId,
        paint: {
          'fill-color': '#00ff00',
          'fill-opacity': 0
        }
      } as any)
    }

    if (!map.getLayer(lineLayerId)) {
      map.addLayer({
        id: lineLayerId,
        type: 'line',
        source: sourceId,
        paint: {
          'line-color': '#00ff00',
          'line-width': 2
        }
      } as any)
    }

    optimizationDrawRef.current = { sourceId, fillLayerId, lineLayerId }

    // If we have bounds but not drawing, show the static box
    if (!optimizationDrawEnabled && optimizationBounds) {
      setDrawFeature(optimizationBounds)
      map.dragPan.enable()
      if (map.getCanvas()) {
        map.getCanvas().style.cursor = ''
      }
      return
    }

    // If not drawing and no bounds, clear the box
    if (!optimizationDrawEnabled && !optimizationBounds) {
      setDrawFeature(null)
      optimizationDrawingStateRef.current = null
      map.dragPan.enable()
      if (map.getCanvas()) {
        map.getCanvas().style.cursor = ''
      }
      return
    }

    // Drawing mode is active
    if (map.getCanvas()) {
      map.getCanvas().style.cursor = 'crosshair'
    }

    const onMouseDown = (e: any) => {
      if (!optimizationDrawEnabled) {
        return
      }

      e.preventDefault?.()
      setOptimizationStatus('drawing')
      setOptimizationError(null)

      optimizationDrawingStateRef.current = {
        active: true,
        startPoint: e.point,
        startLngLat: e.lngLat
      }
      map.dragPan.disable()
    }

    const onMouseMove = (e: any) => {
      const drawState = optimizationDrawingStateRef.current
      if (!drawState?.active) {
        return
      }

      const a = clampLngLat((drawState.startLngLat as any).lng, (drawState.startLngLat as any).lat)
      const b = clampLngLat(e.lngLat.lng, e.lngLat.lat)
      const bounds = normalizeBBox(a, b)
      setOptimizationBounds(bounds)
      optimizationBoundsRef.current = bounds
      setDrawFeature(bounds)
    }

    const onMouseUp = () => {
      const drawState = optimizationDrawingStateRef.current
      if (!drawState?.active) {
        return
      }

      optimizationDrawingStateRef.current = null
      map.dragPan.enable()
      const hasValidBounds = Boolean(optimizationBoundsRef.current)
      setOptimizationStatus(hasValidBounds ? 'ready' : 'idle')
      setOptimizationDrawEnabled(false)
      
      // Auto-generate unique session ID and job ID when drawing completes
      if (hasValidBounds) {
        setSessionId(generateUniqueId())
        setJobId(generateUniqueId())
      }
      
      // Automatically fetch frequencies when drawing completes
      if (hasValidBounds && authTokenRef.current && optimizationBoundsRef.current) {
        void fetchOptimizationSectors(authTokenRef.current, optimizationBoundsRef.current)
      }
    }

    map.on('mousedown', onMouseDown)
    map.on('mousemove', onMouseMove)
    map.on('mouseup', onMouseUp)

    return () => {
      map.off('mousedown', onMouseDown)
      map.off('mousemove', onMouseMove)
      map.off('mouseup', onMouseUp)
      map.dragPan.enable()
      if (map.getCanvas()) {
        map.getCanvas().style.cursor = ''
      }
    }
  }, [mapReady, optimizationDrawEnabled, optimizationBounds, fetchOptimizationSectors])

  // Multi-bounding box visualization effect
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current

    // Clean up all result layers first
    optimizationResultsArray.forEach((result: OptimizationResult) => {
      const sourceId = `map-widget-optimization-result-${result.id}-src`
      const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
      const lineLayerId = `map-widget-optimization-result-${result.id}-line`

      if (map.getLayer(lineLayerId)) {
        map.removeLayer(lineLayerId)
      }
      if (map.getLayer(fillLayerId)) {
        map.removeLayer(fillLayerId)
      }
      if (map.getSource(sourceId)) {
        map.removeSource(sourceId)
      }
    })

    // Re-add visible result layers
    optimizationResultsArray.forEach((result: OptimizationResult, index: number) => {
      if (!visibleBoundingBoxes.has(result.id)) {
        return
      }

      // Skip if bounds are all zeros (placeholder)
      if (result.bounds.minLng === 0 && result.bounds.minLat === 0 &&
          result.bounds.maxLng === 0 && result.bounds.maxLat === 0) {
        return
      }

      const sourceId = `map-widget-optimization-result-${result.id}-src`
      const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
      const lineLayerId = `map-widget-optimization-result-${result.id}-line`

      // Create GeoJSON feature
      const ring = [
        [result.bounds.minLng, result.bounds.minLat],
        [result.bounds.maxLng, result.bounds.minLat],
        [result.bounds.maxLng, result.bounds.maxLat],
        [result.bounds.minLng, result.bounds.maxLat],
        [result.bounds.minLng, result.bounds.minLat]
      ]

      // Add source
      map.addSource(sourceId, {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: [{
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [ring] },
            properties: { resultId: result.id }
          }]
        }
      } as any)

      // Add fill layer (transparent with tint)
      map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: sourceId,
        paint: {
          'fill-color': result.color,
          'fill-opacity': 0.05
        }
      } as any)

      // Add line layer (colored border, solid for active, dashed for inactive)
      const isActive = activeResultIndex === index
      map.addLayer({
        id: lineLayerId,
        type: 'line',
        source: sourceId,
        paint: {
          'line-color': result.color,
          'line-width': isActive ? 3 : 2,
          'line-dasharray': isActive ? [1] : [3, 3]
        }
      } as any)
    })

    return () => {
      // Cleanup on unmount
      optimizationResultsArray.forEach((result: OptimizationResult) => {
        const sourceId = `map-widget-optimization-result-${result.id}-src`
        const fillLayerId = `map-widget-optimization-result-${result.id}-fill`
        const lineLayerId = `map-widget-optimization-result-${result.id}-line`

        if (map.getLayer(lineLayerId)) {
          map.removeLayer(lineLayerId)
        }
        if (map.getLayer(fillLayerId)) {
          map.removeLayer(fillLayerId)
        }
        if (map.getSource(sourceId)) {
          map.removeSource(sourceId)
        }
      })
    }
  }, [mapReady, optimizationResultsArray, visibleBoundingBoxes, activeResultIndex])

  // Auto-initialize visibility for new results
  React.useEffect(() => {
    setVisibleBoundingBoxes((prev: Set<string>) => {
      const newSet = new Set(prev)
      optimizationResultsArray.forEach((result: OptimizationResult) => {
        if (!newSet.has(result.id)) {
          newSet.add(result.id) // Show new boxes by default
        }
      })
      return newSet
    })
  }, [optimizationResultsArray])

  // Auto-zoom to bounding box when a result is activated
  React.useEffect(() => {
    if (!mapReady || !mapRef.current || activeResultIndex === null) {
      return
    }

    const activeResult = optimizationResultsArray[activeResultIndex]
    if (!activeResult || !activeResult.bounds) {
      return
    }

    const bounds = activeResult.bounds
    // Skip if bounds are placeholder (all zeros)
    if (bounds.minLng === 0 && bounds.minLat === 0 && bounds.maxLng === 0 && bounds.maxLat === 0) {
      return
    }

    const map = mapRef.current
    try {
      map.fitBounds(
        [[bounds.minLng, bounds.minLat], [bounds.maxLng, bounds.maxLat]],
        {
          padding: 50,
          duration: 1000
        }
      )
    } catch (error) {
      console.error('[Auto-zoom] Failed to fit bounds:', error)
    }
  }, [mapReady, activeResultIndex, optimizationResultsArray])

  // Manage optimization layer visibility when switching results
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current

    // Hide all optimization layers except for active result
    optimizationResultsArray.forEach((result: OptimizationResult, idx: number) => {
      const overlayKey = `optimization-layer-${result.id}`
      const overlay = overlayRef.current[overlayKey]

      if (!overlay || !overlay.layerIds) {
        return
      }

      const shouldShow = idx === activeResultIndex

      overlay.layerIds.forEach((layerId: string) => {
        if (map.getLayer(layerId)) {
          try {
            map.setLayoutProperty(layerId, 'visibility', shouldShow ? 'visible' : 'none')
          } catch (error) {
            console.error('[Layer Visibility] Failed to set visibility for layer:', layerId, error)
          }
        }
      })
    })
  }, [mapReady, activeResultIndex, optimizationResultsArray])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    mapRef.current.easeTo({
      center: DEFAULT_CENTER,
      zoom: DEFAULT_ZOOM,
      bearing: DEFAULT_BEARING,
      pitch: DEFAULT_PITCH,
      duration: 600
    })
  }, [mapReady])

  const layersHash = React.useMemo(() => {
    return JSON.stringify(runtimeConfig?.layers ?? [])
  }, [runtimeConfig?.layers])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    if (!ENABLE_WIDGET_3D_BUILDINGS_LAYER) {
      return
    }

    const map = mapRef.current
    const layers = runtimeConfig?.layers ?? []
    const addLayers = () => {
      layers.forEach((layerConfig: LayerConfig) => {
        if (!layerConfig?.id || !layerConfig?.sourceId) {
          return
        }

        if (map.getLayer(layerConfig.id)) {
          map.removeLayer(layerConfig.id)
        }
        if (map.getSource(layerConfig.sourceId)) {
          map.removeSource(layerConfig.sourceId)
        }

        map.addSource(layerConfig.sourceId, layerConfig.source as any)
        map.addLayer({
          id: layerConfig.id,
          source: layerConfig.sourceId,
          ...layerConfig.layer
        } as LayerSpecification)

        if (layerConfig.visible === false) {
          map.setLayoutProperty(layerConfig.id, 'visibility', 'none')
        }
      })
    }

    addLayers()

    return () => {
      layers.forEach((layerConfig: LayerConfig) => {
        if (map.getLayer(layerConfig.id)) {
          map.removeLayer(layerConfig.id)
        }
        if (map.getSource(layerConfig.sourceId)) {
          map.removeSource(layerConfig.sourceId)
        }
      })
    }
  }, [mapReady, layersHash])

  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    const map = mapRef.current

    const hidePoiLayers = () => {
      const style = map.getStyle()
      if (!style?.layers) {
        return
      }

      style.layers.forEach((layer: LayerSpecification) => {
        const layerId = layer.id
        if (!layerId || layer.type !== 'symbol') {
          return
        }

        const metadataGroup = (layer as any)?.metadata?.group
        const isPoiLayer = /poi/i.test(layerId) || (typeof metadataGroup === 'string' && /poi/i.test(metadataGroup))

        if (isPoiLayer && map.getLayer(layerId)) {
          map.setLayoutProperty(layerId, 'visibility', 'none')
        }
      })
    }

    hidePoiLayers()
    map.on('style.load', hidePoiLayers)

    return () => {
      map.off('style.load', hidePoiLayers)
    }
  }, [mapReady])



  React.useEffect(() => {
    if (!mapContainerRef.current) {
      return
    }

    const observer = new ResizeObserver(() => {
      mapRef.current?.resize()
    })

    observer.observe(mapContainerRef.current)

    return () => observer.disconnect()
  }, [])

  // 3D Sectors visibility and scale effect
  React.useEffect(() => {
    if (!mapReady || !mapRef.current) {
      return
    }

    console.log('[3D Sectors] Visibility:', show3DSectors, 'Scale:', sectorScale)
    const propChanges = threeDSceneRef.current.setLayerProps(ThreeD.LayerType.Sectors, {
      getSectorColor: getSectorColor,
      visible: show3DSectors,
      scale: sectorScale
    })
    const repaintableChange = threeDSceneRef.current.updateAfterPropsChanges(ThreeD.LayerType.Sectors, propChanges)
    if (repaintableChange) {
      console.log('[3D Sectors] Props changed, triggering repaint')
      mapRef.current.triggerRepaint()
    }
  }, [mapReady, show3DSectors, sectorScale, getSectorColor])

  return (
    <div className="maplibre-widget__map" ref={mapContainerRef} role="presentation">
      <style>
        {`
          @keyframes spinLoader {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `}
      </style>
      {(optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') && (
        <div style={{
          position: 'absolute',
          top: 12,
          left: '50%',
          transform: 'translateX(-50%)',
          zIndex: 2,
          background: 'rgba(10,10,10,0.85)',
          color: '#fff',
          padding: '8px 14px',
          borderRadius: 999,
          border: '1px solid rgba(255,255,255,0.2)',
          boxShadow: '0 4px 16px rgba(0,0,0,0.4)',
          display: 'flex',
          alignItems: 'center',
          gap: 8,
          maxWidth: 520
        }}>
          <div style={{
            width: 12,
            height: 12,
            border: '2px solid rgba(255,255,255,0.3)',
            borderTop: '2px solid #4fc3f7',
            borderRadius: '50%',
            animation: 'spinLoader 1s linear infinite'
          }} />
          <div style={{ fontSize: 11, lineHeight: 1.2, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
            {statusMessage || 'Optimization in progress...'}
          </div>
        </div>
      )}
      <div style={{ position: 'absolute', top: 8, left: 8, zIndex: 1, background: 'rgba(0,0,0,0.75)', color: '#fff', padding: '10px 12px', borderRadius: 6, fontSize: 11, lineHeight: 1.4, boxShadow: '0 2px 8px rgba(0,0,0,0.3)', maxWidth: 320 }}>
        <div style={{ marginBottom: 10 }}>
          <label style={{ display: 'flex', alignItems: 'center', marginBottom: coverageVisible ? 6 : 0, cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={coverageVisible}
              onChange={(e) => setCoverageVisible(e.target.checked)}
              style={{ marginRight: 6 }}
            />
            <span style={{ fontSize: 11 }}>Coverage Layer</span>
          </label>
          {coverageVisible && (
            <>
              <select
                value={coverageLayer}
                onChange={(e) => setCoverageLayer(e.target.value as CoverageLayer)}
                style={{ width: '100%', padding: '4px 6px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer', marginBottom: 6 }}
              >
                {COVERAGE_LAYER_OPTIONS.map((opt) => (
                  <option key={opt.value} value={opt.value}>
                    {opt.label}
                  </option>
                ))}
              </select>
              <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                <strong style={{ fontSize: 10, minWidth: 45 }}>Opacity</strong>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={coverageOpacity}
                  onChange={(e) => setCoverageOpacity(Number(e.target.value))}
                  style={{ flex: 1, cursor: 'pointer', height: 4 }}
                />
                <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{coverageOpacity}%</span>
              </div>
            </>
          )}
        </div>

        <div style={{ marginBottom: 10, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
          <label style={{ display: 'flex', alignItems: 'center', marginBottom: show3DSectors ? 6 : 0, cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={show3DSectors}
              onChange={(e) => setShow3DSectors(e.target.checked)}
              style={{ marginRight: 6 }}
            />
            <span style={{ fontSize: 11 }}>3D Sectors</span>
          </label>
          {show3DSectors && (
            <div style={{ display: 'flex', alignItems: 'center', gap: 6, paddingLeft: 22 }}>
              <label style={{ fontSize: 10, minWidth: 45 }}>Scale:</label>
              <input
                type="range"
                min="0.5"
                max="3"
                step="0.1"
                value={sectorScale}
                onChange={(e) => setSectorScale(parseFloat(e.target.value))}
                style={{ flex: 1, cursor: 'pointer', height: 4 }}
              />
              <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{sectorScale.toFixed(1)}x</span>
            </div>
          )}
        </div>

        <div style={{ marginBottom: 10, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
          <label style={{ display: 'flex', alignItems: 'center', marginBottom: iqiVisible ? 6 : 0, cursor: 'pointer' }}>
            <input
              type="checkbox"
              checked={iqiVisible}
              onChange={(e) => setIqiVisible(e.target.checked)}
              style={{ marginRight: 6 }}
            />
            <span style={{ fontSize: 11 }}>IQI Layer</span>
          </label>
          {iqiVisible && (
            <>
              <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 6 }}>
                <strong style={{ fontSize: 10, minWidth: 45 }}>Opacity</strong>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={iqiOpacity}
                  onChange={(e) => setIqiOpacity(Number(e.target.value))}
                  style={{ flex: 1, cursor: 'pointer', height: 4 }}
                />
                <span style={{ fontSize: 10, minWidth: 28, textAlign: 'right' }}>{iqiOpacity}%</span>
              </div>
              {iqiStatus === 'loading-token' && (
                <div style={{ fontSize: 10, color: '#80deea', paddingLeft: 22 }}>Getting token...</div>
              )}
              {iqiStatus === 'loading-data' && (
                <div style={{ fontSize: 10, color: '#80deea', paddingLeft: 22 }}>Loading features...</div>
              )}
              {iqiStatus === 'success' && iqiFeatureCount > 0 && (
                <div style={{ fontSize: 10, color: '#4caf50', paddingLeft: 22 }}>✓ {iqiFeatureCount.toLocaleString()} features loaded</div>
              )}
              {iqiStatus === 'error' && iqiError && (
                <div style={{ fontSize: 10, color: '#f44336', paddingLeft: 22 }}>{iqiError}</div>
              )}
              {iqiStatus === 'idle' && iqiError && (
                <div style={{ fontSize: 10, color: '#ff9800', paddingLeft: 22 }}>{iqiError}</div>
              )}
            </>
          )}
        </div>

        {clickedSectorData && (
          <div style={{ marginBottom: 10, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)', background: 'rgba(0,100,255,0.15)', padding: 10, borderRadius: 4, position: 'relative' }}>
            <button
              onClick={clearSectorView}
              style={{
                position: 'absolute',
                top: 8,
                right: 8,
                background: 'rgba(255,255,255,0.2)',
                border: '1px solid rgba(255,255,255,0.3)',
                color: '#fff',
                width: 20,
                height: 20,
                borderRadius: 3,
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: 14,
                fontWeight: 'bold',
                lineHeight: 1,
                padding: 0
              }}
              title="Clear sector view"
            >
              ×
            </button>
            <strong style={{ fontSize: 14, display: 'block', marginBottom: 8 }}>Sector View</strong>
            <div style={{ fontSize: 11, lineHeight: 1.6 }}>
              <div><strong>Sector:</strong> {clickedSectorData.sector_name}</div>
              <div><strong>Site:</strong> {clickedSectorData.site_name}</div>
              <div><strong>Band:</strong> {clickedSectorData.band}</div>
              <div><strong>Technology:</strong> {clickedSectorData.technology}</div>
              <div><strong>Azimuth:</strong> {clickedSectorData.azimuth}°</div>
              {sectorStyleStatus === 'loading' && (
                <div style={{ marginTop: 8, color: '#aaf' }}>Loading sector coverage...</div>
              )}
              {sectorStyleStatus === 'error' && (
                <div style={{ marginTop: 8, color: '#faa' }}>Error: {sectorStyleError}</div>
              )}
              {sectorStyleStatus === 'success' && (
                <div style={{ marginTop: 8, color: '#afa' }}>✓ Sector coverage loaded</div>
              )}
            </div>
          </div>
        )}

        <div style={{ display: 'flex', flexDirection: 'column', gap: 6, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
          <button
            type="button"
            onClick={() => setShowApiControls(!showApiControls)}
            style={{ padding: '6px 10px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.35)', background: showApiControls ? 'rgba(0,150,255,0.3)' : 'rgba(255,255,255,0.1)', color: '#fff', cursor: 'pointer', fontSize: 12, fontWeight: 500, transition: 'all 0.2s' }}
            aria-expanded={showApiControls}
          >
            {showApiControls ? '▼ ' : '▶ '}Map Layers
          </button>

          <button
            type="button"
            onClick={() => setRecallFormVisible(!recallFormVisible)}
            style={{
              padding: '6px 10px',
              borderRadius: 4,
              border: '1px solid rgba(255,255,255,0.35)',
              background: recallFormVisible ? 'rgba(138,43,226,0.4)' : 'rgba(138,43,226,0.25)',
              color: '#fff',
              cursor: 'pointer',
              fontWeight: 500,
              fontSize: 12,
              transition: 'all 0.2s',
              display: 'flex',
              alignItems: 'center',
              gap: 6
            }}
            title="Recall existing optimization results"
          >
            <span>🔍</span>
            <span>Recall Results</span>
          </button>

          {recallFormVisible && (
            <div style={{
              position: 'absolute',
              top: 90,
              left: 8,
              zIndex: 1000,
              background: 'rgba(0,0,0,0.85)',
              color: '#fff',
              padding: 16,
              borderRadius: 6,
              width: 320,
              boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
              border: '1px solid rgba(138,43,226,0.5)'
            }}>
              <div style={{ marginBottom: 12, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <strong style={{ fontSize: 13 }}>Recall Optimization Results</strong>
                <button
                  type="button"
                  onClick={() => setRecallFormVisible(false)}
                  style={{
                    background: 'rgba(255,0,0,0.3)',
                    border: '1px solid rgba(255,255,255,0.3)',
                    color: '#fff',
                    width: 20,
                    height: 20,
                    borderRadius: 3,
                    cursor: 'pointer',
                    fontSize: 14,
                    fontWeight: 'bold'
                  }}
                >
                  ×
                </button>
              </div>

              <div style={{ marginBottom: 10 }}>
                <label style={{ fontSize: 11, display: 'block', marginBottom: 4 }}>Session ID:</label>
                <input
                  type="text"
                  value={recallForm.sessionId}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => setRecallForm((prev: RecallFormState) => ({ ...prev, sessionId: e.target.value }))}
                  placeholder="Enter session ID"
                  style={{
                    width: '100%',
                    padding: '6px 8px',
                    fontSize: 11,
                    borderRadius: 3,
                    border: '1px solid rgba(255,255,255,0.35)',
                    background: 'rgba(0,0,0,0.7)',
                    color: '#fff'
                  }}
                />
              </div>

              <div style={{ marginBottom: 10 }}>
                <label style={{ fontSize: 11, display: 'block', marginBottom: 4 }}>Job ID:</label>
                <input
                  type="text"
                  value={recallForm.jobId}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => setRecallForm((prev: RecallFormState) => ({ ...prev, jobId: e.target.value }))}
                  placeholder="Enter job ID"
                  style={{
                    width: '100%',
                    padding: '6px 8px',
                    fontSize: 11,
                    borderRadius: 3,
                    border: '1px solid rgba(255,255,255,0.35)',
                    background: 'rgba(0,0,0,0.7)',
                    color: '#fff'
                  }}
                />
              </div>

              {recallForm.error && (
                <div style={{
                  marginBottom: 10,
                  padding: '6px 8px',
                  background: 'rgba(255,0,0,0.2)',
                  border: '1px solid rgba(255,0,0,0.5)',
                  borderRadius: 3,
                  fontSize: 10,
                  color: '#ffb3b3'
                }}>
                  {recallForm.error}
                </div>
              )}

              <button
                type="button"
                onClick={() => recallOptimizationResult(recallForm.sessionId, recallForm.jobId)}
                disabled={recallForm.loading || !recallForm.sessionId.trim() || !recallForm.jobId.trim()}
                style={{
                  width: '100%',
                  padding: '8px 12px',
                  fontSize: 12,
                  fontWeight: 'bold',
                  borderRadius: 3,
                  border: '1px solid rgba(255,255,255,0.35)',
                  background: recallForm.loading ? 'rgba(138,43,226,0.3)' : 'rgba(138,43,226,0.5)',
                  color: '#fff',
                  cursor: recallForm.loading ? 'not-allowed' : 'pointer',
                  opacity: recallForm.loading || !recallForm.sessionId.trim() || !recallForm.jobId.trim() ? 0.5 : 1
                }}
              >
                {recallForm.loading ? 'Loading...' : 'Recall Results'}
              </button>
            </div>
          )}

          {!optimizationBounds && (
            <button
              type="button"
              onClick={() => setOptimizationDrawEnabled(true)}
              style={{ padding: '6px 10px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.35)', background: optimizationDrawEnabled ? 'rgba(0,255,0,0.4)' : 'rgba(100,200,255,0.3)', color: '#fff', cursor: 'pointer', fontWeight: 500, fontSize: 12, transition: 'all 0.2s', display: 'flex', alignItems: 'center', gap: 6, justifyContent: 'center' }}
              title="Draw optimization bounding box"
            >
              {optimizationDrawEnabled ? (
                <>
                  <span>✏️</span>
                  <span>Drawing...</span>
                </>
              ) : (
                <>
                  <img src={cubeIcon} alt="Submit Optimization Request" style={{ width: 16, height: 16 }} />
                  <span>Submit Optimization Request</span>
                </>
              )}
            </button>
          )}
          {optimizationBounds && (
            <button
              type="button"
              onClick={() => {
                // Clear the optimization state - useEffect will handle map cleanup
                if (pollingTimerRef.current) {
                  window.clearTimeout(pollingTimerRef.current)
                  pollingTimerRef.current = null
                }
                setOptimizationStatus('idle')
                setOptimizationBounds(null)
                optimizationBoundsRef.current = null
                setOptimizationSectors([])
                setSelectedOptimizationSector(null)
                setOptimizationError(null)
                setOptimizationJobStatus('idle')
                setOptimizationJobError(null)
                setStatusMessage('')
                setStatusDetails(null)
                setSubmissionResponse(null)
                setPollingCount(0)
                setSessionId('')
                setJobId('')
                setOptimizationResults(null)
                setShowResultsView(false)
                setResultsError(null)
                setOptimizationLayerType('none')
                setOptimizationLayerData(null)
                setOptimizationLayerStatus('idle')
                setOptimizationLayerError(null)
                clearOverlay('optimization-layer')

                // Clear multi-result state
                setOptimizationResultsArray([])
                setActiveResultIndex(null)
                setShowResultsPanel(false)

                // Clear recall form
                setRecallFormVisible(false)
                setRecallForm({ sessionId: '', jobId: '', error: null, loading: false })

                // Clear comparison mode
                setComparisonMode(false)
                setSelectedComparisonIndices([0, 1])

                // Clear visibility
                setVisibleBoundingBoxes(new Set())

                // Clear per-result layer data
                setResultLayerTypes({})
                resultLayerDataRef.current = {}
                resultLayerStatusRef.current = {}
              }}
              style={{ padding: '6px 10px', borderRadius: 4, border: '1px solid rgba(255,0,0,0.5)', background: 'rgba(255,0,0,0.3)', color: '#fff', cursor: 'pointer', fontWeight: 500, fontSize: 12, transition: 'all 0.2s' }}
              title="Clear optimization box and start over"
            >
              🗑️ Clear Optimization
            </button>
          )}
        </div>

        {showApiControls && (
          <div style={{ marginTop: 8, paddingTop: 10, borderTop: '1px solid rgba(255,255,255,0.15)' }}>
            <div style={{ marginBottom: 8 }}>
              <strong style={{ fontSize: 12 }}>Additional Map Layers</strong>
            </div>

            <div style={{ display: 'grid', gap: 4, maxHeight: 180, overflow: 'auto' }}>
              {(Object.entries(apiVisibility) as Array<[string, ApiVisibilityEntry]>)
                .filter(([key]) => key !== 'bbox')
                .sort((a, b) => String(a[1]?.label ?? a[0]).localeCompare(String(b[1]?.label ?? b[0])))
                .map(([key, entry]: [string, ApiVisibilityEntry]) => (
                  <label key={key} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 10, padding: '4px 8px', borderRadius: 4, background: 'rgba(0,0,0,0.3)', cursor: 'pointer', transition: 'all 0.2s' }}>
                    <span style={{ fontSize: 11, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{entry?.label ?? key}</span>
                    <input
                      type="checkbox"
                      checked={entry?.enabled ?? true}
                      onChange={() => {
                        const currentlyEnabled = Boolean(entry?.enabled)

                        setApiVisibility((prev: Record<string, ApiVisibilityEntry>) => {
                          const current = prev[key]
                          const enabled = !(current?.enabled ?? true)
                          return {
                            ...prev,
                            [key]: {
                              label: current?.label ?? defaultApiLabel(key),
                              enabled
                            }
                          }
                        })

                        if (currentlyEnabled) {
                          clearOverlay(key)
                        }
                      }}
                      style={{ cursor: 'pointer', width: 16, height: 16 }}
                    />
                  </label>
                ))}
            </div>
          </div>
        )}

        {optimizationStatus !== 'idle' && optimizationBounds && (
          <div style={{ marginTop: 8, maxWidth: 340 }}>
            <div style={{ marginBottom: 6 }}>
              <strong>RHEA Optimization</strong>
            </div>

            {optimizationStatus === 'success' && optimizationSectors.length > 0 && (
              <div style={{ marginTop: 8 }}>
                {/* Input Controls */}
                <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
                  <div style={{ flex: 1 }}>
                    <div style={{ marginBottom: 4, fontSize: 11, fontWeight: 'bold' }}>Frequency:</div>
                    <select
                      value={selectedOptimizationSector ?? ''}
                      onChange={(e) => setSelectedOptimizationSector(Number(e.target.value))}
                      style={{ width: '100%', padding: '4px 6px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer' }}
                    >
                      {optimizationSectors.map((sector: number) => (
                        <option key={sector} value={sector}>
                          {sector}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div style={{ flex: 1 }}>
                    <div style={{ marginBottom: 4, fontSize: 11, fontWeight: 'bold' }}>Network:</div>
                    <select
                      value={selectedNetworkType}
                      onChange={(e) => setSelectedNetworkType(e.target.value)}
                      style={{ width: '100%', padding: '4px 6px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer' }}
                    >
                      <option value="LTE">LTE</option>
                      <option value="5G">5G</option>
                      <option value="FNET">FNET</option>
                    </select>
                  </div>
                </div>

                {/* Optimization Hyperparameters Section */}
                <div style={{ marginTop: 10, marginBottom: 8 }}>
                  <div
                    onClick={() => setHyperparametersExpanded(!hyperparametersExpanded)}
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      cursor: 'pointer',
                      padding: '6px 8px',
                      background: 'rgba(0,0,0,0.4)',
                      borderRadius: 3,
                      border: '1px solid rgba(255,255,255,0.2)',
                      transition: 'all 0.2s'
                    }}
                  >
                    <span style={{ fontSize: 11, marginRight: 6 }}>{hyperparametersExpanded ? '▼' : '▶'}</span>
                    <span style={{ fontSize: 10, fontWeight: 'bold' }}>Optimization Hyperparameters (Optional)</span>
                    {hasHyperparametersChanged() && (
                      <span style={{ marginLeft: 'auto', fontSize: 8, padding: '2px 6px', background: 'rgba(76, 175, 80, 0.3)', borderRadius: 2, color: '#4CAF50' }}>Modified</span>
                    )}
                  </div>

                  {hyperparametersExpanded && (
                    <div style={{ marginTop: 6, padding: 10, background: 'rgba(0,0,0,0.3)', borderRadius: 3, border: '1px solid rgba(255,255,255,0.15)' }}>
                      <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: 8 }}>
                        {/* RSRP Threshold */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.rsrp_threshold}>
                            RSRP Threshold (dBm)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            value={hyperparameters.rsrp_threshold}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, rsrp_threshold: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* SINR Threshold */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.sinr_threshold}>
                            SINR Threshold (dBm)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            value={hyperparameters.sinr_threshold}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, sinr_threshold: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* Alpha Condition Change */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.alpha_condition_change}>
                            Alpha Condition Change
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="0"
                            max="1"
                            value={hyperparameters.alpha_condition_change}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, alpha_condition_change: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* Alpha Bin to Bin */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.alpha_bin_to_bin}>
                            Alpha Bin to Bin
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="0"
                            max="1"
                            value={hyperparameters.alpha_bin_to_bin}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, alpha_bin_to_bin: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* Condition Change Multiplier */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.condition_change_multiplier}>
                            Condition Change Multiplier
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.5"
                            value={hyperparameters.condition_change_multiplier}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, condition_change_multiplier: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* RSRP Bin to Bin Loss Tolerance */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.rsrp_bin_to_bin_loss_tolerance}>
                            RSRP Bin to Bin Loss Tol. (%)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="-100"
                            max="0"
                            value={hyperparameters.rsrp_bin_to_bin_loss_tolerance}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, rsrp_bin_to_bin_loss_tolerance: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* RSRP Condition Change Loss Tolerance */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.rsrp_condition_change_loss_tolerance}>
                            RSRP Cond. Change Loss Tol. (%)
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="number"
                            step="0.1"
                            min="-100"
                            max="0"
                            value={hyperparameters.rsrp_condition_change_loss_tolerance}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, rsrp_condition_change_loss_tolerance: Number(e.target.value) })}
                            style={{ width: 80, padding: '3px 5px', fontSize: 10, borderRadius: 2, border: '1px solid rgba(255,255,255,0.3)', background: 'rgba(0,0,0,0.5)', color: '#fff' }}
                          />
                        </div>

                        {/* Use User Density Cache */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.use_user_density_cache}>
                            Use User Density Cache
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="checkbox"
                            checked={hyperparameters.use_user_density_cache}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, use_user_density_cache: e.target.checked })}
                            style={{ cursor: 'pointer', width: 16, height: 16 }}
                          />
                        </div>

                        {/* Use Default Antenna Pabcerns Only */}
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <label style={{ fontSize: 10, display: 'flex', alignItems: 'center', gap: 4, flex: 1 }} title={HYPERPARAMETER_TOOLTIPS.use_default_antenna_pabcerns_only}>
                            Use Default Antenna Pabcerns Only
                            <span style={{ cursor: 'help', opacity: 0.9, fontSize: 9 }}>ℹ️</span>
                          </label>
                          <input
                            type="checkbox"
                            checked={hyperparameters.use_default_antenna_pabcerns_only}
                            onChange={(e) => setHyperparameters({ ...hyperparameters, use_default_antenna_pabcerns_only: e.target.checked })}
                            style={{ cursor: 'pointer', width: 16, height: 16 }}
                          />
                        </div>
                      </div>

                      {/* Reset Button */}
                      <button
                        type="button"
                        onClick={() => setHyperparameters(DEFAULT_HYPERPARAMETERS)}
                        disabled={!hasHyperparametersChanged()}
                        style={{
                          marginTop: 8,
                          width: '100%',
                          padding: '4px 8px',
                          fontSize: 10,
                          borderRadius: 2,
                          border: '1px solid rgba(255,255,255,0.3)',
                          background: hasHyperparametersChanged() ? 'rgba(255,152,0,0.3)' : 'rgba(0,0,0,0.3)',
                          color: '#fff',
                          cursor: hasHyperparametersChanged() ? 'pointer' : 'not-allowed',
                          opacity: hasHyperparametersChanged() ? 1 : 0.5
                        }}
                      >
                        Reset to Defaults
                      </button>
                    </div>
                  )}
                </div>

                <div style={{ marginTop: 6 }}>
                  <button
                    type="button"
                    onClick={() => { void submitOptimizationJob() }}
                    style={{ width: '100%', padding: '5px 10px', fontSize: 12, fontWeight: 'bold', borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: optimizationJobStatus === 'completed' ? 'rgba(0,200,100,0.5)' : (optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') ? 'rgba(255,165,0,0.6)' : 'rgba(0,128,0,0.3)', color: '#fff', cursor: (sessionId.trim() && jobId.trim() && selectedOptimizationSector && optimizationJobStatus === 'idle') ? 'pointer' : 'not-allowed', opacity: (sessionId.trim() && jobId.trim() && selectedOptimizationSector && optimizationJobStatus === 'idle') ? 1 : 0.5, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6 }}
                    disabled={!sessionId.trim() || !jobId.trim() || !selectedOptimizationSector || optimizationJobStatus !== 'idle'}
                  >
                    <span>{(optimizationJobStatus === 'submitting' || optimizationJobStatus === 'polling') ? 'Running...' : optimizationJobStatus === 'completed' ? '✓ Complete' : 'Submit Job'}</span>
                  </button>
                </div>

                {/* Session/Job ID Display with Copy Buttons */}
                {sessionId && jobId && (
                  <div style={{ marginTop: 6, padding: '6px 8px', background: 'rgba(100,100,255,0.15)', borderRadius: 3, fontSize: 9, border: '1px solid rgba(100,100,255,0.3)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
                      <strong style={{ fontSize: 9, minWidth: 60 }}>Session ID:</strong>
                      <code style={{ flex: 1, fontSize: 8, background: 'rgba(0,0,0,0.3)', padding: '2px 4px', borderRadius: 2, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {sessionId}
                      </code>
                      <button
                        type="button"
                        onClick={() => {
                          navigator.clipboard.writeText(sessionId)
                          console.log('Session ID copied:', sessionId)
                        }}
                        style={{
                          padding: '2px 6px',
                          fontSize: 9,
                          borderRadius: 2,
                          border: '1px solid rgba(255,255,255,0.3)',
                          background: 'rgba(100,150,255,0.3)',
                          color: '#fff',
                          cursor: 'pointer'
                        }}
                        title="Copy Session ID"
                      >
                        📋
                      </button>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                      <strong style={{ fontSize: 9, minWidth: 60 }}>Job ID:</strong>
                      <code style={{ flex: 1, fontSize: 8, background: 'rgba(0,0,0,0.3)', padding: '2px 4px', borderRadius: 2, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                        {jobId}
                      </code>
                      <button
                        type="button"
                        onClick={() => {
                          navigator.clipboard.writeText(jobId)
                          console.log('Job ID copied:', jobId)
                        }}
                        style={{
                          padding: '2px 6px',
                          fontSize: 9,
                          borderRadius: 2,
                          border: '1px solid rgba(255,255,255,0.3)',
                          background: 'rgba(100,150,255,0.3)',
                          color: '#fff',
                          cursor: 'pointer'
                        }}
                        title="Copy Job ID"
                      >
                        📋
                      </button>
                    </div>
                  </div>
                )}

                {(optimizationJobStatus !== 'submitting' && optimizationJobStatus !== 'polling' && (optimizationJobStatus !== 'idle' || statusMessage || statusDetails || optimizationJobError || resultsError || submissionResponse || optimizationResults)) && (
                  <div style={{ marginTop: 6, padding: '6px', background: 'rgba(0,0,0,0.3)', borderRadius: 3, fontSize: 10, maxHeight: 200, overflow: 'auto' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 4 }}>
                      {(optimizationJobStatus !== 'submitting' && optimizationJobStatus !== 'polling') && (
                        <div><strong>Status:</strong> {optimizationJobStatus}</div>
                      )}
                      {optimizationJobStatus === 'polling' && (
                        <div style={{ fontSize: 9, opacity: 0.8, display: 'flex', alignItems: 'center', gap: 4 }}>
                          <div style={{ width: 10, height: 10, border: '2px solid rgba(255,255,255,0.3)', borderTop: '2px solid #4fc3f7', borderRadius: '50%', animation: 'spinLoader 1s linear infinite' }} />
                          Polling...
                        </div>
                      )}
                      {submissionResponse?.results && (
                        <div style={{ fontSize: 9, color: '#4CAF50', fontWeight: 'bold' }}>✓ Ready!</div>
                      )}
                    </div>
                    {pollingCount > 0 && (
                      <div style={{ fontSize: 10 }}><strong>Polls:</strong> {pollingCount}</div>
                    )}
                    {(optimizationJobStatus !== 'submitting' && optimizationJobStatus !== 'polling' && statusMessage) && (
                      <div style={{ marginTop: 4, fontSize: 10 }}>
                        <strong>Message:</strong> {statusMessage}
                      </div>
                    )}
                    {statusDetails?.message && (
                      <div style={{ marginTop: 4, padding: '4px', background: 'rgba(0,150,255,0.15)', borderRadius: 2, fontSize: 10, borderLeft: '2px solid #4fc3f7' }}>
                        {statusDetails.message}
                      </div>
                    )}
                    {optimizationJobError && (
                      <div style={{ marginTop: 4, color: '#ffb3b3' }}>
                        <strong>Error:</strong> {optimizationJobError}
                      </div>
                    )}
                    {/* View Results Button */}
                    {(submissionResponse?.results || optimizationJobStatus === 'completed' || optimizationResults) && (
                      <button
                        type="button"
                        onClick={() => {
                          console.log('[Optimization] View Results clicked')
                          if (optimizationResults) {
                            setShowResultsView(true)
                          } else if (submissionResponse?.results) {
                            setOptimizationResults(submissionResponse)
                            setShowResultsView(true)
                          } else {
                            void fetchOptimizationResults()
                          }
                        }}
                        style={{ width: '100%', marginTop: 8, padding: '8px 10px', borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,200,100,0.5)', color: '#fff', cursor: 'pointer', fontWeight: 'bold', fontSize: 11, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4 }}
                      >
                        📊 View Results
                      </button>
                    )}
                    {resultsError && (
                      <div style={{ marginTop: 4, color: '#ffb3b3' }}>
                        <strong>Results Error:</strong> {resultsError}
                      </div>
                    )}
                  </div>
                )}
              </div>
            )}

            {optimizationError && (
              <div style={{ marginTop: 6, color: '#ffb3b3' }}>
                <strong>Error:</strong> {optimizationError}
              </div>
            )}
          </div>
        )}
      </div>

      {/* Results List & Management Panel */}
      {optimizationResultsArray.length > 0 && (
        <div style={{
          position: 'absolute',
          top: 8,
          left: 360,
          zIndex: 999,
          background: 'rgba(0,0,0,0.75)',
          color: '#fff',
          padding: 10,
          borderRadius: 6,
          width: 280,
          maxHeight: 'calc(100vh - 16px)',
          overflow: 'auto',
          boxShadow: '0 4px 20px rgba(0,0,0,0.5)'
        }}>
          <div style={{ marginBottom: 10, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <strong style={{ fontSize: 12 }}>Loaded Results ({optimizationResultsArray.length})</strong>
            <button
              type="button"
              onClick={() => setComparisonMode(!comparisonMode)}
              disabled={optimizationResultsArray.length < 2}
              style={{
                padding: '4px 8px',
                fontSize: 10,
                borderRadius: 3,
                border: '1px solid rgba(255,255,255,0.35)',
                background: comparisonMode ? 'rgba(0,200,100,0.4)' : 'rgba(100,100,100,0.3)',
                color: '#fff',
                cursor: optimizationResultsArray.length < 2 ? 'not-allowed' : 'pointer',
                opacity: optimizationResultsArray.length < 2 ? 0.5 : 1
              }}
            >
              {comparisonMode ? '✓ Compare' : 'Compare'}
            </button>
          </div>

          {/* Result Cards */}
          {optimizationResultsArray.map((result: OptimizationResult, idx: number) => (
            <div
              key={result.id}
              style={{
                marginBottom: 8,
                padding: 8,
                borderRadius: 4,
                background: activeResultIndex === idx ? 'rgba(0,128,255,0.3)' : 'rgba(0,0,0,0.3)',
                border: `2px solid ${result.color}`,
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
              onClick={() => {
                setActiveResultIndex(idx)
                setShowResultsPanel(true)
              }}
            >
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 4 }}>
                <span style={{ fontSize: 11, fontWeight: 'bold' }}>{result.label}</span>
                <div style={{ display: 'flex', gap: 4 }}>
                  {/* Toggle Bounding Box Visibility */}
                  <button
                    type="button"
                    onClick={(e: React.MouseEvent) => {
                      e.stopPropagation()
                      setVisibleBoundingBoxes((prev: Set<string>) => {
                        const newSet = new Set(prev)
                        if (newSet.has(result.id)) {
                          newSet.delete(result.id)
                        } else {
                          newSet.add(result.id)
                        }
                        return newSet
                      })
                    }}
                    style={{
                      padding: '2px 6px',
                      fontSize: 9,
                      borderRadius: 2,
                      border: 'none',
                      background: visibleBoundingBoxes.has(result.id) ? 'rgba(0,255,0,0.3)' : 'rgba(255,0,0,0.3)',
                      color: '#fff',
                      cursor: 'pointer'
                    }}
                    title={visibleBoundingBoxes.has(result.id) ? 'Hide box' : 'Show box'}
                  >
                    {visibleBoundingBoxes.has(result.id) ? '👁️' : '🚫'}
                  </button>

                  {/* Delete Result */}
                  <button
                    type="button"
                    onClick={(e: React.MouseEvent) => {
                      e.stopPropagation()
                      setOptimizationResultsArray((prev: OptimizationResult[]) => prev.filter((r: OptimizationResult) => r.id !== result.id))
                      if (activeResultIndex === idx) {
                        setActiveResultIndex(optimizationResultsArray.length > 1 ? 0 : null)
                      }
                    }}
                    style={{
                      padding: '2px 6px',
                      fontSize: 9,
                      borderRadius: 2,
                      border: 'none',
                      background: 'rgba(255,0,0,0.3)',
                      color: '#fff',
                      cursor: 'pointer'
                    }}
                    title="Delete result"
                  >
                    🗑️
                  </button>
                </div>
              </div>

              <div style={{ fontSize: 9, opacity: 0.7 }}>
                <div>Session: {result.sessionId.substring(0, 12)}...</div>
                <div>Job: {result.jobId.substring(0, 12)}...</div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 4, marginTop: 2 }}>
                  <div style={{ width: 12, height: 12, background: result.color, borderRadius: 2 }} />
                  <span>{result.source === 'submitted' ? 'Submitted' : 'Recalled'}</span>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {(showResultsPanel && activeResultData) && (
        <div style={{ position: 'absolute', top: 8, right: 8, zIndex: 1000, background: 'rgba(0,0,0,0.65)', color: '#fff', padding: 12, borderRadius: 6, width: 420, maxHeight: 'calc(100vh - 16px)', overflow: 'auto', boxShadow: '0 4px 20px rgba(0,0,0,0.5)' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12, position: 'sticky', top: 0, background: 'transparent', padding: '0 0 12px 0', margin: '0', borderBottom: '1px solid rgba(255,255,255,0.15)', zIndex: 1 }}>
            <strong style={{ fontSize: 11 }}>Optimization Results</strong>
            <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
              {activeResultData?.results?.['optimized tilt settings'] && Array.isArray(activeResultData.results['optimized tilt settings']) && (
                <button
                  type="button"
                  onClick={() => setShowTiltTableModal(true)}
                  style={{ padding: '4px 8px', borderRadius: 999, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(100,200,255,0.25)', color: '#fff', cursor: 'pointer', fontSize: 9, fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: 4 }}
                >
                  <span>📋</span>
                  <span>Tilt Optimization Recommendations ({activeResultData.results['optimized tilt settings'].length})</span>
                </button>
              )}
              <button
                type="button"
                onClick={() => setShowResultsPanel(false)}
                style={{ background: 'rgba(255,0,0,0.3)', border: '1px solid rgba(255,255,255,0.3)', color: '#fff', width: 24, height: 24, borderRadius: 3, cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 16, fontWeight: 'bold', lineHeight: 1, padding: 0 }}
                title="Close"
              >
                ×
              </button>
            </div>
          </div>

          <div>
            {/* Visualization Layer Dropdown */}
            <div style={{ marginBottom: 12, paddingBottom: 12, borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
              <div style={{ marginBottom: 6 }}><strong style={{ fontSize: 11 }}>Visualization Layer:</strong></div>
              <select
                value={(() => {
                  // Get layer type for active result
                  if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
                    const resultId = optimizationResultsArray[activeResultIndex].id
                    return resultLayerTypes[resultId] || 'none'
                  }
                  return optimizationLayerType
                })()}
                onChange={(e) => {
                  const newType = e.target.value as OptimizationLayerType

                  // Store layer type for current result
                  if (activeResultIndex !== null && optimizationResultsArray[activeResultIndex]) {
                    const resultId = optimizationResultsArray[activeResultIndex].id
                    setResultLayerTypes((prev: Record<string, OptimizationLayerType>) => ({
                      ...prev,
                      [resultId]: newType
                    }))
                  }

                  // Also update global state for backward compatibility
                  setOptimizationLayerType(newType)

                  // Immediately apply visibility change
                  if (newType !== 'none') {
                    setCoverageVisible(false)

                    // Force immediate update of coverage layer visibility
                    if (mapRef.current) {
                      const overlay = overlayRef.current['coverage']
                      if (overlay?.layerIds?.length) {
                        overlay.layerIds.forEach((layerId: string) => {
                          if (mapRef.current?.getLayer(layerId)) {
                            mapRef.current.setLayoutProperty(layerId, 'visibility', 'none')
                          }
                        })
                      }
                    }
                  }

                  const token = authTokenRef.current
                  if (token) {
                    void fetchOptimizationLayer(token, newType)
                  }
                }}
                style={{ width: '100%', padding: '6px 8px', fontSize: 11, borderRadius: 3, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(0,0,0,0.7)', color: '#fff', cursor: 'pointer', marginBottom: 6 }}
              >
                {(() => {
                  const grouped = new Map<string, typeof OPTIMIZATION_LAYER_OPTIONS>()
                  OPTIMIZATION_LAYER_OPTIONS.forEach(opt => {
                    if (!grouped.has(opt.category)) {
                      grouped.set(opt.category, [])
                    }
                    grouped.get(opt.category)!.push(opt)
                  })
                  
                  return Array.from(grouped.entries()).map(([category, options]) => (
                    <optgroup key={category} label={category} style={{ fontSize: 11, fontWeight: 'bold' }}>
                      {options.map(opt => (
                        <option key={opt.value} value={opt.value} style={{ padding: '6px', fontSize: 11 }}>{opt.label}</option>
                      ))}
                    </optgroup>
                  ))
                })()}
              </select>
              {optimizationLayerStatus === 'loading' && (
                <div style={{ fontSize: 9, opacity: 0.8 }}>⏳ Loading layer...</div>
              )}
              {optimizationLayerStatus === 'success' && optimizationLayerType !== 'none' && (
                <div style={{ fontSize: 9, color: '#4CAF50' }}>✓ Layer loaded</div>
              )}
              {optimizationLayerError && (
                <div style={{ fontSize: 9, color: '#ffb3b3' }}>✗ {optimizationLayerError}</div>
              )}
            </div>

            {/* Summary Cards - 2x2 Grid */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 8, marginBottom: 12 }}>
              <div style={{ background: 'rgba(0,128,255,0.2)', padding: 8, borderRadius: 4, border: '1px solid rgba(0,128,255,0.4)' }}>
                <div style={{ fontSize: 9, opacity: 0.8 }}>RSRP Improvement</div>
                <div style={{ fontSize: 16, fontWeight: 'bold', color: '#4CAF50' }}>
                  +{activeResultData?.results?.total_scores?.['Net RSRP Bin to Bin']?.toFixed(2) || '0'}%
                </div>
              </div>
              <div style={{ background: 'rgba(0,255,128,0.2)', padding: 8, borderRadius: 4, border: '1px solid rgba(0,255,128,0.4)' }}>
                <div style={{ fontSize: 9, opacity: 0.8 }}>SINR Improvement</div>
                <div style={{ fontSize: 16, fontWeight: 'bold', color: '#4CAF50' }}>
                  +{activeResultData?.results?.total_scores?.['Net SINR Bin to Bin']?.toFixed(2) || '0'}%
                </div>
              </div>
              <div style={{ background: 'rgba(255,128,0,0.2)', padding: 8, borderRadius: 4, border: '1px solid rgba(255,128,0,0.4)' }}>
                <div style={{ fontSize: 9, opacity: 0.8 }}>RSRP Good to Bad</div>
                <div style={{ fontSize: 13, fontWeight: 'bold' }}>
                  {activeResultData?.results?.total_scores?.['RSRP Good to Bad']?.toFixed(4) || '0'}%
                </div>
              </div>
              <div style={{ background: 'rgba(255,0,128,0.2)', padding: 8, borderRadius: 4, border: '1px solid rgba(255,0,128,0.4)' }}>
                <div style={{ fontSize: 9, opacity: 0.8 }}>SINR Good to Bad</div>
                <div style={{ fontSize: 13, fontWeight: 'bold' }}>
                  {activeResultData?.results?.total_scores?.['SINR Good to Bad']?.toFixed(4) || '0'}%
                </div>
              </div>
            </div>

            {/* Horizontal Bar Chart for Scores */}
            {activeResultData?.results?.total_scores && (
              <div style={{ marginBottom: 12, background: 'rgba(255,255,255,0.05)', padding: 10, borderRadius: 4 }}>
                <div style={{ fontSize: 12, fontWeight: 'bold', marginBottom: 8 }}>Score Overview</div>
                <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
                    {[
                      { label: 'RSRP Improve', value: activeResultData.results.total_scores['RSRP Improv'], color: '#4CAF50' },
                      { label: 'SINR Improve', value: activeResultData.results.total_scores['SINR Improv'], color: '#8BC34A' },
                      { label: 'RSRP Worse', value: activeResultData.results.total_scores['RSRP Worse'], color: '#FF5722' },
                      { label: 'SINR Worse', value: activeResultData.results.total_scores['SINR Worse'], color: '#F44336' }
                  ].map(({ label, value, color }) => (
                    <div key={label} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                      <div style={{ width: 80, fontSize: 10 }}>{label}</div>
                      <div style={{ flex: 1, background: 'rgba(255,255,255,0.1)', borderRadius: 3, height: 18, position: 'relative', overflow: 'hidden' }}>
                        <div style={{ position: 'absolute', left: 0, top: 0, bottom: 0, width: `${Math.min((value / 50) * 100, 100)}%`, background: color, transition: 'width 0.3s' }} />
                        <div style={{ position: 'relative', padding: '0 6px', lineHeight: '18px', fontSize: 9, fontWeight: 'bold' }}>
                          {value?.toFixed(2)}%
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Signal Distribution Line Chart - SINR Pre vs Post */}
            {activeResultData?.results?.histograms && activeResultData.results.histograms['SINR Pre'] && activeResultData.results.histograms['SINR Post'] && (
              <div style={{ marginBottom: 12 }}>
                <div style={{ fontSize: 12, fontWeight: 'bold', marginBottom: 8 }}>SINR Signal Distribution</div>
                {(() => {
                  const sinrPreData = activeResultData.results.histograms['SINR Pre']
                  const sinrPostData = activeResultData.results.histograms['SINR Post']
                  
                  if (!Array.isArray(sinrPreData) || !Array.isArray(sinrPostData)) return <div style={{ fontSize: 10 }}>No data available</div>
                  
                  const allVals = [...sinrPreData, ...sinrPostData].map((d: any) => d.val || 0)
                  const maxVal = Math.max(...allVals, 0)
                  const yMin = -5
                  const yMax = 20
                  const yRange = yMax - yMin
                  
                  const createLinePoints = (data: any[]) => {
                    return data.map((d: any, idx: number) => {
                      const x = 40 + (idx / Math.max(data.length - 1, 1)) * 370
                      const y = 150 - ((d.val - yMin) / yRange) * 150
                      return { x, y, val: d.val, range: `${d.low}-${d.high}` }
                    })
                  }
                  
                  const prePoints = createLinePoints(sinrPreData)
                  const postPoints = createLinePoints(sinrPostData)
                  
                  const createPathD = (points: any[]) => {
                    if (points.length === 0) return ''
                    const start = `M ${points[0].x} ${points[0].y}`
                    const curves = points.slice(1).map((p: any) => `L ${p.x} ${p.y}`).join(' ')
                    return `${start} ${curves}`
                  }
                  
                  return (
                    <div style={{ background: 'rgba(255,255,255,0.05)', padding: 10, borderRadius: 4 }}>
                      <svg width="100%" height="180" viewBox="0 0 420 180" style={{ display: 'block' }}>
                        {/* Y-axis labels and grid */}
                        {[-5, 0, 5, 10, 15, 20].map((y: number) => {
                          const yPos = 150 - ((y - yMin) / yRange) * 150 + 15
                          return (
                            <g key={`y-${y}`}>
                              <line x1="40" y1={yPos} x2="410" y2={yPos} stroke="rgba(255,255,255,0.1)" strokeWidth="1" strokeDasharray="2,2" />
                              <text x="35" y={yPos + 3} fontSize="9" fill="rgba(255,255,255,0.6)" textAnchor="end">{y}</text>
                            </g>
                          )
                        })}
                        
                        {/* Axes */}
                        <line x1="40" y1="15" x2="40" y2="165" stroke="rgba(255,255,255,0.3)" strokeWidth="1" />
                        <line x1="40" y1="165" x2="410" y2="165" stroke="rgba(255,255,255,0.3)" strokeWidth="1" />
                        
                        {/* SINR Pre line */}
                        <path d={createPathD(prePoints)} stroke="#2196F3" strokeWidth="2.5" fill="none" strokeLinecap="round" strokeLinejoin="round" />
                        
                        {/* SINR Post line */}
                        <path d={createPathD(postPoints)} stroke="#FF5252" strokeWidth="2.5" fill="none" strokeLinecap="round" strokeLinejoin="round" />
                        
                        {/* Data points */}
                        {prePoints.map((p: any, idx: number) => (
                          <circle key={`pre-${idx}`} cx={p.x} cy={p.y} r="2" fill="#2196F3" opacity="0.8" />
                        ))}
                        {postPoints.map((p: any, idx: number) => (
                          <circle key={`post-${idx}`} cx={p.x} cy={p.y} r="2" fill="#FF5252" opacity="0.8" />
                        ))}
                      </svg>
                      
                      {/* Legend */}
                      <div style={{ display: 'flex', gap: 16, marginTop: 8, fontSize: 10, justifyContent: 'center' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                          <div style={{ width: 14, height: 2, background: '#2196F3', borderRadius: 1 }} />
                          <span>Pre Optimization</span>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                          <div style={{ width: 14, height: 2, background: '#FF5252', borderRadius: 1 }} />
                          <span>Post Optimization</span>
                        </div>
                      </div>
                      
                      <div style={{ marginTop: 6, fontSize: 9, opacity: 0.6, textAlign: 'center' }}>SINR Range (dB)</div>
                    </div>
                  )
                })()}
              </div>
            )}

          </div>
        </div>
      )}

      {/* Tilt Table Modal */}
      {showTiltTableModal && activeResultData?.results?.['optimized tilt settings'] && (
        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 10000, background: 'rgba(0,0,0,0.85)', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 20 }}>
          <div style={{ background: '#1a1a1a', color: '#fff', borderRadius: 8, maxWidth: 1000, width: '100%', maxHeight: '90vh', overflow: 'auto', boxShadow: '0 4px 20px rgba(0,0,0,0.5)' }}>
            <div style={{ padding: '16px 20px', borderBottom: '1px solid rgba(255,255,255,0.1)', display: 'flex', justifyContent: 'space-between', alignItems: 'center', position: 'sticky', top: 0, background: '#1a1a1a', zIndex: 1 }}>
              <h2 style={{ margin: 0, fontSize: 18, fontWeight: 'bold', color: '#fff' }}>Optimized Tilt Recommendations</h2>
              <button
                type="button"
                onClick={() => setShowTiltTableModal(false)}
                style={{ padding: '6px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.35)', background: 'rgba(255,0,0,0.3)', color: '#fff', cursor: 'pointer', fontSize: 14 }}
              >
                Close
              </button>
            </div>
            <div style={{ padding: 20 }}>
              <div style={{ overflowX: 'auto' }}>
                <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 13 }}>
                  <thead>
                    <tr style={{ background: 'rgba(255,255,255,0.1)' }}>
                      <th style={{ padding: 10, textAlign: 'left', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Sector Name</th>
                      <th style={{ padding: 10, textAlign: 'left', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Antenna Name</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Optimized Tilt</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Current Tilt</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Tilt Delta</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Min Tilt</th>
                      <th style={{ padding: 10, textAlign: 'center', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Max Tilt</th>
                      <th style={{ padding: 10, textAlign: 'right', borderBottom: '2px solid rgba(255,255,255,0.2)', fontWeight: 'bold' }}>Height (m)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {activeResultData.results['optimized tilt settings'].map((setting: any, idx: number) => (
                      <tr key={idx} style={{ borderBottom: '1px solid rgba(255,255,255,0.1)', background: idx % 2 === 0 ? 'rgba(255,255,255,0.03)' : 'transparent' }}>
                        <td style={{ padding: 10 }}>{setting.sector_name}</td>
                        <td style={{ padding: 10 }}>{setting.antenna_name}</td>
                        <td style={{ padding: 10, textAlign: 'center', fontWeight: 'bold', color: '#4CAF50', fontSize: 14 }}>{setting.tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'center' }}>{setting.current_tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'center', fontWeight: 'bold', color: setting.delta_tilt < 0 ? '#FF5722' : '#4CAF50' }}>
                          {setting.delta_tilt > 0 ? '+' : ''}{setting.delta_tilt}°
                        </td>
                        <td style={{ padding: 10, textAlign: 'center', opacity: 0.7 }}>{setting.min_tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'center', opacity: 0.7 }}>{setting.max_tilt}°</td>
                        <td style={{ padding: 10, textAlign: 'right', opacity: 0.7 }}>{setting.height?.toFixed(2)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Floating Legend Panel - Bottom Right */}
      {coverageVisible && (coverageLayer === 'rsrp_dbm_poly' || coverageLayer === 'bin_state_poly' || coverageLayer === 'sector_counter_poly') && (
        <div style={{
          position: 'absolute',
          bottom: 8,
          right: 8,
          zIndex: 1,
          background: 'rgba(0,0,0,0.85)',
          color: '#fff',
          borderRadius: 6,
          boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
          minWidth: 160,
          maxWidth: 200
        }}>
          <div 
            onClick={() => setLegendExpanded(!legendExpanded)}
            style={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 6,
              cursor: 'pointer',
              padding: '8px 12px',
              borderBottom: legendExpanded ? '1px solid rgba(255,255,255,0.15)' : 'none'
            }}
          >
            <span style={{ 
              fontSize: 12, 
              transform: legendExpanded ? 'rotate(180deg)' : 'rotate(0deg)', 
              transition: 'transform 0.2s' 
            }}>▼</span>
            <span style={{ fontSize: 11, fontWeight: 'bold' }}>Legend</span>
          </div>
          
          {legendExpanded && (
            <div style={{ padding: '8px 12px' }}>
              <div style={{ fontSize: 9, marginBottom: 4, opacity: 0.8, fontWeight: 'bold' }}>RHEA Coverage</div>
              
              {coverageLayer === 'rsrp_dbm_poly' && (
                <>
                  <div style={{ fontSize: 8, marginBottom: 8, opacity: 0.7 }}>Composite Coverage</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {RSRP_LEGEND.map((item: { value: number, color: string, label: string }) => (
                      <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <div style={{ 
                          width: 20, 
                          height: 14, 
                          background: item.color, 
                          border: '1px solid rgba(255,255,255,0.2)',
                          flexShrink: 0
                        }} />
                        <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}
              
              {coverageLayer === 'bin_state_poly' && (
                <>
                  <div style={{ fontSize: 8, marginBottom: 8, opacity: 0.7 }}>Composite State per Bin</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {BIN_STATE_LEGEND.map((item: { value: string, color: string, label: string }) => (
                      <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <div style={{ 
                          width: 20, 
                          height: 14, 
                          background: item.color, 
                          border: '1px solid rgba(255,255,255,0.2)',
                          flexShrink: 0
                        }} />
                        <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}

              {coverageLayer === 'sector_counter_poly' && (
                <>
                  <div style={{ fontSize: 8, marginBottom: 8, opacity: 0.7 }}>Sector Count per Bin</div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    {SECTOR_COUNTER_LEGEND.map((item: { value: number, color: string, label: string }) => (
                      <div key={item.value} style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <div style={{
                          width: 20,
                          height: 14,
                          background: item.color,
                          border: '1px solid rgba(255,255,255,0.2)',
                          flexShrink: 0
                        }} />
                        <span style={{ fontSize: 9, opacity: 0.9 }}>{item.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  )
}

export default MapLibreView
