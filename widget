/** @jsx jsx */
import { React, jsx } from "jimu-core";

const MVT_TILE_URL = "https://abc.com/oauth21/api/vector/tile/polygons/zxy/all";
const MANUAL_BEARER = "token";
const ARCGIS_API_VERSION = "4.32";

interface State {
  message: string;
  currentZoom: number;
  tileCount: number;
  featureCount: number;
}

export default class Widget extends React.PureComponent<any, State> {
  private mapDiv: HTMLDivElement;
  private mapView: any;
  private graphicsLayer: any;
  private tileCache: Map<string, any> = new Map();
  private isLoadingTiles: boolean = false;

  constructor(props) {
    super(props);
    this.state = {
      message: "Widget y√ºkleniyor...",
      currentZoom: 15,
      tileCount: 0,
      featureCount: 0
    };
  }

  componentDidMount() {
    this.loadLibraries();
  }

  componentWillUnmount() {
    if (this.mapView) {
      this.mapView.destroy();
    }
  }

  loadLibraries = () => {
    this.setState({ message: "üì¶ K√ºt√ºphaneler y√ºkleniyor..." });

    // ArcGIS CSS
    const cssLink = document.createElement("link");
    cssLink.rel = "stylesheet";
    cssLink.href = `https://js.arcgis.com/${ARCGIS_API_VERSION}/esri/themes/dark/main.css`;
    document.head.appendChild(cssLink);

    // Protobuf library (CDN)
    const pbfScript = document.createElement("script");
    pbfScript.src = "https://cdn.jsdelivr.net/npm/pbf@3.2.1/dist/pbf.min.js";
    pbfScript.onload = () => {
      console.log("‚úÖ Pbf loaded");
      
      // Vector Tile library
      const vtScript = document.createElement("script");
      vtScript.src = "https://cdn.jsdelivr.net/npm/@mapbox/vector-tile@1.3.1/dist/vector-tile.min.js";
      vtScript.onload = () => {
        console.log("‚úÖ VectorTile loaded");
        this.loadArcGISAPI();
      };
      vtScript.onerror = () => {
        this.setState({ message: "‚ùå VectorTile k√ºt√ºphanesi y√ºklenemedi" });
      };
      document.head.appendChild(vtScript);
    };
    pbfScript.onerror = () => {
      this.setState({ message: "‚ùå Pbf k√ºt√ºphanesi y√ºklenemedi" });
    };
    document.head.appendChild(pbfScript);
  };

  loadArcGISAPI = () => {
    this.setState({ message: "üì¶ ArcGIS API y√ºkleniyor..." });

    if ((window as any).require) {
      this.createMap();
      return;
    }

    const existing = document.querySelector(`script[data-arcgis-api="${ARCGIS_API_VERSION}"]`);
    if (existing) {
      existing.addEventListener('load', () => this.createMap());
      return;
    }

    const script = document.createElement("script");
    script.src = `https://js.arcgis.com/${ARCGIS_API_VERSION}/`;
    script.setAttribute('data-arcgis-api', ARCGIS_API_VERSION);
    script.onload = () => this.createMap();
    script.onerror = () => {
      this.setState({ message: "‚ùå ArcGIS API y√ºklenemedi" });
    };
    document.head.appendChild(script);
  };

  createMap = () => {
    this.setState({ message: "üó∫Ô∏è Map olu≈üturuluyor..." });

    if (!this.mapDiv) {
      setTimeout(() => this.createMap(), 50);
      return;
    }

    (window as any).require([
      'esri/Map',
      'esri/views/MapView',
      'esri/layers/GraphicsLayer',
      'esri/Graphic',
      'esri/geometry/Polygon'
    ], (Map, MapView, GraphicsLayer, Graphic, Polygon) => {
      
      // GraphicsLayer olu≈ütur
      this.graphicsLayer = new GraphicsLayer({
        title: "MVT Polygon Layer"
      });

      const map = new Map({
        basemap: 'dark-gray-vector',
        layers: [this.graphicsLayer]
      });

      this.mapView = new MapView({
        container: this.mapDiv,
        map: map,
        center: [32, 39],
        zoom: 15,
        constraints: {
          snapToZoom: false,
          minZoom: 15,
          maxZoom: 22,
          rotationEnabled: false
        }
      });

      // Mouse wheel zoom
      this.mapView.when(() => {
        const container = this.mapView.container as HTMLElement;
        
        container.addEventListener('wheel', (event: WheelEvent) => {
          event.preventDefault();
          const currentZoom = this.mapView.zoom;
          const delta = event.deltaY;
          const zoomChange = delta > 0 ? -0.2 : 0.2;
          const newZoom = Math.max(15, Math.min(22, currentZoom + zoomChange));
          
          this.mapView.goTo({ zoom: newZoom }, { duration: 100 });
        }, { passive: false });

        this.setState({ message: "‚úÖ Map hazƒ±r! ƒ∞lk tile'lar y√ºkleniyor..." });
        this.loadTilesForViewport();
      });

      // Zoom deƒüi≈üimini izle
      this.mapView.watch('zoom', (newZoom) => {
        this.setState({ currentZoom: Math.round(newZoom * 10) / 10 });
      });

      // Extent deƒüi≈üimini izle (pan/zoom sonrasƒ±)
      this.mapView.watch('stationary', (isStationary) => {
        if (isStationary && this.mapView.zoom >= 15) {
          this.loadTilesForViewport();
        }
      });

      // Store classes for later use
      (window as any).EsriGraphic = Graphic;
      (window as any).EsriPolygon = Polygon;
    });
  };

  // RSRP deƒüerine g√∂re renk hesapla
  getColorForRSRP = (rsrp: number): [number, number, number, number] => {
    const colorMap = [
      { value: -135, color: [49, 54, 149, 128] },
      { value: -126, color: [69, 117, 180, 128] },
      { value: -118, color: [116, 173, 209, 128] },
      { value: -109, color: [171, 217, 233, 128] },
      { value: -100, color: [224, 243, 248, 128] },
      { value: -92, color: [255, 255, 191, 128] },
      { value: -83, color: [254, 224, 144, 128] },
      { value: -75, color: [253, 174, 97, 128] },
      { value: -66, color: [244, 109, 67, 128] },
      { value: -57, color: [215, 48, 39, 128] },
      { value: -49, color: [165, 0, 38, 128] }
    ];

    // Linear interpolation
    for (let i = 0; i < colorMap.length - 1; i++) {
      const current = colorMap[i];
      const next = colorMap[i + 1];
      
      if (rsrp >= current.value && rsrp < next.value) {
        const ratio = (rsrp - current.value) / (next.value - current.value);
        return [
          Math.round(current.color[0] + (next.color[0] - current.color[0]) * ratio),
          Math.round(current.color[1] + (next.color[1] - current.color[1]) * ratio),
          Math.round(current.color[2] + (next.color[2] - current.color[2]) * ratio),
          128
        ];
      }
    }

    return rsrp <= -135 ? [49, 54, 149, 128] : [165, 0, 38, 128];
  };

  // Viewport i√ßin tile listesi hesapla
  getTilesForViewport = () => {
    const extent = this.mapView.extent;
    const zoom = 15; // POC i√ßin sadece zoom 15

    const tiles: Array<{z: number, x: number, y: number}> = [];

    // Lat/Lon to Tile X/Y conversion
    const lon2tile = (lon: number, zoom: number) => 
      Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
    
    const lat2tile = (lat: number, zoom: number) => 
      Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));

    const minX = lon2tile(extent.xmin, zoom);
    const maxX = lon2tile(extent.xmax, zoom);
    const minY = lat2tile(extent.ymax, zoom); // ymax -> minY (inverted)
    const maxY = lat2tile(extent.ymin, zoom);

    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        tiles.push({ z: zoom, x, y });
      }
    }

    return tiles;
  };

  // Viewport i√ßin tile'larƒ± y√ºkle
  loadTilesForViewport = async () => {
    if (this.isLoadingTiles) return;
    
    this.isLoadingTiles = true;
    this.setState({ message: "üîÑ Tile'lar y√ºkleniyor..." });

    const tiles = this.getTilesForViewport();
    this.setState({ tileCount: tiles.length });

    let totalFeatures = 0;

    for (const tile of tiles) {
      const tileKey = `${tile.z}-${tile.x}-${tile.y}`;
      
      // Cache kontrol√º
      if (this.tileCache.has(tileKey)) {
        console.log(`‚úÖ Cache hit: ${tileKey}`);
        continue;
      }

      try {
        const features = await this.fetchAndDecodeTile(tile.z, tile.x, tile.y);
        this.tileCache.set(tileKey, features);
        this.renderFeatures(features, tile.z, tile.x, tile.y);
        totalFeatures += features.length;
        
        console.log(`‚úÖ Tile loaded: ${tileKey} (${features.length} features)`);
      } catch (error) {
        console.error(`‚ùå Tile error: ${tileKey}`, error);
      }
    }

    this.setState({ 
      message: `‚úÖ ${tiles.length} tile y√ºklendi!`,
      featureCount: totalFeatures
    });
    
    this.isLoadingTiles = false;
  };

  // Tile fetch + decode
  fetchAndDecodeTile = async (z: number, x: number, y: number): Promise<any[]> => {
    const url = `${MVT_TILE_URL}/${z}/${x}/${y}.pbf?coverageLayer=rsrp_dbm_poly`;
    
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${MANUAL_BEARER}`
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const arrayBuffer = await response.arrayBuffer();
    
    // Decode MVT
    const Pbf = (window as any).Pbf;
    const VectorTile = (window as any).VectorTile;
    
    const tile = new VectorTile(new Pbf(arrayBuffer));
    const layerName = 'data'; // Style JSON'dan biliyoruz
    
    if (!tile.layers[layerName]) {
      console.warn(`Layer "${layerName}" not found in tile ${z}/${x}/${y}`);
      return [];
    }

    const layer = tile.layers[layerName];
    const features: any[] = [];

    // Her feature'ƒ± GeoJSON'a √ßevir
    for (let i = 0; i < layer.length; i++) {
      const feature = layer.feature(i);
      const geojson = feature.toGeoJSON(x, y, z);
      features.push(geojson);
    }

    return features;
  };

  // Feature'larƒ± GraphicsLayer'a ekle
  renderFeatures = (features: any[], z: number, x: number, y: number) => {
    const Graphic = (window as any).EsriGraphic;
    const Polygon = (window as any).EsriPolygon;

    features.forEach(feature => {
      if (feature.geometry.type !== 'Polygon') return;

      const rsrp = feature.properties.rsrp_dbm;
      if (rsrp === undefined || rsrp === null) return;

      const color = this.getColorForRSRP(rsrp);

      // GeoJSON coordinates -> ArcGIS Polygon
      const rings = feature.geometry.coordinates.map(ring => 
        ring.map(coord => [coord[0], coord[1]]) // [lon, lat]
      );

      const polygon = new Polygon({
        rings: rings,
        spatialReference: { wkid: 4326 } // WGS84
      });

      const graphic = new Graphic({
        geometry: polygon,
        symbol: {
          type: "simple-fill",
          color: color,
          outline: {
            color: [100, 100, 100, 100],
            width: 0.5
          }
        },
        attributes: {
          rsrp_dbm: rsrp,
          tile: `${z}/${x}/${y}`
        }
      });

      this.graphicsLayer.add(graphic);
    });
  };

  render() {
    const { message, currentZoom, tileCount, featureCount } = this.state;

    return (
      <div style={{ width: "100%", height: "100%", position: "relative" }}>
        <div 
          ref={el => this.mapDiv = el}
          style={{ width: "100%", height: "100%" }}
        />

        {/* Zoom Control */}
        <div style={{
          position: "absolute",
          top: "10px",
          right: "10px",
          background: "rgba(0,0,0,0.9)",
          color: "white",
          padding: "20px",
          borderRadius: "8px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "14px",
          minWidth: "200px"
        }}>
          <div style={{ marginBottom: "15px", textAlign: "center", fontWeight: "bold", color: "#4CAF50" }}>
            üé® MVT‚ÜíGeoJSON PoC
          </div>
          
          <div style={{ 
            background: "rgba(255,255,255,0.1)", 
            padding: "15px", 
            borderRadius: "5px",
            marginBottom: "15px",
            textAlign: "center"
          }}>
            <div style={{ fontSize: "12px", color: "#aaa", marginBottom: "5px" }}>
              Zoom Level
            </div>
            <div style={{ fontSize: "32px", fontWeight: "bold", color: "#FFD700" }}>
              {currentZoom}
            </div>
          </div>

          <div style={{ fontSize: "11px", marginBottom: "10px" }}>
            <div>üì¶ Tiles: {tileCount}</div>
            <div>üî∑ Features: {featureCount}</div>
            <div>üíæ Cache: {this.tileCache.size} tiles</div>
          </div>

          <div style={{ display: "flex", gap: "10px" }}>
            <button
              onClick={() => {
                if (this.mapView) {
                  this.mapView.goTo({ zoom: this.mapView.zoom - 0.5 }, { duration: 200 });
                }
              }}
              style={{
                flex: 1,
                padding: "15px",
                fontSize: "20px",
                background: "#f44336",
                color: "white",
                border: "none",
                borderRadius: "5px",
                cursor: "pointer",
                fontWeight: "bold"
              }}
            >
              -
            </button>
            <button
              onClick={() => {
                if (this.mapView) {
                  this.mapView.goTo({ zoom: this.mapView.zoom + 0.5 }, { duration: 200 });
                }
              }}
              style={{
                flex: 1,
                padding: "15px",
                fontSize: "20px",
                background: "#4CAF50",
                color: "white",
                border: "none",
                borderRadius: "5px",
                cursor: "pointer",
                fontWeight: "bold"
              }}
            >
              +
            </button>
          </div>

          <button
            onClick={() => {
              this.graphicsLayer.removeAll();
              this.tileCache.clear();
              this.setState({ tileCount: 0, featureCount: 0 });
              this.loadTilesForViewport();
            }}
            style={{
              width: "100%",
              marginTop: "10px",
              padding: "10px",
              fontSize: "12px",
              background: "#FF9800",
              color: "white",
              border: "none",
              borderRadius: "5px",
              cursor: "pointer"
            }}
          >
            üîÑ Refresh
          </button>
        </div>

        {/* Status Panel */}
        <div style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          background: "rgba(0,0,0,0.8)",
          color: "white",
          padding: "15px",
          borderRadius: "5px",
          zIndex: 9999,
          fontFamily: "monospace",
          fontSize: "12px",
          maxWidth: "300px"
        }}>
          <strong>üß™ PoC Status:</strong>
          <div style={{ marginTop: "10px" }}>{message}</div>
          <div style={{ marginTop: "10px", fontSize: "10px", color: "#aaa" }}>
            ‚úÖ MVT Tile Fetch<br/>
            ‚úÖ Protobuf Decode<br/>
            ‚úÖ GeoJSON Convert<br/>
            ‚úÖ RSRP Color Mapping<br/>
            ‚úÖ GraphicsLayer Render<br/>
            ‚úÖ Tile Cache<br/>
          </div>
        </div>
      </div>
    );
  }
}
