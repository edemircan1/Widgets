/** @jsx jsx */
import {
  React, ReactDOM, css, jsx, getAppStore, type AllWidgetProps, SessionManager,
  type DataRecordSet, TimezoneConfig, AppMode, type IMState,
  classNames, polished, ReactResizeDetector, MutableStoreManager,
  type IMUrlParameters, type DataSource, ExBAddedJSAPIProperties
} from 'jimu-core'
import { type IMConfig } from '../config'
import MultiSourceMap from './components/multisourcemap'
import DefaultMap from './components/default-map'
import { type IFeature } from '@esri/arcgis-rest-feature-service'
import {
  checkIsLive, type MapUrlHashParams, isFullscreenEnabled, getFullscreenElement,
  requestFullscreen, exitFullscreen
} from './utils'
import {
  type JimuMapViewGroup, type ShowOnMapDatas, type AddToMapDatas,
  type JimuMapView, type JimuLayerView,
  DataChangeStatus, loadArcGISJSAPIModules, MapViewManager
} from 'jimu-arcgis'
import {
  ViewportVisibilityContext, PageVisibilityContext, ViewVisibilityContext
} from 'jimu-layouts/layout-runtime'
import { versionManager } from '../version-manager'
import { Loading, LoadingType, Icon, DataActionList, DataActionListStyle } from 'jimu-ui'
import { type ZoomToFeatureActionValue } from '../message-actions/zoom-to-feature-action'
import { type PanToActionValue } from '../message-actions/pan-to-action'
import defaultMessages from './translations/default'
import { Global } from 'jimu-theme'

const MVT_STYLE_URL = 'https://your.api.host/path/to/style.json' // TODO: replace
const MANUAL_BEARER = 'YOUR_MANUAL_BEARER_TOKEN' // TODO: replace
const MVT_LAYER_ID = 'custom-arcgis-map-mvt-layer'
// Match all tile requests for your MVT service host (adjust as needed)
const MVT_REQUEST_URL_REGEX = /https:\/\/your\.api\.host\/.*/ // TODO: replace

export interface ActionRelatedProps {
  zoomToFeatureActionValue?: ZoomToFeatureActionValue
  panToActionValue?: PanToActionValue
  newFeatureSetActionValue?: {
    value: { [layerID: string]: __esri.FeatureSet }
    promise?: Promise<any>
  }
  changedFeatureSetActionValue?: { [layerID: string]: __esri.FeatureSet }
  selectFeatureActionValue?: IFeature[] | __esri.Graphic[]
  flashActionValue?: {
    layerDataSourceId: string
    querySQL: string
  }
  filterActionValue?: {
    layerDataSourceId: string
    querySQL: string
  }
  showOnMapDatas?: ShowOnMapDatas
  addToMapDatas?: AddToMapDatas
}

interface ExtraMapWidgetProps {
  mutableStateProps?: ActionRelatedProps
  appMode: AppMode
  isPrintPreview: boolean
  queryObject: IMUrlParameters
  autoControlWidgetId: string
  isRunAppMode: boolean
  runtimeUrlHashParams: MapUrlHashParams
  mapTimeZone: string
}

export type MapWidgetProps = AllWidgetProps<IMConfig> & ExtraMapWidgetProps

interface State {
  startLoadModules: boolean
  widthBreakpoint: string
  widgetHeight: number
  isFullScreen: boolean
  dataActionDataSet: DataRecordSet
  mvtEnabled: boolean
  mvtMessage?: string
}

const fakeFullscreenClassName = 'fake-fullscreen-map'

export default class Widget extends React.PureComponent<MapWidgetProps, State> {
  parentContainer: HTMLElement
  container: HTMLElement
  containerClientRect: ClientRect | DOMRect
  multiSourceMapInstance: MultiSourceMap = null
  activeJimuMapView: JimuMapView = null
  watchSelectedFeatureHandle: __esri.WatchHandle = null
  dataActionListContainer: HTMLElement = null
  reactiveUtils: typeof __esri.reactiveUtils = null
  popupDomNodeObserver: MutationObserver = null
  readonly warningIcon: string
  private mvtLayerByViewId: Map<string, __esri.VectorTileLayer> = new Map()
  private mvtRequestInterceptorAdded = false

  constructor (props) {
    super(props)
    this.warningIcon = `<svg width="16" height="15" viewBox="0 0 16 15" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M7.09926 5.37004C7.04598 4.83729 7.46434 4.375 7.99975 4.375C8.53516 4.375 8.95353 4.83728 8.90025 5.37004L8.5495 8.87748C8.52126 9.15992 8.2836 9.375 7.99975 9.375C7.71591 9.375 7.47825 9.15992 7.45 8.87748L7.09926 5.37004Z" fill="#938500"/>
                        <path d="M7.99975 12.375C8.55204 12.375 8.99975 11.9273 8.99975 11.375C8.99975 10.8227 8.55204 10.375 7.99975 10.375C7.44747 10.375 6.99975 10.8227 6.99975 11.375C6.99975 11.9273 7.44747 12.375 7.99975 12.375Z" fill="#938500"/>
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M1.66642 14.375C0.9115 14.375 0.428811 13.5705 0.784067 12.9044L7.1174 1.02941C7.49387 0.323529 8.50564 0.323529 8.88211 1.02941L15.2154 12.9044C15.5707 13.5705 15.088 14.375 14.3331 14.375H1.66642ZM1.66642 13.375L7.99975 1.5L14.3331 13.375H1.66642Z" fill="#938500"/>
                        </svg>`
    this.state = {
      startLoadModules: false,
      widthBreakpoint: null,
      widgetHeight: null,
      isFullScreen: false,
      dataActionDataSet: null,
      mvtEnabled: false,
      mvtMessage: null
    }

    this.dataActionListContainer = document.createElement('div')
    this.dataActionListContainer.className = 'data-action-list-wrapper'

    this.loadReactiveUtils()
  }

  getWidgetGlobalStyle () {
    return css`
    *:has(.fake-fullscreen-map) {
      transform: none !important;
      position: fixed !important;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: 1;
    }

    .widget-renderer > .widget-content:has(.fake-fullscreen-map) {
      z-index: 1;
    }
    `
  }

  getWidgetSyle () {
    return css`
      .map-component-container:fullscreen {
        background: white;

        .map-tool-popper, .map-tool-mobile-panel, .popper[role="dialog"] {
          z-index: 9 !important;
        }
      }

      .fake-fullscreen-map {
        position: fixed !important;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: white;
      }

      .multi-source-map:has(.fake-fullscreen-map) > .map-tool-layout {
        display: none;
      }

      .map-loading-bar {
        z-index: 8;
      }

      .map-warning-bar {
        z-index: 8;
        position: absolute;
        bottom: 4px;
        left: 4px;
        right: 4px;
        height: 35px;
        background: #fffdeb;
        border: 1px solid #fff592;
        display: flex;
        align-items: center;
        justify-content: flex-start;

        .warning-icon {
          width: 14px;
          margin: 0 12px 0 12px;
        }
      }

      .map-fix-layout {
        position: absolute !important;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        z-index: 7;
        pointer-events: none;
      }

      .hide-map-tools-layout .map-tool-layout{
        display: none;
      }

      .esri-view-root > .esri-ui {
        z-index: unset;
      }

      .esri-ui-manual-container .esri-swipe {
        z-index: 0;
      }

      .esri-ui .esri-popup {
        z-index: 9;
      }

      .data-action-list-wrapper {
        margin: 3px;
      }

      .mvt-toggle-container {
        position: absolute;
        top: 8px;
        right: 8px;
        z-index: 9;
        pointer-events: auto;
      }

      .mvt-toggle-button {
        border: 1px solid #d3d3d3;
        background: white;
        color: #323232;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
      }

      .mvt-toggle-button.is-active {
        background: #007ac2;
        color: white;
        border-color: #007ac2;
      }

      .mvt-status {
        margin-top: 6px;
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #e5e5e5;
        max-width: 220px;
      }
    `
  }

  getInnerContentStyle () {
    const theme = this.props.theme

    return css`
      position: relative;

      .map-is-live-mode {
        .exbmap-ui {
          pointer-events: auto !important;
        }

        .is-widget {
          pointer-events: auto !important;
        }
      }

      .widget-map-usemask {
        pointer-events: auto !important;
      }

      .map-is-design-mode {
        .exbmap-ui,
        .exbmap-ui-tool {
          pointer-events: none !important;
        }

        .is-widget {
          pointer-events: auto !important;
        }
      }

      .widget-map{
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        z-index: -1;
        .overview-container{
          position: absolute;
          top: 12px;
          right: 12px;
          width: 300px;
          height: 200px;
          border: 1px solid black;
          z-index: 1;
        }

        .extent-container{
          background-color: rgba(0, 0, 0, 0.5);
          position: absolute;
          z-index: 2;
        }

        .extent-btn-container{
          button{
            outline: none;
          }
          .previous-extent-btn{
            color: #111;
          }
          .next-extent-btn{
            color: #222;
          }
        }
      }

      .mapswitch-container {
        position: absolute;
        z-index: 7;
        width: 32px;
        height: 32px;
        bottom: 10px;
        left: 10px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3)
      }

      .mapswitch-icon {
        fill: black;
        left: 8px;
        top: 8px;
        position: absolute;
        display: block;
      }

      .widget-map-background {
        background-color: ${theme.ref.palette.white};
        position: absolute;
        z-index: 1;
      }

      .widget-map-crashed {
        background-color: ${polished.rgba(theme.ref.palette.white, 0.85)};
        position: absolute;
        z-index: 1;
        top: 0;

        .widget-map-crashed-label-padding {
          padding-left: ${polished.rem(24)};
          padding-right: ${polished.rem(24)};
        }

        .widget-map-crashed-label {
          font-size: ${polished.rem(13)};
          color: ${theme.ref.palette.black};
          font-weight: bold;
          text-align: center;
        }
      }

      @keyframes appear {
        0%{opacity:0}
        25%{opacity:.25}
        50%{opacity:.5;}
        75%{opacity:.75}
        100%{opacity:1;}
      }

      @keyframes disappear {
        0%{opacity:1}
        25%{opacity:.75}
        50%{opacity:.5;}
        75%{opacity:.25}
        100%{opacity:0;}
      }

      .multisourcemap-item-appear {
        animation: appear 300ms;
        -webkit-animation: appear 300ms;
        -moz-animation: appear 300ms;
        animation-fill-mode: forwards;
        -webkit-animation-fill-mode: forwards;
        -moz-animation-fill-mode: forwards;
        animation-timing-function: ease-in;
        -webkit-animation-timing-function: ease-in;
        -moz-animation-timing-function: ease-in;
      }

      .multisourcemap-item-disappear {
        animation: disappear 300ms;
        -webkit-animation: disappear 300ms;
        -moz-animation: disappear 300ms;
        animation-fill-mode: forwards;
        -webkit-animation-fill-mode: forwards;
        -moz-animation-fill-mode: forwards;
        animation-timing-function: ease-in;
        -webkit-animation-timing-function: ease-in;
        -moz-animation-timing-function: ease-in;
      }

      .multisourcemap-item-appear-noanimate {
        opacity: 1;
      }

      .multisourcemap-item-disappear-noanimate {
        opacity: 0;
      }
      `
  }

  static versionManager = versionManager

  static mapExtraStateProps = (state: IMState, props: AllWidgetProps<IMConfig>): ExtraMapWidgetProps => {
    let autoControlWidgetId = ''

    const mapWidgetId = props.id

    if (state.mapWidgetsInfo && mapWidgetId) {
      autoControlWidgetId = state.mapWidgetsInfo[mapWidgetId]?.autoControlWidgetId || ''
    }

    const appMode = state && state.appRuntimeInfo && state.appRuntimeInfo.appMode
    const isRunAppMode = appMode === AppMode.Run

    let runtimeUrlHashParams: MapUrlHashParams = null

    if (isRunAppMode && state.urlHashObject) {
      runtimeUrlHashParams = state.urlHashObject[mapWidgetId]
    }

    let mapTimeZone: string = ''
    const timeZoneInfo = state.appConfig?.attributes?.timezone

    if (timeZoneInfo) {
      if (timeZoneInfo.type === TimezoneConfig.Device) {
        mapTimeZone = 'system'
      } else if (timeZoneInfo.type === TimezoneConfig.Specific) {
        mapTimeZone = timeZoneInfo.value
      } else if (timeZoneInfo.type === TimezoneConfig.Data) {
        mapTimeZone = ''
      }
    } else {
      mapTimeZone = 'system'
    }

    return {
      appMode: appMode,
      isPrintPreview: state.appRuntimeInfo.isPrintPreview,
      queryObject: state.queryObject,
      autoControlWidgetId,
      isRunAppMode,
      runtimeUrlHashParams,
      mapTimeZone
    }
  }

  startRenderMap = () => {
    setTimeout(() => {
      this.setState({
        startLoadModules: true
      })
    }, 100)
  }

  componentDidMount () {
    if (!this.state.startLoadModules) {
      if (window.jimuConfig.isInBuilder || !this.props.config.canPlaceHolder) {
        this.startRenderMap()
      }
    }

    document.addEventListener('webkitfullscreenchange', this.onFullscreenChangeHandler)
    document.addEventListener('fullscreenchange', this.onFullscreenChangeHandler)
  }

  componentDidUpdate (prevProps: MapWidgetProps) {
    const preWidgetState = prevProps.state
    const currWidgetState = this.props.state
    if (preWidgetState !== currWidgetState) {
      const jimuMapViews = this.getJimuMapViews()
      jimuMapViews.forEach((jimuMapView) => {
        jimuMapView.setMapWidgetState(currWidgetState)
      })
    }

    const preShowPopupUponSelection = !!(prevProps?.config?.showPopupUponSelection)
    const curShowPopupUponSelection = !!(this.props?.config?.showPopupUponSelection)

    if (preShowPopupUponSelection !== curShowPopupUponSelection) {
      const jimuMapViews = this.getJimuMapViews()
      jimuMapViews.forEach((jimuMapView) => {
        this.setShowPopupUponSelectionForJimuMapView(jimuMapView)
      })
    }

    const preEnableDataAction = prevProps?.enableDataAction
    const currEnableDataAction = this.props.enableDataAction

    if (preEnableDataAction !== currEnableDataAction) {
      this.handleDataActionWhenPopupSelectedFeatureChange(this.activeJimuMapView)
    }
  }

  componentWillUnmount () {
    document.removeEventListener('webkitfullscreenchange', this.onFullscreenChangeHandler)
    document.removeEventListener('fullscreenchange', this.onFullscreenChangeHandler)

    const widgets = getAppStore().getState().appConfig.widgets

    if (!widgets[this.props.id]) {
      MutableStoreManager.getInstance().updateStateValue(this.props.id, 'restoreData', null)
    }
  }

  getJimuMapViews (): JimuMapView[] {
    let jimuMapViews: JimuMapView[] = []

    const jimuMapViewGroup = MapViewManager.getInstance().getJimuMapViewGroup(this.props.id)

    if (jimuMapViewGroup) {
      jimuMapViews = jimuMapViewGroup.getAllJimuMapViews()
    }

    return jimuMapViews
  }

  getPlaceHolderImage = () => {
    let placeHolderImage = this.props.config.placeholderImage
    const session = SessionManager.getInstance().getMainSession()
    if (placeHolderImage) {
      const isPortalThumbExp = new RegExp('^(.)+/sharing/rest/content/items/(.)+/info/(.)+')

      if (isPortalThumbExp.test(placeHolderImage)) {
        if (session) {
          placeHolderImage = placeHolderImage + `?token=${session.token}`
        } else {
          placeHolderImage = placeHolderImage
        }
      }
    }

    return placeHolderImage
  }

  onFullscreenChangeHandler = () => {
    const fullscreenElement = getFullscreenElement()
    const isCurrentMapFullScreen = fullscreenElement && fullscreenElement === this.container

    this.setState({
      isFullScreen: isCurrentMapFullScreen
    })
  }

  fullScreenMap = () => {
    const fullscreenEnabled = isFullscreenEnabled()

    if (fullscreenEnabled) {
      const fullscreenElement = getFullscreenElement()

      if (fullscreenElement === this.container) {
        exitFullscreen()
      } else {
        requestFullscreen(this.container)
      }
    } else {
      if (this.container.classList.contains(fakeFullscreenClassName)) {
        this.container.classList.remove(fakeFullscreenClassName)

        this.setState({
          isFullScreen: false
        })
      } else {
        this.container.classList.add(fakeFullscreenClassName)

        this.setState({
          isFullScreen: true
        })
      }
    }
  }

  handleViewGroupCreate = (viewGroup: JimuMapViewGroup) => {
    if (viewGroup) {
      viewGroup.setMapWidgetInstance(this)
    }
  }

  onJimuMapViewCreated = (jimuMapView: JimuMapView) => {
    jimuMapView.setMapWidgetState(this.props.state)
    this.setShowPopupUponSelectionForJimuMapView(jimuMapView)
    this.addMvtLayerToJimuMapView(jimuMapView)
  }

  onActiveJimuMapViewChange = (jimuMapView: JimuMapView) => {
    this.activeJimuMapView = jimuMapView
    this.watchPopupSelectedFeatureChange()
    this.addMvtLayerToJimuMapView(jimuMapView)
  }

  setShowPopupUponSelectionForJimuMapView (jimuMapView: JimuMapView) {
    if (jimuMapView) {
      jimuMapView.setShowPopupUponSelection(!!this.props.config.showPopupUponSelection)
    }
  }

  private toggleMvtLayer = async () => {
    const nextEnabled = !this.state.mvtEnabled

    this.setState({ mvtEnabled: nextEnabled }, () => {
      if (nextEnabled) {
        if (this.activeJimuMapView) {
          this.addMvtLayerToJimuMapView(this.activeJimuMapView)
        }
      } else {
        this.removeMvtLayers()
        this.setState({ mvtMessage: null })
      }
    })
  }

  private removeMvtLayers () {
    this.mvtLayerByViewId.forEach((layer, viewId) => {
      const jimuMapView = MapViewManager.getInstance().getJimuMapViewById(viewId)
      const map = jimuMapView?.view?.map
      if (map && layer && map.findLayerById(MVT_LAYER_ID)) {
        map.remove(layer)
      }
    })
    this.mvtLayerByViewId.clear()
  }

  private async addMvtLayerToJimuMapView (jimuMapView: JimuMapView) {
    if (!this.state.mvtEnabled) {
      return
    }

    if (!jimuMapView?.view?.map) {
      return
    }

    const viewId = jimuMapView.id
    if (this.mvtLayerByViewId.has(viewId)) {
      return
    }

    const [esriConfig, esriRequest, VectorTileLayer] = await loadArcGISJSAPIModules([
      'esri/config',
      'esri/request',
      'esri/layers/VectorTileLayer'
    ]) as [typeof __esri.config, typeof __esri.request, typeof __esri.VectorTileLayer]

    const mvtStyleUrl = MVT_STYLE_URL
    const mvtBearer = MANUAL_BEARER

    if (!mvtStyleUrl || !mvtBearer) {
      this.setState({ mvtMessage: 'MVT settings missing (style URL / bearer).' })
      return
    }

    if (!this.mvtRequestInterceptorAdded) {
      try {
        const mvtOrigin = new URL(mvtStyleUrl).origin
        esriConfig.request.interceptors.push({
          urls: [mvtOrigin],
          headers: {
            Authorization: `Bearer ${mvtBearer}`
          }
        })
        esriConfig.request.interceptors.push({
          urls: MVT_REQUEST_URL_REGEX,
          before: (params: __esri.RequestInterceptorBeforeCallbackParams) => {
            const headers = params?.requestOptions?.headers || {}
            params.requestOptions = {
              ...params.requestOptions,
              headers: {
                ...headers,
                Authorization: `Bearer ${mvtBearer}`
              }
            }
          }
        })
        this.mvtRequestInterceptorAdded = true
      } catch {
        // ignore malformed URL
      }
    }

    const existingLayer = jimuMapView.view.map.findLayerById(MVT_LAYER_ID) as __esri.VectorTileLayer
    if (existingLayer) {
      this.mvtLayerByViewId.set(viewId, existingLayer)
      return
    }

    try {
      this.setState({ mvtMessage: 'Loading MVT styleâ€¦' })
      const response = await esriRequest(mvtStyleUrl, {
        headers: {
          Authorization: `Bearer ${mvtBearer}`
        },
        responseType: 'json'
      })

      const styleJson = response?.data
      const mvtLayer = new VectorTileLayer({
        id: MVT_LAYER_ID,
        style: styleJson,
        elevationInfo: {
          mode: 'on-the-ground'
        },
        labelsVisible: true,
        opacity: 1,
        visible: true
      })

      const targetMap = jimuMapView.view.map
      targetMap.add(mvtLayer)
      if (targetMap.layers?.length) {
        targetMap.reorder(mvtLayer, targetMap.layers.length - 1)
      }
      this.mvtLayerByViewId.set(viewId, mvtLayer)

      await mvtLayer.load()
      const layerView = await jimuMapView.view.whenLayerView(mvtLayer)
      layerView.watch('updating', (updating) => {
        if (!updating) {
          this.setState({ mvtMessage: 'MVT layer rendered.' })
        }
      })
      jimuMapView.view.on('layerview-create-error', (event) => {
        if (event?.layer?.id === MVT_LAYER_ID) {
          const errorMessage = event?.error?.message || 'Layer view failed to create.'
          this.setState({ mvtMessage: `MVT layer view error: ${errorMessage}` })
          // eslint-disable-next-line no-console
          console.error('MVT layer view error:', event?.error)
        }
      })
      if (mvtLayer.fullExtent) {
        jimuMapView.view.goTo(mvtLayer.fullExtent).catch(() => {})
      }
      this.setState({ mvtMessage: 'MVT layer loaded (awaiting tiles)...' })
    } catch (err: any) {
      const message = err?.message || 'Unknown error'
      this.setState({ mvtMessage: `MVT failed: ${message}` })
      // eslint-disable-next-line no-console
      console.error('MVT layer failed to load:', err)
    }
  }

  private renderMvtToggle () {
    return (
      <div className='mvt-toggle-container'>
        <button
          type='button'
          className={classNames('mvt-toggle-button', { 'is-active': this.state.mvtEnabled })}
          onClick={this.toggleMvtLayer}
        >
          {this.state.mvtEnabled ? 'Hide MVT' : 'Show MVT'}
        </button>
        {this.state.mvtMessage && (
          <div className='mvt-status'>
            {this.state.mvtMessage}
          </div>
        )}
      </div>
    )
  }

  switchMap = async (ignoreSwitchAnimation = false): Promise<any> => {
    if (this.multiSourceMapInstance) {
      return await this.multiSourceMapInstance.switchMap(ignoreSwitchAnimation)
    } else {
      await Promise.resolve()
    }
  }

  setMultiSourceMapInstance = (instance: MultiSourceMap) => {
    this.multiSourceMapInstance = instance
  }

  onResize = (width, height) => {
    if (!width || !height) {
      return
    }

    if (width <= 545 && width > 0) {
      this.setState({
        widthBreakpoint: 'xsmall',
        widgetHeight: height
      })
    } else {
      this.setState({
        widthBreakpoint: 'other',
        widgetHeight: height
      })
    }
  }

  isLoadingDisplayed = () => {
    const addToMapDatas: AddToMapDatas = this.props.mutableStateProps?.addToMapDatas || {}
    return Object.values(addToMapDatas).some(value => value?.dataChangeStatus === DataChangeStatus.Pending)
  }

  isWarningDisplayed = () => {
    const addToMapDatas: AddToMapDatas = this.props.mutableStateProps?.addToMapDatas || {}
    return Object.values(addToMapDatas).some(value => value?.dataChangeStatus === DataChangeStatus.Rejected)
  }

  getInnerContent = (isMapInVisibleArea: boolean) => {
    if (!this.state.startLoadModules) {
      return (
        <div css={this.getInnerContentStyle()} className='w-100 h-100'>
          <div className='widget-map w-100 h-100'>
            <div style={{ position: 'absolute', left: '50%', top: '50%' }} className='jimu-secondary-loading' />
          </div>
        </div>
      )
    } else {
      if (!(this.props.useDataSources && this.props.useDataSources[0] && this.props.useDataSources[0].dataSourceId)) {
        return (
          <div className='w-100 h-100' ref={ref => { this.parentContainer = ref }}>
            <div
              css={this.getInnerContentStyle()} className='w-100 h-100 map-component-container'
              ref={ref => { this.container = ref }}
            >
              <div className={classNames('w-100 h-100', { 'map-is-design-mode': !checkIsLive(this.props.appMode) })}>
                <DefaultMap
                  fullScreenMap={this.fullScreenMap}
                  baseWidgetProps={this.props}
                  startLoadModules={this.state.startLoadModules}
                  isDefaultMap
                  setMultiSourceMapInstance={this.setMultiSourceMapInstance}
                  onViewGroupCreate={this.handleViewGroupCreate}
                  onJimuMapViewCreated={this.onJimuMapViewCreated}
                  onActiveJimuMapViewChange={this.onActiveJimuMapViewChange}
                  widgetHeight={this.state.widgetHeight}
                  widthBreakpoint={this.state.widthBreakpoint}
                  isFullScreen={this.state.isFullScreen}
                  isMapInVisibleArea={isMapInVisibleArea}
                  autoControlWidgetId={this.props.autoControlWidgetId}
                />
                {this.renderMvtToggle()}
              </div>
              <ReactResizeDetector handleWidth handleHeight onResize={this.onResize} />
            </div>
          </div>
        )
      } else {
        return (
          <div className='w-100 h-100' ref={ref => { this.parentContainer = ref }}>
            <div
              css={this.getInnerContentStyle()} className='w-100 h-100 map-component-container'
              ref={ref => { this.container = ref }}
            >
              <div className={classNames('w-100 h-100', { 'map-is-design-mode': !checkIsLive(this.props.appMode) })}>
                {this.props.useDataSources.length >= 1 &&
                  <MultiSourceMap
                    key={1}
                    fullScreenMap={this.fullScreenMap}
                    baseWidgetProps={this.props}
                    startLoadModules={this.state.startLoadModules}
                    ref={this.setMultiSourceMapInstance}
                    onViewGroupCreate={this.handleViewGroupCreate}
                    onJimuMapViewCreated={this.onJimuMapViewCreated}
                    onActiveJimuMapViewChange={this.onActiveJimuMapViewChange}
                    widgetHeight={this.state.widgetHeight}
                    widthBreakpoint={this.state.widthBreakpoint}
                    isFullScreen={this.state.isFullScreen}
                    isMapInVisibleArea={isMapInVisibleArea}
                    autoControlWidgetId={this.props.autoControlWidgetId}
                  />}
                {this.renderMvtToggle()}
              </div>
              <ReactResizeDetector handleWidth handleHeight onResize={this.onResize} />
            </div>
          </div>
        )
      }
    }
  }

  getCurrentPopupSelectedFeature (): __esri.Graphic {
    return this.activeJimuMapView?.view?.popup?.selectedFeature
  }

  async loadReactiveUtils () {
    [this.reactiveUtils] = await loadArcGISJSAPIModules(['esri/core/reactiveUtils']) as [typeof __esri.reactiveUtils]
    this.watchPopupSelectedFeatureChange()
  }

  async watchPopupSelectedFeatureChange () {
    if (this.watchSelectedFeatureHandle) {
      this.watchSelectedFeatureHandle.remove()
      this.watchSelectedFeatureHandle = null
    }

    const activeJimuMapView = this.activeJimuMapView

    if (!activeJimuMapView || !this.reactiveUtils) {
      return
    }

    if (this.getCurrentPopupSelectedFeature()) {
      this.handleDataActionWhenPopupSelectedFeatureChange(activeJimuMapView)
    }

    this.watchSelectedFeatureHandle = this.reactiveUtils.watch(
      () => activeJimuMapView?.view?.popup?.selectedFeature,
      async () => {
        this.handleDataActionWhenPopupSelectedFeatureChange(activeJimuMapView)
      }
    )
  }

  async handleDataActionWhenPopupSelectedFeatureChange (activeJimuMapView: JimuMapView) {
    const popup = activeJimuMapView?.view?.popup
    const originalSelectedFeature = popup?.selectedFeature

    if (this.dataActionListContainer.parentNode) {
      this.dataActionListContainer.parentNode.removeChild(this.dataActionListContainer)
    }

    this.releasePopupDomNodeObserver()

    await this.updateDataActionDataSet(null)

    const isDataActionEnabled = this.isDataActionEnabled()

    if (isDataActionEnabled && originalSelectedFeature) {
      const dataActionDataSet = await this.getDataActionDataSet(activeJimuMapView, originalSelectedFeature)

      if (this.getCurrentPopupSelectedFeature() !== originalSelectedFeature) {
        return
      }

      await this.updateDataActionDataSet(dataActionDataSet)

      if (this.getCurrentPopupSelectedFeature() !== originalSelectedFeature) {
        return
      }

      this.watchPopupDomNodeChange(popup)
    }
  }

  updateDataActionDataSet (dataActionDataSet: DataRecordSet): Promise<void> {
    return new Promise((resolve) => {
      this.setState({
        dataActionDataSet
      }, () => {
        resolve()
      })
    })
  }

  releasePopupDomNodeObserver () {
    if (this.popupDomNodeObserver) {
      this.popupDomNodeObserver.disconnect()
      this.popupDomNodeObserver = null
    }
  }

  watchPopupDomNodeChange (popup: __esri.Popup) {
    this.releasePopupDomNodeObserver()

    const popupDomNode = ((popup as any).domNode || (popup as any).container) as HTMLElement

    this.tryAppendDataActionListDomNodeToPopup(popupDomNode)

    const config = {
      childList: true,
      subtree: true
    }

    const callback = (mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          this.tryAppendDataActionListDomNodeToPopup(popupDomNode)
        }
      }
    }

    const observer = new MutationObserver(callback)
    observer.observe(popupDomNode, config)
    this.popupDomNodeObserver = observer
  }

  tryAppendDataActionListDomNodeToPopup (popupDomNode: HTMLElement) {
    const selector = 'calcite-action-bar[slot="action-bar"]'
    const popupActionsContainer = popupDomNode.querySelector(selector)

    if (popupActionsContainer && !popupActionsContainer.contains(this.dataActionListContainer)) {
      if (this.state.dataActionDataSet) {
        if (this.dataActionListContainer.parentNode) {
          this.dataActionListContainer.parentNode.removeChild(this.dataActionListContainer)
        }

        if (popupActionsContainer.firstChild) {
          popupActionsContainer.insertBefore(this.dataActionListContainer, popupActionsContainer.firstChild)
        } else {
          popupActionsContainer.appendChild(this.dataActionListContainer)
        }
      }
    }
  }

  async getDataActionDataSet (jimuMapView: JimuMapView, selectedFeature: __esri.Graphic) {
    let layerDataSource: DataSource = null

    try {
      layerDataSource = await this.getLayerDataSourceBySelectedFeature(jimuMapView, selectedFeature)
    } catch (err) {
      layerDataSource = null
      // eslint-disable-next-line no-console
      console.error('getLayerDataSourceBySelectedFeature error', err)
    }

    if (!layerDataSource) {
      const layer = selectedFeature.layer

      if (layer) {
        layerDataSource = layer[ExBAddedJSAPIProperties.EXB_DATA_SOURCE]
      }
    }

    if (layerDataSource) {
      const sourceLabel = layerDataSource.getLabel() || ''
      const stringKey = 'mapCurrentRecord'
      const dataSetName = this.props.intl.formatMessage({ id: stringKey, defaultMessage: defaultMessages[stringKey] }, { layerName: sourceLabel })
      const record = layerDataSource.buildRecord(selectedFeature)
      const dataSet: DataRecordSet = {
        dataSource: layerDataSource,
        name: dataSetName,
        type: 'current',
        records: [record]
      }

      return dataSet
    }

    return null
  }

  async getLayerDataSourceBySelectedFeature (jimuMapView: JimuMapView, selectedFeature: __esri.Graphic): Promise<DataSource> {
    let jimuLayerView: JimuLayerView = null

    const jimuLayerViewId = (selectedFeature as any).jimuLayerViewId

    if (jimuLayerViewId) {
      jimuLayerView = jimuMapView.jimuLayerViews[jimuLayerViewId]
    }

    if (!jimuLayerView) {
      const allJimuLayerViews = Object.values(jimuMapView.jimuLayerViews)

      if (selectedFeature.layer && selectedFeature.layer.declaredClass !== 'esri.layers.BuildingSceneLayer') {
        jimuLayerView = allJimuLayerViews.find(item => item.layer === selectedFeature.layer)
      }

      if (!jimuLayerView) {
        const sourceLayer = (selectedFeature as any).sourceLayer

        if (sourceLayer) {
          jimuLayerView = allJimuLayerViews.find(item => item.layer === sourceLayer)
        }
      }
    }

    if (!jimuLayerView) {
      return null
    }

    let layerDataSource = jimuLayerView.getLayerDataSource()

    if (!layerDataSource) {
      layerDataSource = await jimuLayerView.createLayerDataSource()
    }

    return layerDataSource
  }

  isDataActionEnabled () {
    return this.props.enableDataAction !== false
  }

  renderDataActionList () {
    const isDataActionEnabled = this.isDataActionEnabled()

    if (isDataActionEnabled && this.state.dataActionDataSet) {
      return ReactDOM.createPortal(
        <DataActionList
          widgetId={this.props.id}
          dataSets={[this.state.dataActionDataSet]}
          disableDataSourceLevelActions={true}
          listStyle={DataActionListStyle.Dropdown}
          hideGroupTitle={true}
        />,
        this.dataActionListContainer
      )
    }

    return null
  }

  render () {
    const isMapInVisibleArea = true // if you use visibility contexts, wire them here
    const dataActionList = this.renderDataActionList()

    return (
      <div className='jimu-widget arcgis-map' css={this.getWidgetSyle()}>
        <Global styles={this.getWidgetGlobalStyle()} />
        {this.getInnerContent(isMapInVisibleArea)}
        {dataActionList}
      </div>
    )
  }
}
